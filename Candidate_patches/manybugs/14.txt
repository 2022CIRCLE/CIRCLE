golden:
q[2].e = 99; q[2].b = 1;
inference:
#endif

return 0;
unsigned i;
return NULL;
return zero on success;
unsigned b;
unsigned r;
unsigned a;
/* maximum lookup bits, returns actual */
unsigned t;
unsigned v;
ush *e;
unsigned p;
unsigned f;
unsigned d;
return null;
unsigned n;
return 1;
/* i repeats in table every f entries */
unsigned m;
unsigned j;
unsigned s;
ush *d;
unsigned e;
*/
unsigned *p;
unsigned l;
return result;
unsigned h;
break;
ush *e; /* list of extra bits for non-simple codes */
int i;
#ifdef DEBUG
/*
free(b);
b = NULL;
i = 0;
free(t);
int r;
int m;
unsigned q;
unsigned u;
ush *p;
unsigned c[BMAX+1];
ush *t;
return (0);
/* pointer into c[], b[], or v[] */
unsigned c;
/* result: starting table */
unsigned i; unsigned j;
@endif
p = p;
#ifdef DIAGNOSTIC
if (b == NULL) return NULL;
unsigned k;
/* #endif
ush *b;
struct huft *u;
int h;
struct huft *q;
int b;
unsigned g;
#if 0
/* XXX */
int s;
return zero
struct huft *u[BMAX];
unsigned i = 0;
s = s;
/* result: starting table */ int *m;
ush *u;
t = t;
b[0] = '0';
struct huft *t;
int c;
struct huft *h;
ush *d; ush *e;
int n;
unsigned a = 0;
unsigned i; /* counter, current code */ unsigned j;
struct huft *p;
unsigned n = 0;
struct huft *r;
b = b;
unsigned i; /* counter, current code */
out:
v = v;
#endif /*
u[BMAX] = NULL;
;
printf("huft_buildn");
if (t == NULL) return NULL;
/* i repeats in table every f entry */
if (m == NULL) return NULL;
continue;
ush *m; /* maximum lookup bits, returns actual */
unsigned c[BMAX];
struct huft *v;
b[0] = 0;
printf("huft_build: %sn", b);
unsigned t = t;
ush *e = ush;
/* table level */
#ifdef NS_DEBUG
unsigned b = 0;
/* counter for codes of length k */ unsigned c[BMAX+1];
b[0] = NULL;
s = ush *e;
u[BMAX] = '0';
struct huft *i;
/* i repeats in table every f entries */ unsigned i;
if (b == NULL) return 0;
/* return zero on success */
unsigned b[0];
/* i repeats in table every f entries */ int g;
unsigned j; /* counter */
unsigned r = 0;
#ifdef INET6 #endif
if (b!= NULL) return NULL;
struct huft **t;
#ifdef XP_MAC
const struct huft *q;
b[0] = b[1];
struct huft *huft;
ush *d; /* list of base values for non-simple codes */
struct huft **h;
struct huft *u[BMAX+1];
ush *d = ush;
struct huft *e;
unsigned b[BMAX+1];
unsigned i; unsigned j; unsigned f;
ush *d; ush *e; ush *f;
unsigned i; /* counter, current code */ register unsigned j;
s = ush * e;
u[BMAX+1];
if (s == NULL) return NULL;
u[BMAX] = 0;
#if defined(XP_MAC) || defined(XP_MACOSX) #endif
u[BMAX+1] = '0';
unsigned b[BMAX];
/* list of base values for non-simple codes */ ush *e;
int m; /* maximum lookup bits, returns actual */
#ifdef __GNUC__
printf("huft_build()n");
/* table level */ unsigned i;
u[BMAX+1] = NULL;
struct huft *w;
u[BMAX-1] = '0';
unsigned f; /* i repeats in table every f entries */
struct huft *s;
#if defined(XP_MAC) || defined(XP_MACOSX)
printf("huft_build:n");
unsigned c[BMAX-1];
ush *d; ush *e; ush *p;
const struct huft *h;
register
printf("huft_build: ");
/* offset for codes of length k */ unsigned c[BMAX+1];
/* pointer into c[], b[], or v[] */ register
printf("huft_build failedn");
ush *e; ush *m;
/* i repeats in table every f entries */ unsigned a;
ush *d; ush *e; ush *t;
unsigned d; /* number of simple-valued codes (0..s-1) */
unsigned s; /* number of simple-valued codes (0..s-1) */
if (t == NULL) return 0;
ush *d = ush; ush *e = ush;
#endif /* result: starting table */
printf("huft_build (empty)n");
struct huft *u[BMAX-1];
/* list of base values for non-simple codes */
ush *e; /* list of extra bits for non-simple codes. */
printf("huft_build: huft_build failedn");
ush *d = 0; ush *e = 0;
/* zero length codes or an oversubscribed set of lengths */
/* pointer to c[], b[], or v[] */
/* i repeats in table every f entries */ int m;
b[0] = 0; b[1] = 0;
ush *d; ush *e; ush *m;
/* list of base values for non-simple codes */ ush *d;
unsigned i; /* counter for codes of length k */
unsigned i; /* counter, current code */ unsigned f;
unsigned a; /* counter for codes of length k */
ush *d; ush *e; ush *v;
struct huft *h[BMAX];
/* i repeats in table every f entries */ int i;
unsigned i; unsigned j; /* counter */
/* i repeats in table every f entries */ unsigned f;
return zero on success, one if the given code set is incomplete.
/* result: starting table */ /* maximum lookup bits, returns actual */
struct huft *u[BMAX++];
printf("huft_build: %dn", b);
ush *d; ush *e; ush *b;
const struct huft *huft;
/* result: beginning table */ int *m;
unsigned i; unsigned j; unsigned j;
/* iterate all values */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ h = h; /* counter for errors of length k */ h[BMAX+1]; /* bit length count table */ unsigned f; /* maximum lookup bits, returns actual */
/* sum_of_lines */ /* char* i; /* if the line length length is = 0 */ if (i == 0)  b = i; b = i; b = i; b = b;
/* max lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ u[BMAX] = &unsigned_a; /* max lengths, returns actual */ u[BMAX+1] = &unsigned_b;
/* FIXME: number of codes in table already built */ t = t;
/* double sum or offset, but %s, this is NULL */ ush = ush_end;
/* this code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *huft = (struct huft *) huft_list; struct huft *huft;
/* not enough space */
if (! b && m)  return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed = N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
ush *m;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0)  /* no single single entry. */ if (m = 0)  /* * not supported, only work if it returns the non-simple code. */ if (m >= 0)  /* "none" is a valid value. */ if (m >= 0)  /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* a return zero for 0. */
/* offsets for maximum size, returns actual */
/* int count table */
/* limit is not yet supported */ /* * XXX */ /* i only works for the given code lengths */ if (m == 0) i = 0; else i = 0;
/* bempty b and bempty s. */ bempty b;
/* count of zero length codes */ if (!m)  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed = N_MAX) */ unsigned s; /* number of of simple-value
if (n = 0)  if (((*f) - m) >= 0)  *f = p;  else  *f = p;
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed = N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/*n't got any special huft numbers for an %s and bits. */ if (huft_build(b, d, s, e, t, m)) huft_build(b, d, e, t, m);
/* start of integer. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* limit to a number of zero length codes */ if (assumed = N_MAX)  /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* skip from the code lengths */ ush *d;
/* if the base u'unsigned' set, then set the full table size.
/* d -= c */ /* number of non-simple codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /*
/* this should be fixed. */
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *u[BMAX];
/* this code has the byte number of bits in the list */ unsigned i;
/* if any */ return zero on success;
/* if it's just the 'huft' code. */ if (b == NULL)  /* the huft table is null */ if (huft_set_code(b, n, s, e, t, m) == -1) huft_write_code(b, n, s, e, t, m); huft_write_code(b, n, s, s, e, t, m);
if (e.b == NULL)  if (m  ctrlen(e))  f = e;  if (m  ctrlen)  f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* ** Delete any remaining pages. */
/* if not allowed, just ignore the name of a table in the table. */ if (b)  if ((u[BMAX]!= '0') && b[BMAX]!= '0')  /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0'))  /* Remove table */
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS)  s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t)  unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* int the number of n_simple_codes in bits (assumed = N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* not possible for huft_building */ /* for static symbols in huft_building */ struct huft *huft; /* start from NULL*/
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i)  if (m)  /* XXX */ m = m->m_uname; m = m->m_uname;  if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname;  if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname;  else  m->m_uname = m->m_uname;
if (!isdef && m) return NULL;
/* * No data to decode. */ b.p_declarations = 0;
ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* renameable */
/* f  0x2b */
if (v)  v->i = v;
if (e  0)  ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* * Remove all bits p. */
/* Ignore pending code names */ if (b!= NULL)  /* Ignore pending code names */ if (b >= 0)  ush *d; ush *e; ush *b = NULL;  ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
if ((b & 0xffffff)!= 0)  /* not used in current table */
/* start is unsigned long, int is non-negative */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p; /* pointer into c[
/* * * Then it is not required to get a real version of * the code for the decoder. */ struct huft **t; /* /* * It may be a function that may be ptr at the top of the code with the table. */ if (t!= 0) return (0);
/* * Make sure the list of keys is _b, _n. This function should always be __id__ for the base value. */ if (t!= NULL)  ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b == NULL)  unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL)  unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* num of static symbols in static table (int h) */ u[H_ARGI_LENGTH];
/* remove long a; */ if (m > 0)  /* list of table values for non-simple codes */ ush *m; /* list of extra bits for non-simple codes */ if (! ush_d) ush_d = ush_d;
ush *d; ush *e; ush *s; /* list of extra bits for non-simple codes */ struct huft **t;
/* set size of table to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ ush *d; /* number of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k *
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned h; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* maximum code length */ unsigned f; /* maximum number of bits in current code */ unsigned l
/* if (c[I] > -1)  /* offset for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum size */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned c[I]; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count count table */ unsigned f; /* i repeats in table every f entries */ unsigned h; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* maximum length lengths/
unsigned j; /* counter */ register int k; /* number of bits in current code */ register unsigned j; /* counter */ register int q; /* number of bits in current code */ unsigned l; /* number of bits per table (returned in m) */ register unsigned *p;
/* double check length, only for the lengths. */ if (m > 0) return zero (m + huft_build, a);
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned l; /* bits per table (returned in m) */ register unsigned p; /* pointer into c[], b[], or v[] */
/* offset for bits in current code */ unsigned b[BMAX+1]; /* bit length count table */ unsigned f; /* count of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for bits in current code */ unsigned u[BMAX+1]; /* bit length count table */ unsigned f; /* counter */ register unsigned f; /* i repeats in table every f entries */ int g; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int l; /* number of bits in current code */ unsigned
if (! v[0]) return v[0];
/* XXX should we start a new entry? */ hdr_set_unsigned(&huft_symbols); hdr_set_unsigned(&huft_symbols);
/* 0x1 - m0.ac.m0 - m0.b0 - m0.a0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0.b0 - m0
unsigned d = &s;
/* huft_save code to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* offset table level */ register unsigned f; /* counter, current code */ register unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p; /* pointer into c[], b[], or v[] */ register struct huft *u[BMAX]; /* number of bits in current code */ int q; /* number of
/* if this has the huft_lock? */ huft_lock = NULL; /* * Remove the block to the huft_lock. */ huft_lock = NULL;
/* if defined(XP_WIN) &&!defined(XP_MAC))  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
/* if the values are not null, set a rescount in the number of huft_mtx_keys. */
/* initialize for free code length */ ush *e; /* invalidate for free code length */
/* long i; /* i repeats in table every f entries */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* number of bits in current code */ int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of bits in current code */ struct huft *u[BMAX]; /* number of simple-valued codes (0..s-1) */ unsigned s; /* number of simple-valued codes (0..s-1) */ unsigned s; /* number of simple-valued codes (0..s
/* check for error codes. */ if (c[0] == '0') return (-1);
if (f) f->__free(f);
/* if (I'm using NULL_PRIVATE)  /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1])  /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  /* limit for all zero length codes */  b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (u[DIRUNKNOWN] == '0') ush *e;
/* length of the table length */ ush *m;
/* * -if n = d..s.__procsize; */
/* free the table */ /* free the table in the table */ /* free the table from the table*/ /* free the table if not used */ /* free the table*/ /* free the table if necessary */
if (b)  unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
if (m)  /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m)  /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m];  if (m == NULL)  /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL)  if (m == NULL)  m = a[m];  m = a[m]; m = a[m];  else if (m == NULL)  m = a[m];   if (m == NULL)  m = a[m];  if (m == NU
/* it's possible to * use 'huft_build' to decode that set of codes. */
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p; /* pointer into c[], b[], or v[] */ register struct huft *u[BMAX]; /* pointer into c[],
/* pointer into c[], b[], or v[] */ struct huft *p;
/* this has to be */ /* we got the * unsigned t */ /* i t, * i t, j t, j m */
unsigned i; /* counter, current code */ unsigned j; /* counter */ register int h; /* i repeats in table every f entries */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int l; /* bits per table (returned in m) */ register unsigned p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* pointer into q[], or v[] */ struct huft *e; /* number of simple-valued codes (0..s-1) */ unsigned s; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* no more ufts */ /* not less than the huft_add_pointer */
/* n--: This is unsigned in this case and it's a zero length code, and a set of table size. */ ush *s; ush *e; ush *m; ush *m; ush *e; ush *d; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; ush *d; ush *e; ush *e; ush *e; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i  b) i--; /* number of of codes (assumed = N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] = N_MAX)  /* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* if we are a huft_mbufs, we will free up the tables */ ush *m;
/* set the number of pending codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned g; /* maximum code length */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int h; /* maximum code length */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of static const code lengths */ unsigned s; /* number of static const code lengths */ unsigned s; /* number of static const
/* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
unsigned r = r;
/* this is a recursive sequence */ huft_returns(b, t, e);
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len  v) || (v == v))  unsigned a = b[0]; if ((len  v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v))  unsigned i = v[0]; if (v == v)  unsigned j = v[1]; if (v == v)  unsigned i = v[1]; if (v == v)  unsigned i = v[1];
/* pointer into c[], b[], or v[] */ struct huft *q; /* pointer into current table */ struct huft *s; /* pointer into c[], b[], or v[] */ struct huft *v; /* pointer into c[], b[], or v[] */ struct huft *u[BMAX]; /* pointer into c[], b[], or v[] */ struct huft *r; /* pointer into c[], b[], or v[] */ struct huft *u[BMAX]; /* pointer into c[], b[], or v[] */ struct huft *r; /* pointer into c[], b[], or v[] */ struct huft *q; /* pointer into c
/* t's '0' */ if (p == -1)  return 0;
ush *p; /* if a table was nil, then there are any special ones. */ if (p[M]) ush *p = p[M]; else  p[M] ='';
/* ret = NULL;
/* * If there is a map of symbols, we'll need to remove the maps of the index from the index. */ if (*thesaved == NULL) return NULL;
unsigned b = a;
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '0'; else u[BMAX+1] = '0';
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  if (g.get_size() == 0)  b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0)  d[0] = NULL; d[1] = NULL; d[2] = NULL;  /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#if defined(DEBUG_ENABLE) &&!defined(DEBUG_ENABLE_FREE) /* ieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
/* free the source code. */ unsigned i;
/* no huft */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a  m && l  m && r  m)  /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m  m)  ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code  'n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* max is a minimum of ns of length. */ /* initialize the space of csa xmalloc(s); /* check for nsa xmalloc (s) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* no space in the variable name register */ u[BMAX] = v[BMAX];
if (b)  /* code lengths in bits (all assumed = BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
unsigned t = v;
/* * Check that we don't set any decode values. */ if (i == 0)  if (n == 0)  /* set un */ /* not */ ush *e;   else  /* no decode values. */ ush *i = 0;  if (i = 0)  /* no decode values. */ ush *i = 0;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s))  if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s))  if((b[5] >= s) || (b[5] = s))  if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s))  if((b
/* XXX avoid building in this case, the size of the table can be smaller than a value in the table's size. */ ush *e = ush *d; ush *e = ush *e; ush *d = ush *d; ush *e = ush *e; ush *e = ush *e; ush *e; ush *e = ush *e; ush *e = ush *e; ush *e = ush *e; ush *d; ush *d; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e; ush *e;
/* make sure we have all the cds to recompile them. */ if (!is_saved)  ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned b; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int l; /*
/* int m; /* int lookup bits, returns actual */ if (m == 0)  /* if we have code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned j; /* counter */ register int g; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes.
/* n-- has no uft values */ if (b >= 0)  unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0)  unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* this code will be NULL, and the new table size will be empty */ unsigned p;
/* if any of the tables are currently created in this case, check if any tables have been created */ if (syntax)  syntax = (struct huft *)syntax;
if (b > 0)  /* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* number of pending voids */ ush *d; /* number of pending voids */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter,
/* check if we have a valid code. */
/* remove all other zero length codes */
#ifdef XP_MAC if (a == 0)  b = 0;  else  /* XP_MAC -> t::acc_b */ if (a == 0)  b = 0;  else  b = 0;  #endif
ush *d; ush *e; /* list of extra bits for non-simple codes */
/* huft_required - p: to return zero on success, two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (f == '0')  f = (struct huft *) s;
/* if not in_table_cond, we need to get * b[0].fsh */ if (u[0].fsh == 0) b[1].fsh = 0; /* XXX*/
/* no other symbols, return zero on success, zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned h; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* maximum code length */ unsigned f; /* maximum size */ unsigned f; /* maximum code length */ unsigned
/* check in the list of other values. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* points to current table */ struct huft *u[BMAX]; /* check in the list of values (assumed = N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still
/* offset of 1 bits in size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned j; /* counter */ register int k; /* counter, current code */ unsigned j; /* counter */ register int j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ struct huf
/* * If we've got some bits of code lengths */ s = unsigned c[BMAX+1]; /* first read from it and print on all zero length codes */ p = p; /* table level */ s = s + (s + s); s = s + (s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s
unsigned p; /* add of chunks in the stack */ s; /* amount of chunks */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
/* skip */
/* c and c_count, or j */ u[S_MATCH_ARGS];
/* * We don't know if the table is empty or is empty */
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */  unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned j; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p;
/* * n's are set here. */ p = (struct huft *) b;
/* * Check for the first entry of the inode. This has to be sure to have * a table in the specified list. */ ush *d; ush *e; ush *e; ush *e; ush *e; ush *t;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long long, for this slot of hufts and int slot. */
/* count f entries */
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "", &unsigned u)) fstr = "", s;
/* xXX :: i */ /* b*/ b;
/* for the end of a table. */ ush = e; ush = e;
if (flags & OH_BUG) huft_free(&flags);
/* remove from the code list */ /* remove from the table size */ unsigned i; /* remove from the code list */ unsigned j; /* remove from the table size */ unsigned f; /* remove from the table size */ unsigned f;
#ifdef INCLUDE_XUL if (!(b == b->xul))  return 0;  #endif
/* in the queue if a table is empty, return zero on success, one if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if this is an error - just raise an error. */
/* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s); /* free (s

/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (v) <v->i = v;
/* long length code 'n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* set size of table to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ ush *d; /* number of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k *
/* start of integer. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
if (b > 0) /* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* * Make sure the list of keys is _<b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* long length code &'&n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* limit to a number of zero length codes */ if (assumed <= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (e 0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e.b == NULL) if (m ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* max is a minimum of ns of length. */ /* initialize the space of csa xmalloc(s); /* check for nsa xmalloc (s) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '0'; else u[BMAX+1] = '&0';
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code <'&n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (e.b == NULL) if (m <ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _<b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* long length code <'n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* * Make sure the list of keys is _b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* limit to a number of zero length codes */ if (assumed <= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* * Make sure the list of keys is _&b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if it's just the 'huft' code. */ if (b == NULL) </* the huft table is null */ if (huft_set_code(b, n, s, e, t, m) == -1) huft_write_code(b, n, s, e, t, m); huft_write_code(b, n, s, s, e, t, m);
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* number of pending voids */ ush *d; /* number of pending voids */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter,
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
printf("huft_build (empty)n");
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* * Make sure the list of keys is _<b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Make sure the list of keys is _b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "", &unsigned u)) fstr = "<", s;
/* * Make sure the list of keys is _<b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* long length code <'n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* limit to a number of zero length codes */ if (assumed = N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* huft_required - p: to return zero on success, two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (f == '0') <f = (struct huft *) s;
#ifdef XP_MAC if (a == 0) <b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '&0'; else u[BMAX+1] = '<0';
/* t's '<0' */ if (p == -1) <return 0;
if (n <= 0) if (((*f) - m) >= 0) &*f = p; <else *f = p;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* long length code &'&n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code <'n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* long length code <'n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* count of zero length codes */ if (!m) <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed &= N_MAX) */ unsigned s; /* number of of simple-value
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) &if (m ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* max is a minimum of ns of length. */ /* initialize the space of csa xmalloc(s); /* check for nsa xmalloc (s) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
if (n <= 0) &if (((*f) - m) >= 0) &*f = p; &else *f = p;
return NULL;
if (n &= 0) if (((*f) - m) >= 0) *f = p; else *f = p;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
#ifdef XP_MAC if (a == 0) b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '<0'; else u[BMAX+1] = '0';
/* * Make sure the list of keys is _&b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (n = 0) if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* long length code <'&n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef XP_MAC if (a == 0) b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
printf("huft_build:n");
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (e <0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
if (n <= 0) <if (((*f) - m) >= 0) *f = p; &else *f = p;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
u[BMAX-1] = '<0';
#ifdef XP_MAC if (a == 0) &b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) if (m &ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (b > 0) &/* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
if (n <= 0) if (((*f) - m) >= 0) *f = p; <else *f = p;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code &'<n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
#ifdef XP_MAC if (a == 0) <b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* long length code 'n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* * Make sure the list of keys is _&b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (e.b == NULL) if (m <ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Make sure the list of keys is _<b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e &0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed = N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* int m; /* int lookup bits, returns actual */ if (m == 0) </* if we have code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned j; /* counter */ register int g; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes.
/* limit to a number of zero length codes */ if (assumed = N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* long length code <'n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* count of zero length codes */ if (!m) <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed = N_MAX) */ unsigned s; /* number of of simple-value
if (n = 0) <if (((*f) - m) >= 0) *f = p; <else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (e.b == NULL) if (m &ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e.b == NULL) &if (m ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* d -= c */ /* number of non-simple codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /*
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (n &= 0) if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e.b == NULL) &if (m <ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] <= N_MAX) </* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code '<n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
printf("huft_build:<n");
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n <= 0) if (((*f) - m) >= 0) *f = p; else *f = p;
if (b == NULL) <unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) &unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code '&n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
/* limit to a number of zero length codes */ if (assumed <= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
#ifdef XP_MAC if (a == 0) <b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] &= N_MAX) /* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code &'n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* int m; /* int lookup bits, returns actual */ if (m == 0) &/* if we have code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned j; /* counter */ register int g; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes.
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e.b == NULL) if (m ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e.b == NULL) &if (m ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Make sure the list of keys is _&b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code <'<n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* long length code &'<n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (e.b == NULL) &if (m &ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* limit to a number of zero length codes */ if (assumed <= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* long length code &'n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
unsigned p; /* add of chunks in the stack */ s; /* amount of chunks */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned j; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* check for error codes. */ if (c[0] == '0') return (-1);
/* sum_of_lines */ /* char* i; /* if the line length length is &= 0 */ if (i == 0) b = i; b = i; b = i; b = b;
if (n &= 0) <if (((*f) - m) >= 0) *f = p; else *f = p;
/* long length code '<n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (n <= 0) <if (((*f) - m) >= 0) <*f = p; else *f = p;
/* limit to a number of zero length codes */ if (assumed &= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* limit to a number of zero length codes */ if (assumed = N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
printf("huft_build (empty)<n");
/* if (c[I] > -1) </* offset for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum size */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned c[I]; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count count table */ unsigned f; /* i repeats in table every f entries */ unsigned h; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* maximum length lengths/
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (e.b == NULL) if (m &ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i <b) i--; /* number of of codes (assumed &= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
if (e.b == NULL) if (m ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code &'<n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
if (b) unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* long length code &'&n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e.b == NULL) if (m ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n &= 0) <if (((*f) - m) >= 0) <*f = p; &else *f = p;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* * Make sure the list of keys is _&b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _<b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
u[BMAX+1] = '<0';
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
ush *p; /* if a table was nil, then there are any special ones. */ if (p[M]) ush *p = p[M]; else &p[M] ='';
/* long length code '<n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) <b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* long length code &'n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n <= 0) &if (((*f) - m) >= 0) *f = p; <else *f = p;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* long length code &'<n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (b == NULL) &unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) &unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* limit to a number of zero length codes */ if (assumed = N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef INCLUDE_XUL if (!(b == b->xul)) &return 0; #endif
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef XP_MAC if (a == 0) b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
printf("huft_build()&n");
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '&0'; else u[BMAX+1] = '0';
if (n = 0) if (((*f) - m) >= 0) <*f = p; else *f = p;
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
if (e.b == NULL) &if (m ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* limit to a number of zero length codes */ if (assumed &= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (e.b == NULL) if (m <ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (b) &/* code lengths in bits (all assumed <= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* d -= c */ /* number of non-simple codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /*
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e.b == NULL) &if (m ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* sum_of_lines */ /* char* i; /* if the line length length is = 0 */ if (i == 0) <b = i; b = i; b = i; b = b;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e &0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
ush *p; /* if a table was nil, then there are any special ones. */ if (p[M]) ush *p = p[M]; else p[M] ='';
/* f <0x2b */
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (n = 0) &if (((*f) - m) >= 0) <*f = p; &else *f = p;
printf("huft_build: %dn", b);
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n &= 0) &if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (n = 0) <if (((*f) - m) >= 0) *f = p; else *f = p;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) &b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* * No data to decode. */ b.p_declarations = <0;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (u[DIRUNKNOWN] == '<0') ush *e;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code <'<n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* number of pending voids */ ush *d; /* number of pending voids */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter,
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e 0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
#ifdef XP_MAC if (a == 0) &b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* limit to a number of zero length codes */ if (assumed <= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
if (e &0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* * Make sure the list of keys is _<b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* d -= c */ /* number of non-simple codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /*
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "<", &unsigned u)) fstr = "&", s;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (n &= 0) <if (((*f) - m) >= 0) &*f = p; else *f = p;
/* * Make sure the list of keys is _&b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b == NULL) <unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* * Make sure the list of keys is _b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
#ifdef XP_MAC if (a == 0) b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* * Make sure the list of keys is _&b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* long length code '&n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* start of integer. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (! b && m) &return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed <= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* remove long a; */ if (m > 0) </* list of table values for non-simple codes */ ush *m; /* list of extra bits for non-simple codes */ if (! ush_d) ush_d = ush_d;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Make sure the list of keys is _<b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* if any of the tables are currently created in this case, check if any tables have been created */ if (syntax) syntax = (struct huft *)syntax;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* long length code '<n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (e.b == NULL) &if (m <ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Make sure the list of keys is _b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
u[BMAX+1] = '0';
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) <if (m <ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* huft_required - p: to return zero on success, two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (f == '0') &f = (struct huft *) s;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] = N_MAX) &/* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef XP_MAC if (a == 0) b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * Make sure the list of keys is _&b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (n = 0) &if (((*f) - m) >= 0) &*f = p; else *f = p;
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] <= N_MAX) /* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* long length code <'&n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* make sure we have all the cds to recompile them. */ if (!is_saved) <ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* limit to a number of zero length codes */ if (assumed <= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* long length code <'<n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (b) <unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n <= 0) &if (((*f) - m) >= 0) &*f = p; else *f = p;
if (e.b == NULL) if (m ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* limit to a number of zero length codes */ if (assumed = N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "", &unsigned u)) fstr = "&", s;
#ifdef XP_MAC if (a == 0) <b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* long length code '<n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) <s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
if (n <= 0) <if (((*f) - m) >= 0) &*f = p; <else *f = p;
/* int the number of n_simple_codes in bits (assumed = N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (n <= 0) if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
printf("huft_build: %sn", b);
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (n &= 0) if (((*f) - m) >= 0) &*f = p; else *f = p;
if (n = 0) if (((*f) - m) >= 0) *f = p; &else *f = p;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* long length code &'n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed &= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* * Make sure the list of keys is _b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
if (n &= 0) &if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned j; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
ush *p; /* if a table was nil, then there are any special ones. */ if (p[M]) ush *p = p[M]; else <p[M] ='';
if (b) /* code lengths in bits (all assumed = BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (e.b == NULL) <if (m ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef XP_MAC if (a == 0) &b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) <b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
#ifdef XP_MAC if (a == 0) b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* n-- has no uft values */ if (b >= 0) unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) <unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* sum_of_lines */ /* char* i; /* if the line length length is &= 0 */ if (i == 0) &b = i; b = i; b = i; b = b;
/* n-- has no uft values */ if (b >= 0) &unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
#ifdef XP_MAC if (a == 0) b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef XP_MAC if (a == 0) &b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef XP_MAC if (a == 0) &b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* * Make sure the list of keys is _&b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (e.b == NULL) &if (m &ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '&0'; else u[BMAX+1] = '&0';
/* long length code '&n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] = N_MAX) /* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
if (n = 0) if (((*f) - m) >= 0) &*f = p; <else *f = p;
#ifdef INCLUDE_XUL if (!(b == b->xul)) return 0; #endif
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
unsigned p; /* add of chunks in the stack */ s; /* amount of chunks */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
if (e.b == NULL) if (m &ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (! b && m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed &= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* a return zero for &0. */
if (b == NULL) unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) &unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e.b == NULL) <if (m ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i <b) i--; /* number of of codes (assumed <= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
if (e.b == NULL) if (m ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* sum_of_lines */ /* char* i; /* if the line length length is <= 0 */ if (i == 0) b = i; b = i; b = i; b = b;
if (e.b == NULL) &if (m &ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef XP_MAC if (a == 0) <b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i b) i--; /* number of of codes (assumed <= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i b) i--; /* number of of codes (assumed = N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef XP_MAC if (a == 0) b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef XP_MAC if (a == 0) <b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* limit to a number of zero length codes */ if (assumed <= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Make sure the list of keys is _<b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Make sure the list of keys is _<b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b) <unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* sum_of_lines */ /* char* i; /* if the line length length is <= 0 */ if (i == 0) &b = i; b = i; b = i; b = b;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* t's '0' */ if (p == -1) &return 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n = 0) <if (((*f) - m) >= 0) <*f = p; &else *f = p;
/* * Make sure the list of keys is _b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* long length code <'<n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (b == NULL) unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n &= 0) &if (((*f) - m) >= 0) *f = p; <else *f = p;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned b; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int l; /*
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (n &= 0) if (((*f) - m) >= 0) <*f = p; else *f = p;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (v) v->i = v;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n = 0) if (((*f) - m) >= 0) *f = p; <else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (n &= 0) if (((*f) - m) >= 0) *f = p; &else *f = p;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (n &= 0) if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* * Make sure the list of keys is _<b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * No data to decode. */ b.p_declarations = &0;
if (! b && m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed = N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) &if (m <ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* set size of table to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ ush *d; /* number of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k *
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (n <= 0) <if (((*f) - m) >= 0) *f = p; else *f = p;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (e.b == NULL) <if (m ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* long length code '&n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n = 0) &if (((*f) - m) >= 0) &*f = p; <else *f = p;
/* check in the list of other values. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* points to current table */ struct huft *u[BMAX]; /* check in the list of values (assumed = N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still
if (n <= 0) <if (((*f) - m) >= 0) <*f = p; <else *f = p;
if (n = 0) if (((*f) - m) >= 0) <*f = p; &else *f = p;
if (e 0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* a return zero for &0<. */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* remove long a; */ if (m > 0) &/* list of table values for non-simple codes */ ush *m; /* list of extra bits for non-simple codes */ if (! ush_d) ush_d = ush_d;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
printf("huft_build: huft_build failed&n");
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (e.b == NULL) if (m &ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (e.b == NULL) &if (m &ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Make sure the list of keys is _<b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Make sure the list of keys is _b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* int m; /* int lookup bits, returns actual */ if (m == 0) /* if we have code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned j; /* counter */ register int g; /* counter for code lengths and a maximum table size, make a set of tables to decode that set of codes.
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if any of the tables are currently created in this case, check if any tables have been created */ if (syntax) &syntax = (struct huft *)syntax;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "&", &unsigned u)) fstr = "", s;
/* long length code &'n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n <= 0) <if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* make sure we have all the cds to recompile them. */ if (!is_saved) ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (e.b == NULL) <if (m <ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (n &= 0) &if (((*f) - m) >= 0) *f = p; &else *f = p;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef XP_MAC if (a == 0) b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
#ifdef XP_MAC if (a == 0) b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) &if (m ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* int the number of n_simple_codes in bits (assumed <= N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* * Make sure the list of keys is _<b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef XP_MAC if (a == 0) b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef XP_MAC if (a == 0) &b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i <b) i--; /* number of of codes (assumed = N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
if (e.b == NULL) <if (m <ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * No data to decode. */ b.p_declarations = &0<;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (e.b == NULL) if (m &ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Make sure the list of keys is _<b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check in the list of other values. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* points to current table */ struct huft *u[BMAX]; /* check in the list of values (assumed <= N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* make sure we have all the cds to recompile them. */ if (!is_saved) <ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* make sure we have all the cds to recompile them. */ if (!is_saved) ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* * Make sure the list of keys is _<b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e.b == NULL) <if (m &ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
u[BMAX-1] = '&0';
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
printf("huft_build: %s<n", b);
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) &s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* start of integer. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef XP_MAC if (a == 0) &b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _<b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Make sure the list of keys is _b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) if (m &ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (n &= 0) if (((*f) - m) >= 0) <*f = p; &else *f = p;
/* * Make sure the list of keys is _&b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (e.b == NULL) <if (m <ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
#ifdef XP_MAC if (a == 0) <b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (n &= 0) &if (((*f) - m) >= 0) &*f = p; else *f = p;
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) if (m ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n <= 0) <if (((*f) - m) >= 0) <*f = p; &else *f = p;
if (n = 0) if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* * Make sure the list of keys is _b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "<", &unsigned u)) fstr = "", s;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) <b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (n &= 0) &if (((*f) - m) >= 0) *f = p; else *f = p;
if (e.b == NULL) &if (m &ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (e.b == NULL) &if (m <ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (e.b == NULL) &if (m &ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
u[BMAX] = '<0';
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
return 0;
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* long length code <'<n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (b) &unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (b) &/* code lengths in bits (all assumed &= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) if (m ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef XP_MAC if (a == 0) &b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* n-- has no uft values */ if (b >= 0) &unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) &unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) <b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* long length code <'&n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
printf("huft_build: %d<n", b);
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e.b == NULL) &if (m &ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n <= 0) &if (((*f) - m) >= 0) *f = p; &else *f = p;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (n <= 0) if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed &= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
if (e.b == NULL) <if (m ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if any of the tables are currently created in this case, check if any tables have been created */ if (syntax) <syntax = (struct huft *)syntax;
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed = N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* * No data to decode. */ b.p_declarations = <0<;
/* * Make sure the list of keys is _<b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (! b && m) <return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed &= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
if (n <= 0) &if (((*f) - m) >= 0) &*f = p; <else *f = p;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* long length code &'n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (n = 0) &if (((*f) - m) >= 0) &*f = p; &else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code 'n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (b > 0) &/* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
printf("huft_build (empty)&n");
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
#ifdef XP_MAC if (a == 0) &b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (n = 0) <if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* limit to a number of zero length codes */ if (assumed <= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
#ifdef XP_MAC if (a == 0) <b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
#ifdef XP_MAC if (a == 0) &b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* make sure we have all the cds to recompile them. */ if (!is_saved) ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* long length code '<n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (e.b == NULL) if (m <ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Make sure the list of keys is _<b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* * Make sure the list of keys is _b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b > 0) /* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* count of zero length codes */ if (!m) <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed <= N_MAX) */ unsigned s; /* number of of simple-value
/* * Make sure the list of keys is _&b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (n &= 0) <if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* * Make sure the list of keys is _b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (e.b == NULL) &if (m &ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
b[0] = '0';
/* t's '<0' */ if (p == -1) &return 0;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) &b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (e.b == NULL) &if (m ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Make sure the list of keys is _&b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* limit to a number of zero length codes */ if (assumed &= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
#ifdef INCLUDE_XUL if (!(b == b->xul)) <return 0; <#endif
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* count of zero length codes */ if (!m) unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed &= N_MAX) */ unsigned s; /* number of of simple-value
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (b > 0) </* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* count of zero length codes */ if (!m) &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed &= N_MAX) */ unsigned s; /* number of of simple-value
if (n = 0) if (((*f) - m) >= 0) &*f = p; else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code '&n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) <s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
printf("huft_build&n");
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (b > 0) </* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* sum_of_lines */ /* char* i; /* if the line length length is <= 0 */ if (i == 0) <b = i; b = i; b = i; b = b;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef XP_MAC if (a == 0) &b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* long length code <'<n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* long length code <'&n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Make sure the list of keys is _b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (e.b == NULL) <if (m &ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) if (m <ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code 'n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Make sure the list of keys is _b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _&b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef XP_MAC if (a == 0) b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e.b == NULL) if (m ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* a return zero for 0&. */
u[BMAX-1] = '0';
/* * Make sure the list of keys is _b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) &b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
unsigned p; /* add of chunks in the stack */ s; /* amount of chunks */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
if (! b && m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed <= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
if (n = 0) <if (((*f) - m) >= 0) <*f = p; else *f = p;
if (b > 0) &/* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
if (b == NULL) &unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n = 0) &if (((*f) - m) >= 0) <*f = p; else *f = p;
/* * Make sure the list of keys is _b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef XP_MAC if (a == 0) &b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
if (n = 0) <if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef INCLUDE_XUL if (!(b == b->xul)) return 0; <#endif
/* check in the list of other values. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* points to current table */ struct huft *u[BMAX]; /* check in the list of values (assumed &= N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still
if (e.b == NULL) <if (m &ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) <b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (e.b == NULL) &if (m <ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* * Make sure the list of keys is _b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* long length code &'<n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e.b == NULL) <if (m &ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef XP_MAC if (a == 0) &b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef INCLUDE_XUL if (!(b == b->xul)) return 0; &#endif
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "", &unsigned u)) fstr = "", s;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* long length code &'n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* remove long a; */ if (m > 0) /* list of table values for non-simple codes */ ush *m; /* list of extra bits for non-simple codes */ if (! ush_d) ush_d = ush_d;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e &0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef XP_MAC if (a == 0) &b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* n-- has no uft values */ if (b >= 0) <unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* long length code <'<n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
printf("huft_build:&n");
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (e.b == NULL) if (m <ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Make sure the list of keys is _b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b > 0) </* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* * Make sure the list of keys is _&b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (n <= 0) &if (((*f) - m) >= 0) <*f = p; else *f = p;
/* * Make sure the list of keys is _&b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* * Make sure the list of keys is _&b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n &= 0) <if (((*f) - m) >= 0) *f = p; <else *f = p;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * No data to decode. */ b.p_declarations = 0;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n <= 0) &if (((*f) - m) >= 0) *f = p; else *f = p;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Make sure the list of keys is _&b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if ((b & 0xffffff)!= 0) &/* not used in current table */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef XP_MAC if (a == 0) <b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * Make sure the list of keys is _b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef XP_MAC if (a == 0) b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* long length code <'n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i b) i--; /* number of of codes (assumed &= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Make sure the list of keys is _&b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e.b == NULL) &if (m &ctrlen(e)) &f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '<0'; else u[BMAX+1] = '&0';
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* limit to a number of zero length codes */ if (assumed = N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (e &0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
#ifdef INCLUDE_XUL if (!(b == b->xul)) &return 0; &#endif
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l <m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* t's '&0' */ if (p == -1) <return 0;
/* a return zero for &0&. */
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n &= 0) &if (((*f) - m) >= 0) <*f = p; else *f = p;
if ((b & 0xffffff)!= 0) </* not used in current table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* long length code <'n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (! b && m) <return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed <= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* * -if n = d..s.__procsize; */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (e 0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* long length code 'n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if defined(XP_WIN) &&!defined(XP_MAC)) unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u<n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed <= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* * No data to decode. */ b.p_declarations = &0&;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _<b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* count of zero length codes */ if (!m) unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed = N_MAX) */ unsigned s; /* number of of simple-value
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (e.b == NULL) <if (m &ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if (c[I] > -1) &/* offset for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum size */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned c[I]; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count count table */ unsigned f; /* i repeats in table every f entries */ unsigned h; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* maximum length lengths/
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n = 0) <if (((*f) - m) >= 0) &*f = p; <else *f = p;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned b; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int l; /*
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* number of pending voids */ ush *d; /* number of pending voids */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter,
printf("huft_build failed&n");
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (n = 0) <if (((*f) - m) >= 0) *f = p; &else *f = p;
/* long length code 'n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * No data to decode. */ b.p_declarations = <0&;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
printf("huft_buildn");
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "<", &unsigned u)) fstr = "<", s;
/* sum_of_lines */ /* char* i; /* if the line length length is = 0 */ if (i == 0) &b = i; b = i; b = i; b = b;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* limit to a number of zero length codes */ if (assumed = N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
if (b == NULL) unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) <unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef XP_MAC if (a == 0) b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (n = 0) &if (((*f) - m) >= 0) *f = p; <else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* t's '0' */ if (p == -1) <return 0;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r <m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* t's '0' */ if (p == -1) return 0;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (u[DIRUNKNOWN] == '0') ush *e;
/* long length code 'n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* limit to a number of zero length codes */ if (assumed &= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i &b) i--; /* number of of codes (assumed &= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i &b) i--; /* number of of codes (assumed = N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] &= N_MAX) &/* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* limit to a number of zero length codes */ if (assumed = N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* check for error codes. */ if (c[0] == '<0') return (-1);
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* * Make sure the list of keys is _b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* limit to a number of zero length codes */ if (assumed = N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
if (b) /* code lengths in bits (all assumed &= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
#ifdef XP_MAC if (a == 0) <b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* limit to a number of zero length codes */ if (assumed &= N_MAX) &/* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e <0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed <= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ <b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
printf("huft_build()<n");
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (b == NULL) &unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) <unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* a return zero for 0<. */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
u[BMAX] = '0';
/* * Make sure the list of keys is _<b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (e.b == NULL) <if (m <ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* limit to a number of zero length codes */ if (assumed <= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef XP_MAC if (a == 0) &b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (e.b == NULL) <if (m <ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* * -if n <= d..s.__procsize; */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef INCLUDE_XUL if (!(b == b->xul)) <return 0; &#endif
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* long length code &'<n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e.b == NULL) <if (m ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e <0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* long length code <'&n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n <= 0) <if (((*f) - m) >= 0) *f = p; <else *f = p;
#ifdef XP_MAC if (a == 0) <b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
if (e <0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* long length code &'&n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) if (m &ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* long length code <'<n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n = 0) <if (((*f) - m) >= 0) &*f = p; else *f = p;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code '<n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef XP_MAC if (a == 0) &b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code '<n', '&n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* n-- has no uft values */ if (b >= 0) &unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) <unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* long length code <'&n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) &s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e 0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e &0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
printf("huft_build failedn");
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
if ((b & 0xffffff)!= 0) /* not used in current table */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
if (n &= 0) if (((*f) - m) >= 0) *f = p; <else *f = p;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (b) </* code lengths in bits (all assumed = BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* max is a minimum of ns of length. */ /* initialize the space of csa xmalloc(s); /* check for nsa xmalloc (s) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* limit to a number of zero length codes */ if (assumed &= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e 0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* a return zero for 0. */
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] = N_MAX) </* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
if (e.b == NULL) &if (m ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
if (n = 0) &if (((*f) - m) >= 0) *f = p; else *f = p;
/* * Make sure the list of keys is _&b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
#ifdef XP_MAC if (a == 0) &b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
if (e.b == NULL) <if (m <ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (e 0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e.b == NULL) <if (m ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* count of zero length codes */ if (!m) &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed <= N_MAX) */ unsigned s; /* number of of simple-value
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
if (e <0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
if (e.b == NULL) &if (m <ctrlen(e)) &f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (! b && m) <return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed = N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* count of zero length codes */ if (!m) &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed = N_MAX) */ unsigned s; /* number of of simple-value
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
#ifdef XP_MAC if (a == 0) b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (b) &unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) &b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _&b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Make sure the list of keys is _<b, _&n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (b == NULL) <unsigned a = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum lookup bits, returns actual */ if (b == NULL) <unsigned i = 0; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count table */ unsigned f; /* counter, current code */ unsigned j; /* counter */ register int r; /* counter */ unsigned j; /
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e <0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e 0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
printf("huft_build()n");
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (! b && m) &return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed = N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
#ifdef XP_MAC if (a == 0) &b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n &= 0) if (((*f) - m) >= 0) &*f = p; <else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* long length code <'&n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* * Make sure the list of keys is _&b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (e.b == NULL) <if (m <ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* f 0x2b */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (e.b == NULL) <if (m <ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
if (e.b == NULL) <if (m ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Make sure the list of keys is _&b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Make sure the list of keys is _&b, _<n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u&n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (n <= 0) &if (((*f) - m) >= 0) <*f = p; &else *f = p;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; <if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* count of zero length codes */ if (!m) unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ unsigned i; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned b[], or v[] */ register struct huft *q; /* pointer into c[], b[], or v[] */ register struct huft *p; /* pointer into c[], b[], or v[] */ register struct huft *q; /* number of times in bits (assumed <= N_MAX) */ unsigned s; /* number of of simple-value
/* * Make sure the list of keys is _&b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
printf("huft_build: huft_build failedn");
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) /* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _<b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* Ignore pending code names */ if (b!= NULL) &/* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* long length code '&n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) <b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) <if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef XP_MAC if (a == 0) &b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
if (b) &/* code lengths in bits (all assumed = BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
if (b) unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
#ifdef XP_MAC if (a == 0) b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed &= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set u&n */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] &= N_MAX) </* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
printf("huft_build failed<n");
#ifdef XP_MAC if (a == 0) &b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (n &= 0) &if (((*f) - m) >= 0) &*f = p; <else *f = p;
if (e.b == NULL) if (m &ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (e <0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
if (n &= 0) <if (((*f) - m) >= 0) *f = p; &else *f = p;
#ifdef XP_MAC if (a == 0) b = 0; else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
printf("huft_build<n");
if (n &= 0) <if (((*f) - m) >= 0) &*f = p; <else *f = p;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) &/* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- has no uft values */ if (b >= 0) unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* make sure we have all the cds to recompile them. */ if (!is_saved) &ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed <= N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* long length code '&n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
#ifdef XP_MAC if (a == 0) &b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '<0') && b[BMAX]!= '0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* long length code <'<n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* check for error codes. */ if (c[0] == '&0') return (-1);
if (e.b == NULL) if (m <ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* t's '<0' */ if (p == -1) return 0;
/* long length code &'<n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (e.b == NULL) <if (m &ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) &/* set un */ /* not */ ush *e; <else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) &unsigned m = b; /* start to b [*c]n"'""> b[[]]<n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) &/* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (n &= 0) &if (((*f) - m) >= 0) <*f = p; &else *f = p;
/* make sure we have all the cds to recompile them. */ if (!is_saved) <ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '<0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if defined(XP_WIN) &&!defined(XP_MAC)) <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ &b[BMAX
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef XP_MAC if (a == 0) <b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (n = 0) &if (((*f) - m) >= 0) *f = p; &else *f = p;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef XP_MAC if (a == 0) <b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
if (n &= 0) <if (((*f) - m) >= 0) &*f = p; &else *f = p;
/* long length code &'&n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* * Make sure the list of keys is _<b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m <= 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) &/* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (n = 0) if (((*f) - m) >= 0) *f = p; else *f = p;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) &/* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef XP_MAC if (a == 0) <b = 0; <else /* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
/* make sure we have all the cds to recompile them. */ if (!is_saved) &ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
#ifdef XP_MAC if (a == 0) <b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (! b && m) &return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (b >= m) return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ struct huft *q; /* number of of times in bits (assumed &= N_MAX) */ ush *s; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given
if (e.b == NULL) &if (m <ctrlen(e)) <f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* long length code &'&n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
#ifdef XP_MAC if (a == 0) <b = 0; else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* * Make sure the list of keys is _b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ b[BMAX
/* if (c[I] > -1) /* offset for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum size */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned c[I]; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* count count table */ unsigned f; /* i repeats in table every f entries */ unsigned h; /* counter for codes of length k */ unsigned c[I]; /* bit length count table */ unsigned f; /* maximum length lengths/
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l &m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* a return zero for <0. */
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if it's just the 'huft' code. */ if (b == NULL) &/* the huft table is null */ if (huft_set_code(b, n, s, e, t, m) == -1) huft_write_code(b, n, s, e, t, m); huft_write_code(b, n, s, s, e, t, m);
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef XP_MAC if (a == 0) <b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* limit to a number of zero length codes */ if (assumed &= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e.b == NULL) <if (m ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (n <= 0) if (((*f) - m) >= 0) <*f = p; &else *f = p;
#ifdef XP_MAC if (a == 0) b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
if (b) /* code lengths in bits (all assumed <= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* sum_of_lines */ /* char* i; /* if the line length length is = 0 */ if (i == 0) b = i; b = i; b = i; b = b;
/* limit to a number of zero length codes */ if (assumed &= N_MAX) /* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
if (e.b == NULL) <if (m &ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) &s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
if (e &0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; &if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* int the number of n_simple_codes in bits (assumed &= N_MAX) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Make sure the list of keys is _&b, _n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set u&n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (n <= 0) if (((*f) - m) >= 0) &*f = p; else *f = p;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ <b[BMAX
if (n <= 0) &if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
printf("huft_build: %s&n", b);
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
/* t's '&0' */ if (p == -1) &return 0;
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
b[0] = '&0';
/* make sure we have all the cds to recompile them. */ if (!is_saved) &ush *e; /* list of extra bits for non-simple codes */ if (!is_assumed) ush *e; ush *d; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /
if (n <= 0) if (((*f) - m) >= 0) *f = p; &else *f = p;
/* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned j; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ int l; /* bits per table (returned in m) */ register unsigned p;
/* n-- has no uft values */ if (b >= 0) <unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) &unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) </* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (e.b == NULL) if (m <ctrlen(e)) <f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (b) <unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* if it's just the 'huft' code. */ if (b == NULL) /* the huft table is null */ if (huft_set_code(b, n, s, e, t, m) == -1) huft_write_code(b, n, s, e, t, m); huft_write_code(b, n, s, s, e, t, m);
/* f &0x2b */
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
#ifdef XP_MAC if (a == 0) &b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e &0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#if defined(XP_MAC) &&!defined(XP_MACOSX) /* * Some of the huft_eps will be out of bounds for a number of codes. */ struct huft *e; /* list of non-simple codes (assumed = N_MAX) */ struct huft *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ un
/* long length code 'n', 'n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l &m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* long length code <'n', 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (b > 0) /* list of base values for non-simple codes */ ush *d; /* list of extra bits for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned i
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m &= 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* * Make sure the list of keys is _b, _<n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* long length code <'n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (n &= 0) <if (((*f) - m) >= 0) <*f = p; else *f = p;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * No data to decode. */ b.p_declarations = 0&;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* long length code 'n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* long length code &'&n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* sum_of_lines */ /* char* i; /* if the line length length is &= 0 */ if (i == 0) <b = i; b = i; b = i; b = b;
u[BMAX+1] = '&0';
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
b[0] = '<0';
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* Ignore pending code names */ if (b!= NULL) </* Ignore pending code names */ if (b >= 0) <ush *d; ush *e; ush *b = NULL; &ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
if (e.b == NULL) if (m <ctrlen(e)) f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]&n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
printf("huft_build: huft_build failed<n");
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) </* set u<n */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) if (m) /* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Make sure the list of keys is _<b, _&n&. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* a return zero for <0<. */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (e.b == NULL) <if (m &ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* * No data to decode. */ b.p_declarations = 0<;
#ifdef INCLUDE_XUL if (!(b == b->xul)) <return 0; #endif
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]<n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
if (u[DIRUNKNOWN] == '&0') ush *e;
/* Ignore pending code names */ if (b!= NULL) /* Ignore pending code names */ if (b >= 0) &ush *d; ush *e; ush *b = NULL; <ush *m = NULL; ush *e = NULL; ush *e = NULL; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; ush *e; ush *t; ush *m; /* Ignore pending code names */ ush *t; ush *e; ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *e; /* Ignore pending code names */ ush *m; /*
/* * Make sure the list of keys is _<b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) &ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) </* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (e <0) ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (unsigned a[N_MAX] <= N_MAX) &/* start off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s; /* end off in a single table */ unsigned e[N_MAX] = NULL; /* end off in a single table */ unsigned s = ush *d; /* pointer into a single table */ unsigned n; /* length lengths in the previous table size, and three if not enough memory. */ h[N_MAX] = h[N_MAX]; /* lengths in the previous table size, and three if not enough memory. */ h[N
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) &/* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (e <0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r <m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
#ifdef XP_MAC if (a == 0) <b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
if (v) &v->i = v;
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ <b[BMAX
if (b) unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) </* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) </* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '<0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* * Check that we don't set any decode values. */ if (i == 0) if (n == 0) </* set un */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned b; /* counter, current code */ unsigned j; /* counter */ register int h; /* counter, current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int k; /* number of bits in current code */ unsigned j; /* counter */ register int l; /*
/* * Make sure the list of keys is _&b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req &= 0; /* number of integers req <= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
#ifdef XP_MAC if (a == 0) <b = 0; <else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
#ifdef XP_MAC if (a == 0) b = 0; <else &/* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; <if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) <unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* * Make sure the list of keys is _b, _n. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
if (m) </* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* * -if n &= d..s.__procsize; */
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed <= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* a return zero for <0&. */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len &v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l &m && r <m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* * Make sure the list of keys is _<b, _n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) /* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l m && r m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a m && l <m && r m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &/* limit for all zero length codes */ b[BMAX
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req = 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* * Make sure the list of keys is _<b, _<n&. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
#ifdef XP_MAC if (a == 0) <b = 0; else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
if (e.b == NULL) &if (m <ctrlen(e)) f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) /* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* long length code &'n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]n"'"> e<n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* long length code &'&n', '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ /* limit for all zero length codes */ &b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l <m && r &m) </* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m &= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) /* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
/* * Make sure the list of keys is _b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* long length code &'<n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] = s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] <= s)) &if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed = N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* long length code '&n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '<0'; else u[BMAX+1] = '<0';
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "&", &unsigned u)) fstr = "&", s;
if (b) &unsigned b = huft_build(b, n, s, e, t, m); /* huft_build() must be NULL */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length
/* if it is a huft_c or a huft_c m or m */ if (fstrncmp(fstr, "&", &unsigned u)) fstr = "<", s;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req &= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* double size, returns actual */ /* if the first lookup bits are present, we set the table size, as a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (i &b) i--; /* number of of codes (assumed <= N_MAX) */ ush *d; /* number of simple-valued codes (0..s-1) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one
#ifdef XP_MAC if (a == 0) b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) b = 0; else b = 0; #endif
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (e.b == NULL) <if (m ctrlen(e)) f = e; <if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) <d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r &m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (b) </* code lengths in bits (all assumed &= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* long length code '&n', '<n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req &= 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* set size of table to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ ush *d; /* number of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k *
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] <= s)) && (b[0] = s)) <if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req &= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* t's '&0' */ if (p == -1) return 0;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; <if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
if (m) /* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) /* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) &/* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) /* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* n-- has no uft values */ if (b >= 0) unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) &unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
if (e 0) &ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '0'; else u[BMAX+1] = '0';
/* n-- has no uft values */ if (b >= 0) <unsigned a = m; /* maximum lookup bits, returns actual */ if (m >= 0) <unsigned c[BMAX] = 0; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code length */ unsigned f; /* max length count table */ unsigned f; /* maximum number of bits in current code */ unsigned j; /* counter */ register int f; /* minimum table size */ unsigned f; /* maximum length count table */ unsigned f; /* minimum length count table */ unsigned f; /* maximum length length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length count table */ unsigned f; /* maximum length
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] <= s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) </* no single single entry. */ if (m = 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
if (e.b == NULL) <if (m &ctrlen(e)) &f = e; if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) <if((b[1] >= s) || (b[2] &= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* * Make sure the list of keys is _&b, _&n<. This function should always be __id__ for the base value. */ if (t!= NULL) <ush *d; ush *e; ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (t == 0) ush *r; /* maximum lookup bits, returns actual */ ush *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* ** Delete any remaining pages. */
/* if defined(XP_WIN) &&!defined(XP_MAC)) &unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* maximum code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f
/* if not allowed, just ignore the name of a table in the table. */ if (b) <if ((u[BMAX]!= '0') && b[BMAX]!= '&0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req <= 0; /* number of integers req = 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) <unsigned m = b; /* start to b [*c]<n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* frees it, but try to free it in the future */ if (flags & DB_FIFO_NOT_FOCUS) <s = 0; return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &b = unsigned q; /* frees it */ d = unsigned d; /* frees it */ e; /* frees it */
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) &b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* * Check that we don't set any decode values. */ if (i == 0) <if (n == 0) /* set un */ /* not */ ush *e; &else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req <= 0; /* number of (int)codes req &= 0; /* number of integers req = 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
if (e &0) <ush *e; /* list of unused values (0..s-1) */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ int g; /* maximum code length */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /
/* long length code '<n', '<n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]&n"'""> b[[]]&n"'"> e&n"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) /* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a &m && l m && r m) /* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
/* for the long code length. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (a <m && l m && r &m) &/* set of %s of length */ unsigned a; /* set of size of code lengths */ ush *e; /* set of extra bits for non-simple codes */ ush *t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ if (m m) ush *e; /* set of extra bits for non-simple codes */ ush *e; /* set of extra bits for non-simple codes */ ush *m; /* maximum lookup bits, returns actual */ if (m >= m)
if (n = 0) &if (((*f) - m) >= 0) <*f = p; <else *f = p;
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req &= 0; /* number of special-valued codes req = 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ <if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; &/* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) <if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; &if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and &fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed<on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* n-- is the integer that isn't free. */ b[SIZE] = 0; /* number of (int)codes req = 0; /* number of (int)codes req = 0; /* number of integers req <= 0; /* number of special-valued codes req <= 0 */ ush *d; /* number of simple-valued codes req = 0 */ ush *e; /* list of extra bits for non-simple codes req = 0 */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if
#ifdef XP_MAC if (a == 0) b = 0; &else </* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* long length code &'n', 'n' '<n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) <b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) &d[0] = NULL; d[1] = NULL; d[2] = NULL; </* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
if (n <= 0) <if (((*f) - m) >= 0) &*f = p; else *f = p;
if (n <= 0) if (((*f) - m) >= 0) <*f = p; else *f = p;
/* * Check that we don't set any decode values. */ if (i == 0) &if (n == 0) /* set u<n */ /* not */ ush *e; else /* no decode values. */ ush *i = 0; if (i = 0) /* no decode values. */ ush *i = 0;
#ifdef XP_MAC if (a == 0) &b = 0; &else /* XP_MAC -> t::acc_b */ if (a == 0) <b = 0; else b = 0; #endif
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] &= s)) && (b[0] = s)) if((b[1] >= s) || (b[2] = s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
#ifdef XP_MAC if (a == 0) <b = 0; &else &/* XP_MAC -> t::acc_b */ if (a == 0) &b = 0; else b = 0; #endif
if (m) &/* * The code lengths can only be set on the huft table. This will just return zero on success, the code lengths are not guaranteed to be unsigned. */ if (m) </* * The huft table table is decoded as needed. */ m = a[m]; m = a[m]; &if (m == NULL) </* * If we have to do a huft table, we need to do the huft table * and we need to do this. */ if (m == NULL) if (m == NULL) m = a[m]; m = a[m]; m = a[m]; else if (m == NULL) m = a[m]; if (m == NULL) m = a[m]; if (m == NU
/* long length code &'&n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
/* long length code <'&n', '&n' '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (b) </* code lengths in bits (all assumed <= BMAX) */ unsigned n; /* number of simple-valued codes (0..s-1) */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned i; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table
#ifdef __XP_MAC /* XXX :/ */ if (unsigned a &&!unsigned i) &if (m) &/* XXX */ m = m->m_uname; m = m->m_uname; if (m->m_uname) m = m->m_uname; m->m_uname = m->m_uname; m->m_uname = m->m_uname; if (m->m_uname) m->m_uname = m->m_uname; m->m_uname = m->m_uname; else m->m_uname = m->m_uname;
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed = N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed <= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and <fixedon any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '&0') && b[BMAX]!= '0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '&0') && b[BMAX]!= '&0') &/* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if we can get the first one, i for sure that we can't have the next one. */ if (u[BMAX+1]) u[BMAX+1] = '0'; else u[BMAX+1] = '<0';
/* s = 0; /* i=%s, the list isn't yet implemented. */ if((b[0] >= s) || (b[1] = s)) && (b[0] &= s)) &if((b[1] >= s) || (b[2] <= s) || (b[3] >= s) || (b[4] >= s) || (b[5] = s)) if((b[5] >= s) || (b[5] = s)) if((b[5] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s) || (b[6] = s)) if((b
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed <= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed <= N_MAX) */ ush *t; /* if number of non-simple code (assumed &= N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
if (e.b == NULL) &if (m ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* huft_required - p: to return zero on success, two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (f == '0') f = (struct huft *) s;
#ifdef INCLUDE_XUL if (!(b == b->xul)) &return 0; <#endif
/* long length code &'<n', '&n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n' 'n'
if (e.b == NULL) &if (m <ctrlen(e)) <f = e; &if (m ctrlen) f = m + i; /* minimum lookup bits, returns actual */ /* given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table */ unsigned f; /* i repeats in table every f entries */ unsigned f; /* table level */ register unsigned i; /* counter, current code */ unsigned j;
/* return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ &if (g.get_size() == 0) b[0] = NULL; /* length of code lengths */ if (g.get_size() > 0) d[0] = NULL; d[1] = NULL; d[2] = NULL; /* number of zero length codes (assumed = N_MAX) */ d[2] = NULL; /* number of simple-valued codes (0..s-1) */ ush *d; /* number of non-simple codes (assumed = N_MAX) */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t;
/* if not allowed, just ignore the name of a table in the table. */ if (b) if ((u[BMAX]!= '0') && b[BMAX]!= '&0') /* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
/* if the first part of the list is no longer supported, return zero on success. */ if (b >= 0) /* no single single entry. */ if (m <= 0) &/* * not supported, only work if it returns the non-simple code. */ if (m >= 0) </* "none" is a valid value. */ if (m >= 0) /* non-simple code. */ ush *d; /* list of base values for non-simple codes */ ush *e; /* list of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables
printf("huft_build: %d&n", b);
/* skip at a number of bits */ unsigned a = (struct huft *) u[BMAX-1]; /* skip at the first of these codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ if (u[BMAX-1] == t) unsigned m = b; /* start to b [*c]n"'""> b[[]]&n"'"> en"'"> en"'"> b[[]]n"'"> en"'"> en"'"> m[[]n"'"> en"'"> b[[]]n"'> en"'> b[[]]n"'> en"'
/* if (I'm using NULL_PRIVATE) &/* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) </* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ b[BMAX
/* if the prev == a, he'll never be a non-simple table. */ /* * The non-simple table has been modified and fixed, and fixed&on any of the prevs. */ /* the non-simple table has been added to the next table. */ if ((len <v) || (v == v)) &unsigned a = b[0]; if ((len v) || (v == v) || (v == v) || (v == v) || (v == v) || (v == v)) unsigned i = v[0]; if (v == v) unsigned j = v[1]; if (v == v) unsigned i = v[1]; if (v == v) unsigned i = v[1]; <unk>
/* if (I'm using NULL_PRIVATE) </* no first table size */ unsigned b[BMAX+1]; /* no first table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ unsigned f[BMAX+1]; /* minimum table size */ if (f[BMAX+1] == b[BMAX+1]) &/* a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ </* limit for all zero length codes */ &b[BMAX
/* check if huft_build(b, n, s, e, t, m) */ ush *d; /* if number of low codes (assumed &= N_MAX) */ ush *e; /* if number of low codes (0..s-1) */ ush *d; /* if number of low code (assumed &= N_MAX) */ ush *e; /* if number of high codes (0..s-1) */ ush *t; /* if number of low code (assumed &= N_MAX) */ ush *t; /* if number of non-simple code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N_MAX) */ ush *e; /* if number of low code (assumed = N
/* limit to a number of zero length codes */ if (assumed &= N_MAX) </* limit of a number of zero-valued codes (0..s-1) */ ush *d; /* limit of non-simple codes */ ush *e; /* limit of extra bits for non-simple codes */ struct huft **t; /* result: starting table */ int *m; /* maximum lookup bits, returns actual */ /* Given a list of code lengths and a maximum table size, make a set of tables to decode that set of codes. Return zero on success, one if the given code set is incomplete (the tables are still built in this case), two if the input is invalid (all zero length codes or an oversubscribed set of lengths), and three if not enough memory. */ unsigned a; /* counter for codes of length k */ unsigned c[BMAX+1]; /* bit length count table *
u[BMAX] = '&0';
/* if not allowed, just ignore the name of a table in the table. */ if (b) &if ((u[BMAX]!= '0') && b[BMAX]!= '<0') </* * Delete table */ if (!(u[BMAX]!= '0') &&!(u[BMAX]!= '0')) /* Remove table */
