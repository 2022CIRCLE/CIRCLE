golden:
result.add((x));
inference:
result.addElement(flatten(x));
result.append(flatten(x));
result = flatten(x);
result = result.add(flatten(x));
result.add(x);
result.add(flatten(x));
result += flatten(x);
result.addAll(flatten(x));
result.add((ArrayList)flatten(x));
result.add (flatten (x));
result.Append(flatten(x));
result.add(flatten(x));
result.put(flatten(x));
result.add((void *)flatten(x));
result.addElement(x);
result = x;
result.add((ArrayList) flatten(x));
result = (ArrayList)flatten(x);
result.add((void **)flatten(x));
result.append(flatten(x));
result=flatten(x);
result.add (flatten(x));
result.add(y);
result.addEmpty(flatten(x));
result.add((int)flatten(x));
result.push(flatten(x));
result = (ArrayList) flatten(x);
result = add(flatten(x));
result.add(flatten((int)x));
result.add(int(x));
result.add((Object)flatten(x));
result.update(flatten(x));
result.addElementAt(x);
result = result.add(flatten(x));
result.add(flatten(arr));
result.addes(flatten(x));
result.addRef(flatten(x));
result.addInt(flatten(x));
result.add(flatten((void *)x));
result = result.add(x);
result.remove(x);
x = result.add(flatten(x));
result.add(&flatten(x));
result.add((String)flatten(x));
result.advance(flatten(x));
result = new ArrayList(50);
result.add(result);
result.add(l);
result.add(mat);
result.add(strlen(x));
result.addr(flatten(x));
result.set(flatten(x));
result = (Object)flatten(x);
result.add(x, 0);
result = result.addAll(flatten(x));
result.add(x.get());
res = result.add(flatten(x));
result.add(flatten(narr));
result.add(flatten(x) + 1);
result = result.append(flatten(x));
result.add(narr);

result.add(buf);
rv = result.add(flatten(x));
result.add(m);
result.add((void**)flatten(x));
result.add(flatten(x, 0));
result.add((void*)flatten(x));
result.add(flatten(i));
result.add(flatten(x) - 1);
result.add((List)flatten(x));
result.add(flatten(a));
result.add(base);
result.remove(flatten(x));
result.add((Int)flatten(x));
result.addSize(flatten(x));
x = flatten(x); result.add(x);
result.AppendElement(flatten(x));
result_add(flatten(x));
(void) result.add(flatten(x));
result |= flatten(x);
result = result;
(void)flatten(x);
result.add(flatten(x), 0);
result.addRef(x);
result.add(sizeof(x));
res.add(flatten(x));
else result.add(flatten(x));
result.add(c);
result.add(flatten((void **)x));
result += x;
result.add(flatten(*x));
result.addRaw(x);
result.addMore(flatten(x));
result.insert(0, x);
result++;
result.add(i);
result[x] = flatten(x);
result = result + flatten(x);
result.add(flatten(p));
result.addPtr(flatten(x));
result.add(flatten(r));
result.add(sizeof(flatten));
result.add((Point)flatten(x));
result.add(arr);
r = result.add(flatten(x));
result.addObject(flatten(x));
result.add(flatten(y));
result.add(width);
result.add(x + 1);
result.add(p);
result =flatten(x);
result.add(sizeof(flatten(x)));
result.addArray(flatten(x));
result.add((void)flatten(x));
result.add(float(x));
result.add(b);
result.addElement(flatten(x), 0);
result.addMatch(flatten(x));
result.add(align(x));
result.add((narg)flatten(x));
result+=flatten(x);
result = (void *)flatten(x);
result.add(flatten(x)); return result;
result.add(flatten(object));
result.addReference(flatten(x));
result.add(aFlatten(x));
result.add(ulong(x));
result.add(flatten((Object)x));
result.add(x - 1);
result.add(x);
result.add((ObjectList)flatten(x));
result.removeAll(flatten(x));
result.add(n);
result.add(object);
result &= flatten(x);
result.add(flatten(x)+1);
result.add(a);
result.add(flatten(int));
result.add(x, sizeof(x));
result.add(new_flatten(x));
result.addProperty(flatten(x));
result.add(abs(x));
result.add(flatten(result));
result.add(alpha);
result[x] = '0';
result.put(x);
result.append(x);
result = new ArrayList(100);
result.addAll(x);
result.add(flatten (x));
result.addElement(flatten(0));
result = Flatten(x);
result.add(flatten(m));
result.add(i));
result.add(align);
result.add(flatten(&x));
result.add(flatten((void*)x));
result = flatten(x); result = result;
result.ptr = flatten(x);
result.addElementAt(x));
*result = flatten(x);
result.addMask(flatten(x));
result.add(mat));
result.add(flatten(x)); break;
result.add(flatten((Int)x));
result.add(flatten());
result.add(flatten(x).get());
result.add(flatten((narg)x));
result.addElementAt(x, 0);
result.removeElement(x);
result.add(flatten(x)));
result.add(narg);
result.add(tmp);
result.add(origin);
result.add(flatten(x)-1);
res = flatten(x);
result.add(flatten((String)x));
result.add(flatten((void**)x));
result.addElement(flatten(x).get());
return result;
x = x; result.add(x);
result.add(flatten(x), narr);
result.add(math.max(x));
result.add(flatten((ArrayList)x));
result = flatten(x); else result = result;
result.add(flatten((narr)));
result = x + (x - result); result = result + result;
result.add(sizeof(void));
result.add((BIG)flatten(x));
result.add(mFlat);
result.add((struct nsRefPtrnnn)x);
result.add(flatten((PRUint32)x));
result.add(flatten((u_int)x));
result.add(math.max(0, x));
result.add((x));
result.add(math.max(x, 0));
result.add(flatten(x), false);
result.add((FlatString)flatten(x));
result.add((AttrList)flatten(x));
result.add((XXX *)flatten(x));
result.add(flatten(x, sizeof(x)));
result.add((u_int8_t *)flatten(x));
result.add(flatten((u_int32_t)x));
result.add(((Integer)flatten(x)));
result.add(X_MAX(x));
result.add(flatten((Object *)x));
result.add(aFlat));
result.add(aList);
result.add(flatten((u_long)x));
result.add((nsIFrame*)flatten(x));
result.add((AReadable)flatten(x));
result = x + flatten(x);
result.add(aReferrer);
result.add(flatten(x, (narg)0));
result &= flatten(x);
result &= <flatten(x);
result[x] = '&0';
result.add((struct nsRefPtr<nn&n)x);
result.add((struct nsRefPtr&n&nn)x);
result.add((struct nsRefPtrn&n&n)x);
&result.add(flatten(x));
result.add((struct nsRefPtrn<n&n)x);
result.add((struct nsRefPtr&n<nn)x);
result.add((struct nsRefPtr&nn&n)x);
result.add((struct nsRefPtr&nn<n)x);
result.append(flatten(x));
result.add((struct nsRefPtrnn<n)x);
result.add(flatten(x));
result.add((struct nsRefPtr<n<n&n)x);
result.add((struct nsRefPtr&nnn)x);
result &= &flatten(x);
result.add((struct nsRefPtr&n&n&n)x);
result.add((struct nsRefPtr<n&nn)x);
result.add((struct nsRefPtr<n&n&n)x);
result.add((struct nsRefPtr&n<n<n)x);
result.add((struct nsRefPtrn&n<n)x);
result.addElement(flatten(x));
result[x] = '<0';
result.add((struct nsRefPtrnn&n)x);
result.add((struct nsRefPtr&n<n&n)x);
result.add((struct nsRefPtr<nn<n)x);
result.add((struct nsRefPtr<n&n<n)x);
result[x] = '0';
result.add(x);
result.add((struct nsRefPtrnnn)x);
<result.add(flatten(x));
result.add((struct nsRefPtrn<nn)x);
result.add((struct nsRefPtr<n<n<n)x);
result.add((struct nsRefPtr<n<nn)x);
result.add((struct nsRefPtrn&nn)x);
result.add((struct nsRefPtr&n&n<n)x);
result.add((struct nsRefPtr<nnn)x);
result.add((struct nsRefPtrn<n<n)x);
