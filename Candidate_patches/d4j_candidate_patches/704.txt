golden:
traverse(c);
inference:
traverse(node);
traverse(&c);

traverse(c, 0);
traverse(c, c);
traverse(node, c);
traverse(c, 1);
c = traverse(c);
traverse();
traverse(c, null);
traverse(c, node);
traverse((void *)c);
traverse(c, cl);
traverse((node)c);
traverse(c, -1);
traverse(c);
traverse(c, true);
traverse(*c);
traverse (c);
traverseNode(c);
traverse((void **)c);
traverse(c, cp);
traverse((unsigned long)c);
traverse((int)c);
traverse(c.get());
traverse(s);
traverse(c, next);
traverse(c, c0);
traverse(c, &c);
traverse(c, this);
traverse(c, cls);
if (c) traverse(c);
traverse(c, c++);
traverse(c + 1);
traverse(c, true);
traverse(p);
traverse((void**)c);
traverse(aC);
traverse(c, false);
traverse("");
traverse(sc);
traverse( c );
traverseElement(c);
traverse(m);
traverse(child);
traverse(c, cb);
traverse((char *)c);
(void) traverse(c);
traverse((void*)c);
#endif
traverse(n);
traverse(c, firstChild);
return traverse(c);
traverse(C);
traverse(c, parent);
traverse(c, 2);
traverse(c, p);
traverse(c, null);
traverse(b);
traverse(c, true);
traverse(firstChild);
traverse(ret);
traverse(c, n);
traverse((Node)c);
traverse("%s", c);
traverse(Node(c));
traverse(null);
traverse('0');
traverse(dev);
traverse(c1, c2);
traverse(this);
traverse_child(c);
traverse((Node*)c);
ret = traverse(c);
traverse(c,node);
traverse(node.c);
traverse(a);
traverse(this, c);
traverse(nc);
traverse(c, start);
traverse(u);
traverse(c, "");
traverse(c, child);
traverse(c, end);
traverse(c == null);
parse(c);
traverse(&node);
traverse("", c);
traverse(c, s);
traverse(c.getNext());
traverse(c, first);
traverse(id);
traverse(0);
traverse(c, l);
traverse((*c));
traverse(c, c.parent);
/* traverse(c); */
traverse(name);
traverse(c, 4);
traverse(buf);
traverse(v);
free(c);
traverse(c, path);
traverse(c, c--);
traverse(c - 1);
traverse((c));
traverse(ep);
traverse(c, c;
traverse((u_long)c);
traverse(c, flags);
traverse(c, false);
traverse(i);
traverse(c, prev);
traverse(c, 0, null);
traverse(c, c.children);
traverse(next);
traverse(c, cc);
traverse(c, len);
traverse(new);
traverse(c, scope);
traverse((Node *)c);
traverse_next(c);
traverse(c++);
traverse(c, i);
traverse(lc);
traverse(cur);
traverse(l);
traverse(i, c);
traverse(c, *c);
traverse(!c);
traverse(c.next);
traverse(c, cnt);
traverse(c, count);
traverse(self, c);
traverse(first);
traverse(c, ctx);
traverse(-c);
traverse(in);
traverse(null);
traverse(c, skip);
traverse((long)c);
traverse(f);
traverse(c, 0, 0);
traverse(c, last);
traverse(c, ret);
traverse(it);
rv = traverse(c);
traverse(result);
traverse(c, a);
traverse(c, c + 1);
traverseChild(c);
traverse((void)c);
traverse(obj);
traverse(c!= null);
traverse(c,0);
traverse(c); #endif
traverse(c, m);
traverse(c+1);
traverse(r);
traverse((char*)c);
traverse(buf, c);
traverse(n, c);
traverse(newNode);
traverse(c, v);
traverse(node.next);
traverse(conn);
traverse(e);
traverse(c, ep);
else traverse(c);
traverse(c, cx);
traverse(c, entry);
traverse(c, c2);
p = traverse(c);
traverse(C, c);
traverse(c, t);
traverse(c, dev);
traverse(c, prefix);
traverse((void *) c);
i = traverse(c);
traverse(c, bounds);
traverse(1);
traverse(c, preconditions);
traverse(c, cs);
traverse(c, e);
traverse(c, start, end);
traverse(c, tmp);
transit(c);
traverse(c, h);
traverse(c, cr);
traverse(c, cline);
traverse(c, recurse);
traverse(c, &next);
traverse(c, aNode);
traverse(c, c.c);
traverse(c, c.next);
traverse(c, &conn);
traverse(c, c.c_file);
traverse(c, c.relativeContext);
traverse(c, "%s", c.mChild);
traverse(c, &p);
traverse(c, ni);
traverse(c, *notEntries);
traverse(c, &c.cstack);
traverse(c, &aNode.next);
traverse(c, c.getNext());
traverse(c, c.flags);
traverse(c, cp.cp_name);
traverse(c, c == null);
traverse(c, sizeof(c));
traverse(c, getter_AddRefs(c));
traverse(c, c.child);
traverse(c, c.mNext);
traverse((uintptr_t)c);
traverse(c, &ePossible);
traverse(c, node.getFirstChild());
traverse(c, c.cs);
traverse(c, c.dv_flags);
traverse(c, false);
traverse(c, c.cnt);
traverse((unsigned char)c);
traverse(c, c.dma_c);
traverse(c, c.previous);
traverse(c, null);
traverse(c, &c.cflags);
traverse(c, c, 1);
traverse(c, c == '0'? '0' : '0');
traverse((unsigned char *)c);
traverse(c, ntobj);
traverse(c, c.firstChild);
traverse(c, &c.mIsContained? 0 : 0);
traverse(c, &c == c;
traverse(c, 0, sizeof(c), c);
traverse(c, "", nc);
traverse(c, &c.h);
traverse(c, c.prev);
traverse(c, &c.recurse_fun);
traverse(c, c.p, c.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.p.
traverse(c, nil);
traverse(c, c.asyncDesc);
traverse(c, getTarget(node));
traverse(c, clr);
traverse(c, &c.node.getNext());
traverse(c, c.id);
traverse('0');
traverse(c, c == '&0'? '&0' : '&0');
traverse(c, c == '0'? '<0' : '0');
traverse(c, c == '&0'? '&0' : '<0');
traverse(c, c == '0'? '&0' : '&0');
traverse(c, c == '<0'? '&0' : '0');
traverse(&c);
traverse(c, c == '&0'? '&0' : '0');
traverse(c, c == '0'? '<0' : '&0');
traverse(node);
<traverse(c);
traverse(c, c == '0'? '&0' : '<0');
traverse(c, c == '0'? '0' : '&0');
traverse(c, c == '<0'? '0' : '&0');
traverse(c, c == '&0'? '<0' : '<0');
traverse(c, c == '<0'? '&0' : '<0');
traverse('<0');
traverse(c, c == '0'? '<0' : '<0');
traverse('&0');
traverse(c, c == '<0'? '<0' : '&0');
&traverse(c);
traverse(c, c == '<0'? '&0' : '&0');
traverse(c, c == '&0'? '<0' : '&0');
traverse(c, c == '&0'? '<0' : '0');
traverse(c, c == '<0'? '0' : '0');
traverse(c, c == '&0'? '0' : '0');
traverse(c, c == '<0'? '0' : '<0');
traverse(c, c == '0'? '&0' : '0');
traverse(c, c == '<0'? '<0' : '0');
traverse(c);
traverse(c, c == '0'? '0' : '<0');
traverse(c, c == '0'? '0' : '0');
traverse(c, c == '<0'? '<0' : '<0');
traverse(c, c == '&0'? '0' : '<0');
traverse(c, c == '&0'? '0' : '&0');
