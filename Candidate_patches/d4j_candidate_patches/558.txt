switch (n.type){
switch (n.getType()){
switch (n){
switch (n.type){
switch (n.getType()){
switch (n.type()){
switch(n.getType()){
switch ((n.getType())){
switch (n.type()){
switch (type){
if (n.getType()){
switch (n.Type()){
switch (n.getType().get()){
switch (n.GetType()){
switch (n.Type()){
switch (n.getType(n)){
switch (n && n.getType()){
switch (n.GetType()){
switch ((n.type)){
switch (c.getType()){
switch (Type){
switch ((n.getType())){
switch ( n.getType() ){
switch (aType){
switch (c.type){
switch (n.isType()){
switch (n!= null){
switch(n){
switch (c.type){
switch (n.isType()){
switch (ControlFlowGraph.getType(n)){
switch ((n.type())){
switch(n.type){
switch (m.type){
switch (n.Type){
switch (n.get()){
switch (n.mType){
switch (n.getNodeType()){
switch(n.type()){
switch (m.getType()){
switch (!n.getType()){
switch ((n.type())){
switch (strlen(n)){
switch (n == null){
switch (n.mType){
switch (n!= n){
switch (NodeType(n)){
switch (n.getType(ControlFlowGraph)){
switch (n.eType){
switch (&n.getType()){
switch ((n = n.getType())){
switch (ControlFlowGraph.getType()){
switch (n == n){
switch (n.nType()){
switch (mType){
switch ((n).type){
if (n.type()){
switch (n.eType){
switch (c.type()){
switch (m.type){
switch ((int)n.getType()){
switch (getType()){
switch (n.getType().type){
if (n){
switch (n!= n.getType()){
type = n.getType(); switch (type){
switch (r.getType()){
switch (n.getType ()){
switch ( (n.getType()) ){
switch (n.getName()){
switch (n == n.getType()){
switch (nType){
switch (getType(n)){
switch (n.getChildType()){
switch (controlFlowGraph.getType()){
switch (n.getCategory()){
switch (n && n.getType()){
switch (n_type){
switch (n.Type){
switch (None){
switch ((n.type)){
switch (ControlFlowGraph.type()){
switch (t.type){
switch (n.nType){
switch (eType){
switch (n.getType(aType)){
switch (n ){
switch (n.eType()){
switch (n.type && n.type){
switch (n.getPropertyType()){
switch (n.getType()!= null){
switch (n.getType())   else{
switch (n && n.type){
switch (n).getType(){
switch (ControlFlowGraph.type(n)){
switch (gType){
switch (n.getType());{
switch (ControlFlowGraph.type){
switch (v){
switch (c){
switch ((type)n.getType()){
switch (n.type.get()){
switch (getter_AddRefs(n)){
switch (N.getType()){
switch (n && n.type()){
switch (this.type){
switch (controlFlowGraph.type){
switch (ntype){
switch (n.getType( ) ){
switch (c && n.getType()){
switch (n && n.type()){
switch (n.getType()!= 0){
switch((n.getType())){
switch ((Node)n.getType()){
switch (kType){
switch (n.getType()!= n){
switch (tType){
switch (NodeType){
switch (GetType(n)){
switch (n.getType() > 0){
switch (n.type.get()){
switch (n.getType() + 1){
if (n) switch (n.getType()){
switch (GetType()){
switch (ControlFlowGraph.Type(n)){
switch (t.getType()){
if (n.type){
switch (l.getType()){
switch (n.getTYPE()){
switch (*n){
if (n)  switch (n.type){
switch (type(n)){
switch (Type(n)){
switch (n.hasType()){
switch ((Type)n.getType()){
switch (n.type && n.type){
switch (n.getType(c)){
switch (n.getType() && type){
switch (m.type()){
switch (rv){
switch ((n.GetType())){
switch (n.isEmpty()){
switch ((n.Type())){
switch (n.getTargetType()){
switch n.getType(){
switch (ControlFlowGraph.isType(n)){
switch (n.getType()) > 0{
if (n.isType()){
switch (t.type()){
switch (d.getType()){
switch (controlFlowGraph.type()){
switch (b.getType()){
switch (CType){
switch (m.type()){
switch (isType(n)){
switch (n.getType())  break;{
switch (oType){
switch (p.type){
switch (n.getInstance()){
switch (n.getType()):{
switch (n.getType(*n)){
switch (n.getType()) == 0{
switch (n.getClass()){
switch (strdup(n)){
if (n.getType()){
if(n.getType()){
switch (r.type){
switch (d.type){
switch (itemType){
switch ((n.GetType())){
switch (n, type){
switch ((n.type).type){
switch (n.getType() == n){
switch (pType){
switch (n.aType){
switch (n.getType()) ;{
switch ((type = n.getType())){
switch (n.getType(&n)){
switch (self.type){
switch (n.pType){
if (n)  switch (n){
switch (n.nodeType){
switch (ControlFlowGraph.GetType()){
switch (n.getType().type()){
switch (n.getType(Node)){
switch (n.getType(controlFlowGraph)){
switch (/*n.getType()){
switch ( (n.getType())){
switch (n.getType())){
switch (n.type!= n.type){
switch (n.getType())  return true;{
switch (n);{
switch (n.getType()),{
switch (n.getType())!= 0{
switch (n.getType())  /* XXX */ if (n.getParent() == n.getParent())  if (n.getParent() == n.getParent()) return true;  else if (n.getParent() == n.getParent())  /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent())  if (n.getType() == n.getParent())  /* Now the first parent node is a Node and not the last node is in the result. */ return true;  else if (n.getType() == n.getType())  return true;   else  return false;  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()){
switch (n.getType())  if (ControlFlowGraph.isLoaded())  return true;{
switch (n.getType())  if (ControlFlowGraph.isOpening())  /* XXX */ switch (n.getType()){
switch (n.getType())  /* * For the * next function, we need to know whether the * next call has been inserted. */ switch (n.getType()){
switch (n.getType())  /* We must do this before the object can * be passed in a field */{
switch (n.getType())  /* * If it is an object re-address of a non-native object. */{
switch (n.getType())  n.getType() = n.getProperty(n.GetType());{
switch (n.getType())   else if (c)  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType())  case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.ENC: case Token.DEC: case Token.FUNCTION: return true;{
switch (n.getType())  n.stackAvailable = false;{
switch (n.getType())  case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false;  for (Node c = n.getFirstChild(); c!= null; c = c.getNext())  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;   return false;{
switch (n.getType())  if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow))  return true;   else{
switch (((NodeType)n).getType()){
switch (n.getType())  n.type = n.getType();{
switch (n.getType())  if (ControlFlowGraph.isDestroying) return true;{
switch (n.getType())  case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false;  for (Node c = n.getFirstChild(); c!= null; c = c.getNext())  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;{
switch (n.getType())  n = n.getChildCount();{
switch (n.getType())  if (n.getFlags() & 0xfff)  return true;{
switch (n.getType())  /* XXX */{
switch (n.getType())  case Token.DEC: case Token.ENC: case Token.DO_BEL: case Token.DO_C: case Token.DO_C: case Token.DO_R: case Token.DO_BEL: case Token.DO_NON: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_C: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_DEL: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_RX: case Token.DO_FX: case Token.DO_RX: case Token.DO_PX: case Token.DO_CX: case Token.DO_CX: case Token.DO_FX: case Token.DO_CX: case{
switch (n.getType())  if (mOwner)  if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType())  /* Node not present in the switcher and */ n = (Node)n;{
switch (n.getType())  /* * XXX */{
switch (n.getType())  case Token.PXX:{
switch (n.getType())  n.put("TYPE");{
switch (n.getType())  if (n.getType()!= n.GetType()) return true;{
switch (n.getType())  if (!ControlFlowGraph.isEmpty()) return true;{
switch (n.getType())  /* * Get the * Type type. */{
switch (n.getType())  if (isSelect) return true;{
switch (n.getType())  if ((n == n.getProperty()) || (n == n.getOwner())) return true;{
switch (n.getType())  if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;{
switch (n.getType())  n.getType() = n;{
switch (n.getType())  n.mType = n.getType();{
switch (n.getType())  if (!ControlFlowGraph.isEnteringNewCfgNode(c))  return true;   else{
switch (n.getType())  case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false;  for (Node c = n.getFirstChild(); c!= null; c = c.getNext())  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;   return false;  for (Node c = n.getFirstChild(); c!= null; c = c.getNext())  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;   if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType())  if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;   if (ControlFlowGraph.isEmpty())  return true;  switch (n.getType()){
switch (n.getType())  if (c!= null)  if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c))  return true;  return false;{
switch (n.getType())  if (controlflowGraph.isInvalid(c)){
switch (n.getType())  /* We've got the type of the callback, so get * this here. */ switch (n.getType()){
switch (n.getType())  if (n.isPosition() && n.getType()!= n.getPosition())  return true;{
switch (n.getType())  /* XXX a new one */{
switch (n.getType())  /* n is not defined in n.__PLAGIN */{
switch (n.getType())  if (mControlFlow){
switch (n.getType()) &&else{
switch (n && n.type){
switch (n.getType()) <n.getType() = n;{
switch (m.type){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; else{
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
if (n) <switch (n.type){
switch (n.getType()) &&else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (c.type()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <<else{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()!= 0){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (n.isPosition() && n.getType()!= n.getPosition()) &return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &else{
switch (n.getType()) /* Node not present in the switcher and */ n = (Node)n;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (t.getType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <else{
switch (n.getType()) > 0{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <else{
switch (!n.getType()){
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <else{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <<else{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.eType){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.Type()){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &<else{
switch (tType){
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.get()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (type){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (mType){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &<else{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &<else{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (n.getFlags() & 0xfff) &return true;{
switch (n.Type){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) &<else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()!= null){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; else{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <&else{
switch (n.getType()) &else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.ENC: case Token.DEC: case Token.FUNCTION: return true;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType().type){
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch ((n.Type())){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <else{
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &<else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getPropertyType()){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <<else{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <<else{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <<else{
switch (n.getType()) &if (ControlFlowGraph.isLoaded()) return true;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &else{
if (n) &switch (n){
switch (n.getType()) </* n is not defined in n.__PLAGIN */{
switch (n.getType()) &if (ControlFlowGraph.isOpening()) /* XXX */ switch (n.getType()){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.mType){
switch n.getType(){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; else{
switch (n.getType()) &if (ControlFlowGraph.isLoaded()) &return true;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &/* * XXX */{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &else{
switch (v){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <else{
switch (n.getType()) &n.getType() = n;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) &/* n is not defined in n.__PLAGIN */{
switch (n.getType() + 1){
switch (n.getType(controlFlowGraph)){
switch (n.getType()) </* We must do this before the object can * be passed in a field */{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &else{
switch (n.getType()) <if (ControlFlowGraph.isOpening()) &/* XXX */ switch (n.getType()){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch ((n.GetType())){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.ENC: case Token.DEC: case Token.FUNCTION: return true;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch((n.getType())){
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch(n.type){
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &<else{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &if ((n == n.getProperty()) || (n == n.getOwner())) return true;{
switch (n.getType()) <else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &&else{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (mOwner) <if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) <n.put("TYPE");{
switch (n.getType()) /* * For the * next function, we need to know whether the * next call has been inserted. */ switch (n.getType()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <&else{
switch ((type = n.getType())){
switch (n.getType()) <break;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (c.type){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <<else{
switch (n.getType()) case Token.DEC: case Token.ENC: case Token.DO_BEL: case Token.DO_C: case Token.DO_C: case Token.DO_R: case Token.DO_BEL: case Token.DO_NON: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_C: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_DEL: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_RX: case Token.DO_FX: case Token.DO_RX: case Token.DO_PX: case Token.DO_CX: case Token.DO_CX: case Token.DO_FX: case Token.DO_CX: case{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &else{
switch (n.getType()) &n.put("TYPE");{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; else{
switch (n.getType()) if (!ControlFlowGraph.isEmpty()) return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) /* * XXX */{
switch (GetType()){
switch (n.getType()) n.getType() = n;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (n.isPosition() && n.getType()!= n.getPosition()) &return true;{
switch (n.getType()) &if (mOwner) if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) <&else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (mOwner) if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) &case Token.DEC: case Token.ENC: case Token.DO_BEL: case Token.DO_C: case Token.DO_C: case Token.DO_R: case Token.DO_BEL: case Token.DO_NON: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_C: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_DEL: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_RX: case Token.DO_FX: case Token.DO_RX: case Token.DO_PX: case Token.DO_CX: case Token.DO_CX: case Token.DO_FX: case Token.DO_CX: case{
switch(n.getType()){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (p.type){
switch (c && n.getType()){
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n && n.type()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <case Token.PXX:{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &else{
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
if (n.type){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.PXX:{
switch (n.getType()) if (ControlFlowGraph.isOpening()) </* XXX */ switch (n.getType()){
switch (n.getType()) <if (isSelect) return true;{
switch (n.getType()) &if (n.isPosition() && n.getType()!= n.getPosition()) return true;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &&else{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (/*n.getType()){
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <else{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (getType(n)){
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; else{
switch (n.getClass()){
switch (n.getType()) &&else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &n.type = n.getType();{
switch (n.getType()) <else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &if (n.getFlags() & 0xfff) <return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (ControlFlowGraph.isOpening()) &/* XXX */ switch (n.getType()){
switch (m.type()){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.pType){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; else{
switch (n.getChildType()){
switch (n.getType() == n){
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch ((n.getType())){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <<else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (controlFlowGraph.getType()){
switch (n.getType()) if (controlflowGraph.isInvalid(c)){
switch(n.type()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* * If it is an object re-address of a non-native object. */{
switch (n.getType()) &/* * Get the * Type type. */{
<switch (n.getType()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &<else{
switch ((Node)n.getType()){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch ((n).type){
switch (n.getType()) &return true;{
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (ControlFlowGraph.Type(n)){
switch (n.getTargetType()){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (l.getType()){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (n.getType()!= n.GetType()) return true;{
switch (n.getType()) if (n.getFlags() & 0xfff) return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) ;{
switch ((Type)n.getType()){
switch (n.getType(&n)){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()){
switch (n.getType()) /* We must do this before the object can * be passed in a field */{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch ((type)n.getType()){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &<else{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch ((n.type)){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <else{
switch (n.getType()) if (isSelect) return true;{
switch (strdup(n)){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <n.type = n.getType();{
switch (n.getType()) &/* * If it is an object re-address of a non-native object. */{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &&else{
switch (n.getType()) <if (n.getFlags() & 0xfff) return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (mOwner) if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch ( (n.getType()) ){
switch (Type){
switch (n.aType){
switch (ControlFlowGraph.GetType()){
type = n.getType(); switch (type){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &if (controlflowGraph.isInvalid(c)){
switch (n.eType()){
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) break;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()),{
switch (n.getType()) <if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <&else{
switch (d.getType()){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &else{
switch (n.getType()) /* XXX a new one */{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) /* n is not defined in n.__PLAGIN */{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) </* * Get the * Type type. */{
switch (n.getType() && type){
switch (ControlFlowGraph.type){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &else{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <&else{
switch (n.getType()) <<else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType ()){
switch (ControlFlowGraph.type()){
switch ((n.getType())){
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getNodeType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; else{
switch (n.getType()) &if (n.getType()!= n.GetType()) return true;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; else{
switch (n.type()){
switch (n!= n){
switch (n.getType()) &if (mOwner) &if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) &/* * For the * next function, we need to know whether the * next call has been inserted. */ switch (n.getType()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <&else{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <n.getType() = n.getProperty(n.GetType());{
switch (n.getType()) &/* XXX */{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <else{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <<else{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <<else{
switch (n_type){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (n.getFlags() & 0xfff) <return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &n.stackAvailable = false;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (type(n)){
switch (r.getType()){
switch (n && n.getType()){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getName()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n && n.getType()){
switch (N.getType()){
switch (n.GetType()){
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (d.type){
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &&else{
switch (n.isType()){
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n && n.type()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <&else{
switch (n == null){
if (n) switch (n){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &else{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType(c)){
switch (n.getType( ) ){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (mOwner) <if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (b.getType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <<else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (NodeType(n)){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) n.getType() = n.getProperty(n.GetType());{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &<else{
switch (t.type){
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <<else{
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()!= n){
switch (n.getType()) if (mControlFlow){
switch (aType){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch ((n.type)){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <else{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &<else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <else{
if (n) <switch (n){
switch (n.getType()) if (ControlFlowGraph.isOpening()) /* XXX */ switch (n.getType()){
switch (n.getType()) /* XXX */{
switch ( (n.getType())){
switch (n.getType()) if (ControlFlowGraph.isOpening()) &/* XXX */ switch (n.getType()){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (this.type){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) if (ControlFlowGraph.isLoaded()) &return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType() > 0){
switch (n.getType().type()){
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) == 0{
switch (Type(n)){
switch (n.getType()) &<else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <&else{
switch (n.getType()) <if (mOwner) &if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) else{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; else{
switch (n, type){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (ControlFlowGraph.isDestroying) return true;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType(aType)){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) n = n.getChildCount();{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (ControlFlowGraph.isLoaded()) <return true;{
if (n.type()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.DEC: case Token.ENC: case Token.DO_BEL: case Token.DO_C: case Token.DO_C: case Token.DO_R: case Token.DO_BEL: case Token.DO_NON: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_C: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_DEL: case Token.DO_BEL: case Token.DO_DEL: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_TX: case Token.DO_RX: case Token.DO_FX: case Token.DO_RX: case Token.DO_PX: case Token.DO_CX: case Token.DO_CX: case Token.DO_FX: case Token.DO_CX: case{
switch (isType(n)){
switch (n.getType())){
switch (n.getType()) <if (n.isPosition() && n.getType()!= n.getPosition()) <return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (controlFlowGraph.type()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <<else{
switch (n.GetType()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &else{
switch (n.type.get()){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.nodeType){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &&else{
switch (n.getCategory()){
switch (n.getType()) <if (mControlFlow){
switch (n.getType()) <n.stackAvailable = false;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (((NodeType)n).getType()){
switch (n.hasType()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <&else{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (n.isPosition() && n.getType()!= n.getPosition()) return true;{
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (pType){
switch (n.getType()) if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <n = n.getChildCount();{
switch (n.getType()) </* * If it is an object re-address of a non-native object. */{
switch (n.getType()) &/* We must do this before the object can * be passed in a field */{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <if (ControlFlowGraph.isOpening()) </* XXX */ switch (n.getType()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <&else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <&else{
if(n.getType()){
switch (n.getType()) &else{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (n.getFlags() & 0xfff) &return true;{
switch (n.type){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &<else{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.type && n.type){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) n.mType = n.getType();{
switch (&n.getType()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType(Node)){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &else{
switch (n.getType()) if (mOwner) &if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch ( n.getType() ){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (controlFlowGraph.type){
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.type!= n.type){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) &if (mControlFlow){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch ((int)n.getType()){
switch (n.getType()) <if (n.isPosition() && n.getType()!= n.getPosition()) return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
if (n.getType()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; else{
switch (n.getType()) if ((n == n.getProperty()) || (n == n.getOwner())) return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (*n){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <else{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.Type()){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) </* * XXX */{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &&else{
switch (n.getType()) case Token.PXX:{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (rv){
switch (n.mType){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <else{
switch (n.getType()) &;{
switch (n.getType()) <if (!ControlFlowGraph.isEmpty()) return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (c){
switch (c.type){
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (n.isPosition() && n.getType()!= n.getPosition()) <return true;{
switch ((n.GetType())){
switch (n.getType()) if (ControlFlowGraph.isLoaded()) <return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &<else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n == n.getType()){
switch (m.type()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (ControlFlowGraph.type(n)){
switch (n.getInstance()){
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <n.mType = n.getType();{
switch (n.getType()) n.put("TYPE");{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &&else{
if (n) switch (n.type){
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <else{
switch (n!= n.getType()){
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (self.type){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <<else{
switch (n.getType()) if (ControlFlowGraph.isLoaded()) return true;{
switch (n.getType()) &/* Node not present in the switcher and */ n = (Node)n;{
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <if (controlflowGraph.isInvalid(c)){
switch (n.getType()) &n.getType() = n.getProperty(n.GetType());{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &<else{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <&else{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) /* We've got the type of the callback, so get * this here. */ switch (n.getType()){
switch (n ){
switch (n.getType()) <else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &&else{
switch (n.type()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <else{
switch (getType()){
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <&else{
switch (n.getType()) </* XXX a new one */{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (getter_AddRefs(n)){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.type){
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &&else{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (kType){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.nType){
switch ((n = n.getType())){
switch (nType){
switch (n.getType()) <if (ControlFlowGraph.isLoaded()) return true;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <<else{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <&else{
switch (n.getType()) &if (n.isPosition() && n.getType()!= n.getPosition()) <return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n == n){
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <<else{
switch (n.getType(n)){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
switch (n.getType()) </* We've got the type of the callback, so get * this here. */ switch (n.getType()){
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
if (n.getType()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; &return false;{
&switch (n.getType()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch(n){
switch (m.type){
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &/* XXX a new one */{
switch ((n.type).type){
switch (ControlFlowGraph.isType(n)){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (n.getFlags() & 0xfff) return true;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch ((n.type())){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &n = n.getChildCount();{
switch (n.getType()) &&else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &<else{
switch (n.getType()) &if (n.getFlags() & 0xfff) &return true;{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n){
switch (n.getType()) <&else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <<else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &/* We've got the type of the callback, so get * this here. */ switch (n.getType()){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <else{
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &&else{
switch (n.getType()) <if (ControlFlowGraph.isOpening()) /* XXX */ switch (n.getType()){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &&else{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <&else{
if (n) switch (n.getType()){
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getTYPE()){
switch (strlen(n)){
switch (ntype){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &&else{
switch (n.getType()) n.stackAvailable = false;{
switch (n.getType()) <if (ControlFlowGraph.isDestroying) return true;{
switch (t.type()){
switch (r.type){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &&else{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (isSelect) return true;{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (ControlFlowGraph.getType()){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.eType){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) </* XXX */{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; else{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.Type){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <&else{
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) <&else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) n.type = n.getType();{
switch (gType){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; else{
switch (n.getType()) if (ControlFlowGraph.isDestroying) return true;{
switch (n.getType()) &if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; else{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.isEmpty()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; <<else{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n);{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) else if (c) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
if (n){
switch (c.getType()){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; &<else{
switch (n.getType()) else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &n.mType = n.getType();{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if ((n == n.getProperty()) || (n == n.getOwner())) return true;{
switch (n.getType()) if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) </* * For the * next function, we need to know whether the * next call has been inserted. */ switch (n.getType()){
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; else{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; else{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <<else{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &<else{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()){
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.nType()){
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; <<else{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &else{
switch (n.getType()) &<else if (c) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &break;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &else{
switch (n.getType()) &if (ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType(ControlFlowGraph)){
switch (oType){
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (eType){
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) &if (ControlFlowGraph.isOpening()) </* XXX */ switch (n.getType()){
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) <if (n.isPosition() && n.getType()!= n.getPosition()) &return true;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &&else{
switch (n.getType()) </* Node not present in the switcher and */ n = (Node)n;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &&else{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n).getType(){
switch (n!= null){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) return true; &else{
switch (n.getType()) <if (n.getType()!= n.GetType()) return true;{
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &if (mOwner) <if (mOwner) mOwner.ConcatenateWithConversion(n); mOwner.SetSubstring(n, mOwner); return true;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &<else{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; <&else{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) &return true; <<else{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; &&else{
switch (n.getType()) &case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &return false;{
switch (n.getType()) if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &&if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &<else{
switch (n.getType()) &if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) return true; &else{
switch (n.getType())!= 0{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) <case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false;{
switch (n.getType()) if (n.getFlags() & 0xfff) <return true;{
switch (n.getType().get()){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (ControlFlowGraph.getType(n)){
switch (GetType(n)){
switch (n.getType()) <if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) /* * Get the * Type type. */{
switch ((n.type())){
switch (n.getType()) <&else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) /* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) if (n.getParent() == n.getParent()) return true; <else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.ENC: case Token.DEC: case Token.FUNCTION: return true;{
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; &for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (itemType){
switch (n.getType()){
switch (NodeType){
switch (n.type.get()){
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &&else{
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; <else{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) &if (ControlFlowGraph.isLoaded()) <return true;{
switch (n.getType()) if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; <return false;{
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (n.getType()) <if (ControlFlowGraph.isLoaded()) &return true;{
switch (n.getType()) <if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; <return false;{
switch (n.getType()) &if (c!= null) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; else{
switch (null){
switch (n.getType()) /* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; &else if (n.getParent() == n.getParent()) </* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
switch (n.getType()) <if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) <return true; &&else{
switch (n.type && n.type){
switch (n.getType()) <case Token.TOT: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; if (n.getType() == Token.PROP || n.getType() ={
switch (n.getType(*n)){
switch (n.getType()) &case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; return false;{
switch (CType){
switch (n.getType()) if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <&else{
switch (n.getType()) &if (c!= null) &if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; <return false;{
switch (n.getType()) case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true;{
switch (n.getType()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &<else{
switch (n.getType()) <case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) &/* XXX */ if (n.getParent() == n.getParent()) &if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
if (n.isType()){
switch (n.getType()) &if (!ControlFlowGraph.isEnteringNewCfgNode(c)) <return true; &<else{
switch (n.getType()) &if (!ControlFlowGraph.isEmpty()) return true;{
switch (n.getType()) &if (controlflowGraph.isPositional((IStyleUnit*)n.mInFlow)) &return true; <&else{
if (n) &switch (n.type){
switch (n.getType()) &case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true;{
switch (n.isType()){
switch (n.getType()) <<else if (c) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true;{
switch (n.getType()) <if (controlflowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) return true; &<if (ControlFlowGraph.isEmpty()) return true; switch (n.getType()){
switch (m.getType()){
switch (n.getType()) case Token.CALL: case Token.GETPROP: case Token.GETELEM: case Token.THROW: case Token.INC: case Token.DEC: return true; case Token.FUNCTION: return false; <for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) <return true; return false;{
switch (n.getType()) if (c!= null) <if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) &return true; &return false;{
switch (n.getType()) </* XXX */ if (n.getParent() == n.getParent()) <if (n.getParent() == n.getParent()) return true; else if (n.getParent() == n.getParent()) &/* * Node exists, a nparent (e.g. '+') */ if (n.getType() == n.getParent()) if (n.getType() == n.getParent()) /* Now the first parent node is a Node and not the last node is in the result. */ return true; else if (n.getType() == n.getType()) return true; else return false; for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) <unk>{
