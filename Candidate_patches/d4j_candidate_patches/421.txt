getRegistry().remove(value);
getRegistry().remove(key);
GetRegistry().remove(new IDKey(value));
getRegistry().remove(new IDKey(value));

getRegistry().remove(value);
getRegistry().removeElement(new IDKey(value));
getRegistry().remove(&value);
getRegistry().remove(new nsIDKey(value));
getRegistry().removeKey(value);
getRegistry().remove(name);
getRegistry().remove(id);
getRegistry().remove(new IIDKey(value));
aRegistry.remove(new IDKey(value));
getRegistry().remove(IDKey(value));
mRegistry.remove(new IDKey(value));
getRegistry().remove(new idKey(value));
GetRegistry().remove(new IDKey(value));
(void) getRegistry().remove(new IDKey(value));
return getRegistry().remove(new IDKey(value));
getRegistry().remove(new _IDKey(value));
getRegistry().remove(key);
getRegistry().removeElement(value);
getRegistry().remove(new Key(value));
getRegistry().remove(aKey);
getRegistry().remove(idKey);
getRegistry().remove(nsCIDKey(value));
register.remove(new IDKey(value));
getRegistry().remove(nsIDKey(value));
getRegistry().removeAll(new IDKey(value));
getRegistry().free(value);
getRegistry().remove(null);
getRegistry().remove(new IDKey(value));
register().remove(new IDKey(value));
getRegistry().remove(new ObjectKey(value));
unregister(value);
aRegistry.remove(new IDKey(value));
getRegistry().remove (new IDKey (value));
getRegistry().remove( value );
getRegistry().remove(this);
getRegister().remove(new IDKey(value));
getRegistry().remove(idkey);
mRegistry.remove(new IDKey(value));
getRegistry().unregister(value);
getRegistry().remove(IIDKey(value));
get_registry().remove(new IDKey(value));
getRegistry().remove(new nsIDKey(value));
getRegistry().delete(new IDKey(value));
return getRegistry().remove(new IDKey(value));
getRegistry().remove(new IDKey(key));
getRegistry().remove(&key);
getRegistry().remove(aIDKey);
getRegistry().remove(*value);
getRegistry().remove(null);
getRegistry().remove(new IIDKey(value));
goto unregister;
getRegistry().remove(value.get());
getRegistry().remove((void**)value);
getRegistry().clear();
getRegistry(value);
getRegistry().removeKey(value);
getRegistry().removeValue(value);
getRegistry().remove(nsIIDKey(value));
getRegistry().remove(index);
getRegistry().remove((const IDKey*)value);
getRegistry().remove(new PRUint32(value));
getRegistry().remove(entry);
register.remove(new IDKey(value));
getRegistry().remove(name);
getRegistry().removeObject(new IDKey(value));
getRegistry().remove(_IDKey(value));
getRegistry().removeElement(new IDKey(value));
goto cleanup;
getRegistry().remove((void **)value);
goto out;
getRegistry().remove(key, value);
getRegistry().removeObject(value);
getRegistry().unregister(new IDKey(value));
getRegion().remove(new IDKey(value));
getRegistry().remove(nsAutoString(value));
getRegistry().remove(new IdentKey(value));
getRegistry().remove(addr);
register(value);
getRegistry().remove();
findRegistry().remove(new IDKey(value));
getRegistry().remove(None);
getRegistry().remove(const IDKey(value));
(void)getRegistry().remove(new IDKey(value));
getRegistry().remove(getter_Copies(value));
getRegistry().removeChild(new IDKey(value));
getRegistry().remove(nsIDKey(value));
getRegistry().remove(nodeInfo);
getRegistry().remove(new NSKey(value));
getRegistry().remove(type);
getRegistry().remove(nsCIDKey(value));
getRegistry().removeValue(new IDKey(value));
getRegistry().remove(new IDKey(&value));
nsresult rv;
getRegistry().remove(new idKey(value));
getRegistry().remove(obj);
if (!getRegistry())  return;
getRegistry().remove(strlen(value));
getRegistry().remove(&newIDKey(value));
getRegistry().remove(new CIDKey(value));
getRegistry().remove(new null);
theRegistry.remove(new IDKey(value));
getRegistry().remove(data);
getRegistry().remove(new IdKey(value));
do_remove(new IDKey(value));
free(value);
getRegistry().remove(&value);
getRegistry().remove(aRegistry);
register(new IDKey(value));
getRegistry().remove(new IDKey(aKey));
getRegistry().remove(do_QueryInterface(value));
if (value) getRegistry().remove(value);
getRegistry().remove(IDKey(value));
getRegistry().remove(new PIDKey(value));
getRegistry().remove(null);
getRegistry().remove(new RegistryKey(value));
getRegistry().remove(NS_NewIDKey(value));
getRegistry().remove("");
getRegistry().remove(new IDKey(value, 0));
getRegistry().remove((void**) value);
getRegistry().remove(p);
getRegistry().remove((void*)value);
getRegistry().remove(new uidKey(value));
getRegistry().remove(new idkey(value));
return NS_OK;
getRegistry().remove(uri);
getRegistry().remove(mRegistry);
getRegistry().remove(id);
getRegistry().remove(buf);
nsCRT::free(value);
getRegistry().remove(new (void) IDKey(value));
getRegistry().remove((PRUint32)value);
getRegistry().remove(new DOMKey(value));
do_remove(value);
removeRegistry();
getRegistry().removeElementAt(value);
remove(value);
goto done;
getRegistry().remove((nsIDKey*)value);
getRegistry().remove(new IDKey(key));
getRegistry().remove(new kIDKey(value));
getRegistry().remove(new &IDKey(value));
getRegistry().remove(new IDKey(value, null));
getRegistry().remove(false);
getRegistry().remove(new NS_IDKey(value));
goto delete;
getRegistry().remove((caddr_t)value);
getRegistry().remove(aRegistryKey);
getRegistry().remove(oldIDKey);
getRegistry().remove(NS_IDKey(value));
getRegistry().remove(new IDKey(value.get()));
getRegistry().remove(new IDKey(*value));
getRegistry();
getRegistry().remove(new IDKey(newKey));
getRegistry().remove((IIDKey*)value);
deregister(value);
return 0;
getRegistry().remove(NS_ID_KEY(value));
getRegistry().remove(new IDKey(value).get());
getRegistry().remove((IDKey*)value);
getRegistry().remove((PRInt32)value);
getRegistry().remove((void **) value);
getRegistry().remove(&idKey);
return new IDKey(value);
getRegistry().remove( new IDKey( value ) );
getRegistry().remove("%s", value);
getRegistry().remove((void *)value);
return getRegistry();
getRegistry().remove(NS_IDKEY(value));
getRegistry(&value);
getRegistry().remove(strdup(value));
getRegistry().remove((nsIIDKey*)value);
getRegistry().remove(new nsKey(value));
getRegistry().remove(new IDKey(&value));
clearRegistry();
getRegistry().remove((const IDKey*) value);
super.unregister(value);
getRegistry().remove(new IDKey(value), null);
delete getRegistry();
getRegistry().remove(new IDKey(value) + 1);
getRegistry().remove((const char*)value);
getRegistry().remove(new IDKey(id));
getRegistry().remove(new IDKey(value), 0);
getRegistry().remove((const IDKey&)value);
getRegistry().remove((PRUnichar *)value);
checkRegistry();
if (getRegistry()) getRegistry().remove(value);
getRegistry().remove((const IDKey *)value);
if (getRegistry()) getRegistry().remove(value);
getRegistry().remove((nsIDKey*) value);
getRegistry().remove((unsigned char*)value);
getRegistry().remove(nsIDKey::value);
if (!newKey(value))  ret = NS_OK; delete value;  else  ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED)  ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) return rv;
getRegistry().remove(new IDKey(_c.get()));
getRegistry().remove(new IDKey(value, &key));
if (getRegistry())  LOG(L_ERR, "removeRegistry: %s", value);  else  LOG(L_ERR, "removeRegistry: %s", value);
getRegistry().remove(new (IDKey*)value);
if (value)  if (!isSupported())  return NS_ERROR_UNEXPECTED;  return NS_OK;
if (value == null)  return;  if (! getRegistry())  nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document)  nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));  doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv = register(&value, &new_identity); if (NS_FAILED(rv)) return;
ret = getRegistry().remove(new IDKey(value)); if (ret)  if (ret == null)  /* XXX remove the register */ ret = ret;
if (!mRegistry)  getRegistry().remove(new IDKey(value));
getRegistry().remove(new char(value));
nsresult rv; if (id)  if (id == 0)  rv = IdNumKeys(&id); if (NS_FAILED(rv))  return rv;   return rv;
getRegistry().remove("%s", IDKey(value));
getRegistry().remove(new RDFKey(value));
getRegistry().remove(ref);
getRegistry().remove(reg.address);
getRegistry().remove(nsGenericCID::IDKey(value));
if (!eventType)  eventType = ev;  else  eventType = ev;
getRegistry().remove(new IDKey((const char *)value));
getRegistry().remove(NS_LITERAL_STRING("").get());
getRegistry().remove(mKey);
getRegistry().remove(NS_CONST_CAST(const IDKey(value)));
if (getRegistry()) getRegistry().remove(new IDKey(value));
if (getRegistry())  getRegistry().remove(new IDKey(value));
if ((ret = getRegistry()) == null)  /* we can't change the registry or rename the Registry */ if (ret)  if (!ret)  /* If this is the register, we will rename it. */ ret = rv;   else  if (ret == 0)  if (!ret)  /* * If we've got a register or rename the registry, we will not be here. */ ret = rv;  if (ret == 0)  ret = rv;   if (ret == 0)  ret = rv; ret = ret;      if (ret!= 0)  /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (mRegistry) getRegistry().remove(new IDKey(value));
getRegistry().remove(new PRInt32(value));
getRegistry().remove(nsCRT::strdup(value));
if ((value!= null) && (value.data.key == NS_ID_NAME))  if (*value.data.key.attributes)  *value.key = value; return;   else  LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key);  if (!getRegistry())  return;  return;
getRegistry().remove(new IDKey(value), getCurrentRegistry());
fprintf(stderr, "wrapping registration failedn"); if (! fprintf(stderr, "wrapped registry failedn");
getRegistry().remove(new rdf_id);
getRegistry().remove(new IDKey(getter_AddRefs(value)));
getRegistry().remove(new IDKey(unsigned char*));
ret = new IDKey(value); if (ret!= 0)  return ret;
getRegistry().remove(new char((const IDKey*)value));
getRegistry().remove(new IDKey(value) - value);
ret = getRegistry().remove(new IDKey(value)); if (ret && ret  0) return ret; ret = ret;
NS_INIT_REFCNT(); NS_ADDREF(value);
getRegistry().remove(NS_ID_STRING(value));
rv = getRegistry().remove(new IDKey(value)); if (rv)  mRegistry.remove(value);
NS_ENSURE_ARG_POINTER(value); if (! aKey)  aKey.delete(value); NS_RELEASE(value);
getRegistry().remove(new voidkey(value));
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry())  nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv))  NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
getRegistry().remove(new nsAString(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv)  rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0)  rv = NS_ERROR_OUT_OF_MEMORY;  if (rv == 0)  rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY;  else  rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
getRegistry().remove(new IDKey((CString*)value));
if (value)  getRegistry().remove(new IDKey(value));
getRegistry().remove(nsIIDKey::IDKey(value));
getRegistry().remove(NS_STATIC_CAST(nsIRegistry *, value));
if (isRegistry)  fprintf(stderr, "unregister: %sn", __func__); getRegistry().remove(&isRegistry);
if (getRegistry())  if (value)  delete nsGenericHostAddress(&key.lssHostAddress, value);  else  nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
NS_REINTERPRET_CAST(nsIDKey*, value).removeFromRegistry(nsIDKey(value));
getRegistry().remove(new kNameSpaceIDKey(value));
if (! aDirty)  return;  if (value == '0')  aDirty = false;  if (aDirty!= false)  aDirty = true; return;
rv = getRegistry(); if (NS_FAILED(rv)) return rv; rv = rename(name, value); if (NS_FAILED(rv)) return rv;
if (!value) return;
if (getRegistry())  if (NS_SUCCEEDED(&gRegistry.remove(key)))  if (!gRegistry.remove(key)) return 0;  gRegistry.remove(key);
if (getRegistry().remove(new IDKey(value)))  void unregister(value);
if (!m_get_flags)  m_get_flags = 0;  else  m_get_flags = 0;
if (value)  if (type!= TYPE_CAST)  if (value.__dp == __DPRINTF)  delete value; return (0);    else  if (type == TYPE_CAST)  if (type == TYPE_CAST)  /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT)  if (! rename)  return -1;    if (type == TYPE_PROGRAM)  /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM;    else  rename = TYPE_CONTENT_PROGRAM;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry())  ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry();  else  ret = new IDKey(value); if (ret)  ret = ret;
if (!getRegistry())  getRegistry().remove(new IDKey(value));
getRegistry().remove(NS_LITERAL_STRING("identity"));
if (getRegistry()) getRegistry().remove(new IDKey(value));
if (value)  retval = new IDKey(value); if (retval == 0)  retval = -1; goto unregister;
getRegistry().remove((IDKey*)new IDKey(value));
fputs("removed");
if (id)  GetRegistry().remove(id);
NS_INIT_REFCNT();
if (mRegistry)  mRegistry.remove(new IDKey(value));
getRegistry().remove((unsigned char*) value);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService)  return NS_ERROR_NULL_POINTER;  if (!eService)  return NS_ERROR_NULL_POINTER;  else  return NS_ERROR_NULL_POINTER;
getRegistry().remove((PRInt32) value);
if (!getRegistry()) return; /* GetRegistry() has to be created if no registry */ getRegistry().remove(new IDKey(value)); if (!this) return;
if (getRegistry().get() == null)  getRegistry().remove(new IDKey(value));
if (isValid())  getRegistry().remove(new IDKey(value));
if ((entry = getRegistry()))  if (!entry.is_entry())  break;   else  getRegistry().remove(new IDKey(value));
if (!getRegistry()) return; getRegistry().remove(new IDKey(value));
getRegistry().remove((ContentUtils)value);
if (!getRegistry())  mRegistry.remove(new IDKey(value));
getRegistry().remove(NS_LITERAL_STRING("name"));
if (id == null)  id = jd_register(id, value); if (id!= null)  id = jd_register(id, value);
/*remove IDKey(value); */
getRegistry().remove((PRUnichar*)new IDKey(value));
getRegistry().remove(NS_ConvertASCIItoUCS2(value));
if (value) getRegistry().remove(new IDKey(value));
if (!value) return 0; goto delete;
getRegistry().remove(new IDKey((KeyType)value));
rv = GetRegistry(); if (NS_FAILED(rv)) return rv; delete rv; /* delete id_slots, or id_listslots.lowerCase(); */ if (NS_FAILED(rv)) return rv;
if (eRegistry && newIDKey(value))  /* XXX this may cause the register to work out to zero */
getRegistry().remove(((void*)value).get());
if (getRegistry())  getRegistry().remove(new IDKey(value));
getRegistry().remove(NS_STATIC_CAST(nsIDecoder*, value));
if (isOpen())  /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL)  /* Remove the _registered entry. */ if (!isOpen())  delete this; return 0;  return 0;
getRegistry().remove((IDKey)value);
if (!ioctl)  /* * Unregister ioctl in a log entry */ ioctl.octl = null;  else  ioctl.octl = null;  if (!ioctl)  return ioctl;  if (!ioctl.octl)  ioctl.octl = null;  if (ioctl.octl == 0)  return ioctl;   else  if (ioctl.octl == 0)  return ioctl;
if (!isDocument) return NS_ERROR_NULL_POINTER; if (!getRegistry())  getRegistry().remove(new IDKey(value));
if (need_register)  idKeys(need_register);  else  /* The new IDKey key must be changed before */ if (need_register)  /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys);  if (need_register)  /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
getRegistry().remove((PRUint32) value);
if (!getRegistry()) return 0; /* If we don't have a register, we will remove a new registry entry. */
retval = getRegistry().remove(new IDKey(value)); if (retval)  return;
if (!(value = getRegistry()))  return;  if (value == 0)  return;  if (value == 0)  if (value == -1)  return;
getRegistry().remove(new IDKey((ContentEnumerator*)value));
if (!getRegistry())  return NS_ERROR_FAILURE;
if (! aRegistry)  ret = new Object[MAX_ID]; if (ret)  ret.mDirty = false; ret.mContent = null;   else  ret.mContent = null;  return ret;
getRegistry().remove(new gIDKey(value));
if (!value)  getRegistry().remove(new IDKey(value));
getRegistry().remove(new IDKey(_CTOR_EXCLUSIVE));
if (! getRegistry())  return;  if (getCertificateKey(value))  mRegistry.remove(((CertificateKey*)value));
/* Unregister this object for the user's access. */ getRegistry().remove(new IDKey(value)); /* XXX XXX */
getRegistry().remove(NS_LITERAL_STRING("ident"));
if (!mRegistry) return NS_ERROR_OUT_OF_MEMORY; mRegistry = null; if (!mRegistry) return NS_ERROR_OUT_OF_MEMORY;
rv = getRegistry().remove(new IDKey(value)); if (rv == null)  return NS_ERROR_NULL_POINTER;  if (rv == null)  rv = unregister(result);
getRegistry().remove(s);
getRegistry().remove(getter_AddRefs(value));
getRegistry().remove((*value));
getRegistry().remove(new IDKey(value) & 0xFFFF);
if (*value == '0' ||!getRegistry().containsKey(value))  return;  getRegistry().remove(value);
if (!aRegistry)  NS_ERROR("Failed to register register"); return NS_OK;  if (!aRegistry)  NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv))  printf("Unable to remove registry entryn"); return;
if (isRegistry) &fprintf(stderr, "unregister: %sn", __func__); getRegistry().remove(&isRegistry);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) ret = ret;
if (value == null) return; <if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!newKey(value)) <ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) return; &if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value == null) <return; if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aDirty) <return; &if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) &idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!getRegistry()) &return NS_ERROR_FAILURE;
if (! getRegistry()) &return; if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (!(value = getRegistry())) &return; &if (value == 0) return; &if (value == 0) if (value == -1) return;
if (!(value = getRegistry())) &return; <if (value == 0) &return; if (value == 0) if (value == -1) return;
if (eRegistry && newIDKey(value)) /* XXX this may cause the register to work out to zero */
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!(value = getRegistry())) return; &if (value == 0) &return; if (value == 0) if (value == -1) return;
if (!newKey(value)) <ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) printf("Unable to remove registry entry<n"); return;
if (! aDirty) return; &if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) ret = ret;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (isRegistry) fprintf(stderr, "unregister: %s<n", __func__); getRegistry().remove(&isRegistry);
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (!(value = getRegistry())) <return; &if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (! aDirty) &return; if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! getRegistry()) return; if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if (!newKey(value)) <ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (need_register) idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
fprintf(stderr, "wrapping registration failed<n"); if (! fprintf(stderr, "wrapped registry failed<n");
if (! aDirty) return; if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (*value == '<0' ||!getRegistry().containsKey(value)) return; &getRegistry().remove(value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) ret = ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry().remove(new IDKey(value))) <void unregister(value);
ret = getRegistry().remove(new IDKey(value)); if (ret) <if (ret == null) /* XXX remove the register */ ret = ret;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (value) <if (!isSupported()) &return NS_ERROR_UNEXPECTED; &return NS_OK;
if (! aDirty) return; <if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!(value = getRegistry())) &return; if (value == 0) <return; if (value == 0) if (value == -1) return;
if (! aDirty) <return; &if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (value == null) return; <if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! getRegistry()) <return; <if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (!newKey(value)) <ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (value == null) return; if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aDirty) <return; &if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (need_register) idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (isValid()) &getRegistry().remove(new IDKey(value));
if (*value == '0' ||!getRegistry().containsKey(value)) &return; <getRegistry().remove(value);
if (value == null) &return; &if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (!newKey(value)) &ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!(value = getRegistry())) <return; <if (value == 0) &return; <if (value == 0) if (value == -1) return;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) <ret = ret;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (*value == '<0' ||!getRegistry().containsKey(value)) &return; &getRegistry().remove(value);
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
fprintf(stderr, "wrapping registration failed&n"); if (! fprintf(stderr, "wrapped registry failed<n");
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if (*value == '<0' ||!getRegistry().containsKey(value)) &return; getRegistry().remove(value);
if (!m_get_flags) &m_get_flags = 0; else m_get_flags = 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((entry = getRegistry())) if (!entry.is_entry()) <break; else getRegistry().remove(new IDKey(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (need_register) idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry().remove(new IDKey(value))) void unregister(value);
if (!eventType) eventType = ev; else <eventType = ev;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) &return; <if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!eventType) eventType = ev; else eventType = ev;
if (value) <if (!isSupported()) &return NS_ERROR_UNEXPECTED; return NS_OK;
if (!(value = getRegistry())) &return; if (value == 0) &return; if (value == 0) if (value == -1) return;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (! aDirty) <return; &if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) &idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (need_register) <idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!newKey(value)) ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!(value = getRegistry())) return; <if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (value == null) &return; &if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!(value = getRegistry())) &return; &if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (!eventType) <eventType = ev; <else eventType = ev;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!newKey(value)) &ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) return; <if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value == null) return; &if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aDirty) &return; <if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) &ret = ret;
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); else <LOG(L_ERR, "removeRegistry: %s", value);
if (!newKey(value)) <ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (isRegistry) fprintf(stderr, "unregister: %sn", __func__); getRegistry().remove(&isRegistry);
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) <ret = ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (value == null) <return; <if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! getRegistry()) &return; if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if (*value == '&0' ||!getRegistry().containsKey(value)) &return; &getRegistry().remove(value);
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) &ret = ret;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) ret = ret;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!newKey(value)) ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (! getRegistry()) return; &if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <printf("Unable to remove registry entry&n"); return;
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); &else <LOG(L_ERR, "removeRegistry: %s", value);
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (getRegistry()) getRegistry().remove(new IDKey(value));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; if (rv == null) rv = unregister(result);
if (!newKey(value)) ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) <return; if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) <if (!isSupported()) return NS_ERROR_UNEXPECTED; &return NS_OK;
if (!eventType) &eventType = ev; else &eventType = ev;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; &if (rv == null) <rv = unregister(result);
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); <else <LOG(L_ERR, "removeRegistry: %s", value);
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; &<else getRegistry().remove(new IDKey(value));
if (!eventType) &eventType = ev; &else <eventType = ev;
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; <&else getRegistry().remove(new IDKey(value));
if (!newKey(value)) &ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (need_register) idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) ret = ret;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (id == null) &id = jd_register(id, value); if (id!= null) <id = jd_register(id, value);
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); <else LOG(L_ERR, "removeRegistry: %s", value);
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (! aDirty) &return; &if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!newKey(value)) ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) &ret = ret;
if (need_register) idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!newKey(value)) <ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (!(value = getRegistry())) &return; if (value == 0) return; if (value == 0) if (value == -1) return;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) <ret = ret;
getRegistry().remove(value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) &ret = ret;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) <return; <if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!getRegistry()) return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
ret = new IDKey(value); if (ret!= 0) &return ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) ret = ret;
if (!eventType) eventType = ev; <else &eventType = ev;
if (value == null) <return; &if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (*value == '&0' ||!getRegistry().containsKey(value)) return; &getRegistry().remove(value);
ret = getRegistry().remove(new IDKey(value)); if (ret) if (ret == null) </* XXX remove the register */ ret = ret;
if (value == null) return; <if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; else getRegistry().remove(new IDKey(value));
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (! aDirty) <return; if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (! getRegistry()) return; if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; <if (rv == null) rv = unregister(result);
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; &<else getRegistry().remove(new IDKey(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) <nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
fprintf(stderr, "wrapping registration failed&n"); if (! fprintf(stderr, "wrapped registry failed&n");
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) &ret = ret;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) <return; &if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value == null) &return; if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!m_get_flags) m_get_flags = 0; <else &m_get_flags = 0;
if (value == null) &return; &if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); &else <LOG(L_ERR, "removeRegistry: %s", value);
if (id == null) <id = jd_register(id, value); if (id!= null) <id = jd_register(id, value);
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; else getRegistry().remove(new IDKey(value));
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! getRegistry()) <return; <if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if (!(value = getRegistry())) &return; if (value == 0) return; <if (value == 0) if (value == -1) return;
retval = getRegistry().remove(new IDKey(value)); if (retval) <return;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (!newKey(value)) &ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (! getRegistry()) &return; &if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (! aDirty) &return; if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) <if (!isSupported()) <return NS_ERROR_UNEXPECTED; &return NS_OK;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (need_register) &idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (getRegistry().get() == null) <getRegistry().remove(new IDKey(value));
if (!eventType) <eventType = ev; &else &eventType = ev;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (!newKey(value)) &ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; if (rv == null) <rv = unregister(result);
if (need_register) <idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (! getRegistry()) <return; if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; <else getRegistry().remove(new IDKey(value));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) ret = ret;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) retval = new IDKey(value); if (retval == 0) &retval = -1; goto unregister;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (value) <if (!isSupported()) &return NS_ERROR_UNEXPECTED; <return NS_OK;
if ((entry = getRegistry())) if (!entry.is_entry()) &break; &else getRegistry().remove(new IDKey(value));
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eventType) eventType = ev; <else eventType = ev;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) <nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (*value == '<0' ||!getRegistry().containsKey(value)) <return; getRegistry().remove(value);
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if (!newKey(value)) <ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (!(value = getRegistry())) &return; &if (value == 0) return; if (value == 0) if (value == -1) return;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; &<else getRegistry().remove(new IDKey(value));
if (eRegistry && newIDKey(value)) </* XXX this may cause the register to work out to zero */
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (!(value = getRegistry())) <return; if (value == 0) return; <if (value == 0) if (value == -1) return;
if (!newKey(value)) ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
ret = getRegistry().remove(new IDKey(value)); if (ret && ret &0) return ret; ret = ret;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (mRegistry) mRegistry.remove(new IDKey(value));
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) &return; if (value == 0) return; &if (value == 0) if (value == -1) return;
if (!newKey(value)) ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!(value = getRegistry())) &return; <if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (need_register) idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!m_get_flags) <m_get_flags = 0; <else &m_get_flags = 0;
if (value == null) return; <if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; if (rv == null) &rv = unregister(result);
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eventType) <eventType = ev; else eventType = ev;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) ret = ret;
if (! getRegistry()) return; <if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; <if (rv == null) <rv = unregister(result);
if (value == null) return; <if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) &return; &if (value == 0) &return; if (value == 0) if (value == -1) return;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (!(value = getRegistry())) return; &if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (!newKey(value)) <ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if (!newKey(value)) ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (!(value = getRegistry())) return; <if (value == 0) &return; <if (value == 0) if (value == -1) return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) ret = ret;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aDirty) return; if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); <else &LOG(L_ERR, "removeRegistry: %s", value);
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; &if (rv == null) rv = unregister(result);
if (! aDirty) <return; if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aDirty) return; &if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) &ret = ret;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
if (value == null) <return; <if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (isRegistry) <fprintf(stderr, "unregister: %s&n", __func__); getRegistry().remove(&isRegistry);
if (value) <if (!isSupported()) <return NS_ERROR_UNEXPECTED; return NS_OK;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) &ret = ret;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; &else getRegistry().remove(new IDKey(value));
if (! getRegistry()) return; &if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
rv = getRegistry().remove(new IDKey(value)); if (rv) mRegistry.remove(value);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!getRegistry()) mRegistry.remove(new IDKey(value));
if (!eventType) eventType = ev; &else <eventType = ev;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (need_register) idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (! getRegistry()) &return; &if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; if (rv == null) rv = unregister(result);
if ((entry = getRegistry())) if (!entry.is_entry()) break; &<else getRegistry().remove(new IDKey(value));
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (need_register) idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) if (!isSupported()) &return NS_ERROR_UNEXPECTED; &return NS_OK;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) <ret = ret;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
NS_ENSURE_ARG_POINTER(value); if (! aKey) &aKey.delete(value); NS_RELEASE(value);
if (need_register) <idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; <if (rv == null) &rv = unregister(result);
if (*value == '<0' ||!getRegistry().containsKey(value)) return; <getRegistry().remove(value);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) <return; <if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (!value) getRegistry().remove(new IDKey(value));
if (value) &retval = new IDKey(value); if (retval == 0) <retval = -1; goto unregister;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isValid()) <getRegistry().remove(new IDKey(value));
if ((entry = getRegistry())) if (!entry.is_entry()) break; <&else getRegistry().remove(new IDKey(value));
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); &else &LOG(L_ERR, "removeRegistry: %s", value);
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) &ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
ret = getRegistry().remove(new IDKey(value)); if (ret) &if (ret == null) &/* XXX remove the register */ ret = ret;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eventType) <eventType = ev; <else <eventType = ev;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) <ret = ret;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
rv = getRegistry().remove(new IDKey(value)); if (rv) &mRegistry.remove(value);
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) &return; <if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!m_get_flags) <m_get_flags = 0; <else <m_get_flags = 0;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) <ret = ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; if (rv == null) <rv = unregister(result);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (!newKey(value)) ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (*value == '&0' ||!getRegistry().containsKey(value)) <return; <getRegistry().remove(value);
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry().get() == null) &getRegistry().remove(new IDKey(value));
if (value) <retval = new IDKey(value); if (retval == 0) <retval = -1; goto unregister;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) <ret = ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) ret = ret;
if (value == null) return; &if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!value) &getRegistry().remove(new IDKey(value));
if (!newKey(value)) ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; <if (rv == null) &rv = unregister(result);
if (id == null) id = jd_register(id, value); if (id!= null) <id = jd_register(id, value);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) return; &if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aDirty) &return; if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; <else getRegistry().remove(new IDKey(value));
if ((entry = getRegistry())) <if (!entry.is_entry()) break; &else getRegistry().remove(new IDKey(value));
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (need_register) <idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!(value = getRegistry())) &return; <if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (need_register) idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value == null) &return; if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eventType) &eventType = ev; <else &eventType = ev;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (need_register) <idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (!eventType) eventType = ev; &else eventType = ev;
if (value) retval = new IDKey(value); if (retval == 0) retval = -1; goto unregister;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); else LOG(L_ERR, "removeRegistry: %s", value);
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); &else LOG(L_ERR, "removeRegistry: %s", value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) <ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) if (!entry.is_entry()) &break; <&else getRegistry().remove(new IDKey(value));
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) return; &if (value == 0) return; <if (value == 0) if (value == -1) return;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (*value == '0' ||!getRegistry().containsKey(value)) return; getRegistry().remove(value);
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!(value = getRegistry())) return; &if (value == 0) return; if (value == 0) if (value == -1) return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
if (value == null) &return; &if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!(value = getRegistry())) return; if (value == 0) &return; if (value == 0) if (value == -1) return;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (need_register) &idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (isRegistry) <fprintf(stderr, "unregister: %sn", __func__); getRegistry().remove(&isRegistry);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) ret = ret;
if (need_register) <idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value == null) return; <if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((entry = getRegistry())) if (!entry.is_entry()) <break; <&else getRegistry().remove(new IDKey(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if (getRegistry()) &getRegistry().remove(new IDKey(value));
if (need_register) idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
ret = getRegistry().remove(new IDKey(value)); if (ret) &if (ret == null) </* XXX remove the register */ ret = ret;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (need_register) idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) &if (!isSupported()) return NS_ERROR_UNEXPECTED; <return NS_OK;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) ret = ret;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (need_register) &idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!m_get_flags) <m_get_flags = 0; <else m_get_flags = 0;
if (!newKey(value)) &ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (!(value = getRegistry())) return; <if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (*value == '&0' ||!getRegistry().containsKey(value)) <return; getRegistry().remove(value);
if (need_register) <idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) <return; &if (value == 0) &return; if (value == 0) if (value == -1) return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (!(value = getRegistry())) &return; if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (need_register) idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) &return; &if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!(value = getRegistry())) &return; if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (*value == '&0' ||!getRegistry().containsKey(value)) &return; <getRegistry().remove(value);
if (!(value = getRegistry())) &return; <if (value == 0) return; <if (value == 0) if (value == -1) return;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <printf("Unable to remove registry entryn"); return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!getRegistry()) &mRegistry.remove(new IDKey(value));
if (!newKey(value)) ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! getRegistry()) &return; &if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if (!mRegistry) getRegistry().remove(new IDKey(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; <if (rv == null) <rv = unregister(result);
if (value) &if (!isSupported()) return NS_ERROR_UNEXPECTED; &return NS_OK;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (!newKey(value)) <ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!newKey(value)) &ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; <&else getRegistry().remove(new IDKey(value));
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) printf("Unable to remove registry entry&n"); return;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &printf("Unable to remove registry entry&n"); return;
if (need_register) &idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!newKey(value)) &ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
ret = new IDKey(value); if (ret!= 0) <return ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!newKey(value)) <ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (value == null) return; if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((entry = getRegistry())) if (!entry.is_entry()) &break; <<else getRegistry().remove(new IDKey(value));
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) <return; &if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (! getRegistry()) <return; &if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if (*value == '&0' ||!getRegistry().containsKey(value)) return; <getRegistry().remove(value);
if (!newKey(value)) <ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) return; &if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) <ret = ret;
if (!newKey(value)) ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) <if (!entry.is_entry()) break; <<else getRegistry().remove(new IDKey(value));
if (value == null) <return; <if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) <ret = ret;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
if (value == null) <return; if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (id == null) id = jd_register(id, value); if (id!= null) &id = jd_register(id, value);
if (! aDirty) &return; &if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; if (rv == null) rv = unregister(result);
if (id) <GetRegistry().remove(id);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value == null) &return; &if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (!(value = getRegistry())) <return; if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (value == null) return; &if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) &getRegistry().remove(new IDKey(value));
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; if (rv == null) &rv = unregister(result);
if (!m_get_flags) &m_get_flags = 0; else <m_get_flags = 0;
ret = getRegistry().remove(new IDKey(value)); if (ret && ret <0) return ret; ret = ret;
if (need_register) idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value == null) <return; &if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (!getRegistry()) <return NS_ERROR_FAILURE;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (need_register) <idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (*value == '&0' ||!getRegistry().containsKey(value)) <return; &getRegistry().remove(value);
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) <ret = ret;
if (! aDirty) <return; <if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) getRegistry().remove(new IDKey(value));
if (need_register) idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) <ret = ret;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) &return; if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) <return; <if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (need_register) &idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (!getRegistry()) getRegistry().remove(new IDKey(value));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) ret = ret;
if (value == null) <return; &if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (!(value = getRegistry())) <return; <if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) ret = ret;
if (need_register) &idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (need_register) &idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (*value == '0' ||!getRegistry().containsKey(value)) return; <getRegistry().remove(value);
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if (need_register) &idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value == null) return; <if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (value == null) &return; <if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aDirty) return; <if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!newKey(value)) <ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (!isSupported()) &return NS_ERROR_UNEXPECTED; return NS_OK;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!newKey(value)) <ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (!newKey(value)) &ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) <return; &if (value == 0) return; &if (value == 0) if (value == -1) return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!newKey(value)) &ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (need_register) &idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!newKey(value)) ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (*value == '<0' ||!getRegistry().containsKey(value)) &return; <getRegistry().remove(value);
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (! getRegistry()) return; if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if (need_register) <idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (getRegistry()) <getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (id) GetRegistry().remove(id);
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) <if (!entry.is_entry()) break; <else getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (value) if (!isSupported()) &return NS_ERROR_UNEXPECTED; <return NS_OK;
if (! aDirty) <return; if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value == null) <return; &if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (*value == '&0' ||!getRegistry().containsKey(value)) return; getRegistry().remove(value);
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (value == null) return; if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if ((entry = getRegistry())) if (!entry.is_entry()) break; &&else getRegistry().remove(new IDKey(value));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; &<else getRegistry().remove(new IDKey(value));
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) ret = ret;
if (value == null) &return; <if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!m_get_flags) &m_get_flags = 0; &else &m_get_flags = 0;
if (!(value = getRegistry())) &return; &if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (! getRegistry()) &return; if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
retval = getRegistry().remove(new IDKey(value)); if (retval) &return;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; if (rv == null) <rv = unregister(result);
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
ret = new IDKey(value); if (ret!= 0) return ret;
if (! aDirty) return; &if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (*value == '0' ||!getRegistry().containsKey(value)) <return; <getRegistry().remove(value);
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (value) &if (!isSupported()) <return NS_ERROR_UNEXPECTED; return NS_OK;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) <ret = ret;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); &else &LOG(L_ERR, "removeRegistry: %s", value);
fprintf(stderr, "wrapping registration failedn"); if (! fprintf(stderr, "wrapped registry failedn");
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; else getRegistry().remove(new IDKey(value));
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
if (!newKey(value)) ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((entry = getRegistry())) <if (!entry.is_entry()) break; &<else getRegistry().remove(new IDKey(value));
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (! aDirty) return; if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!newKey(value)) ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &printf("Unable to remove registry entryn"); return;
if (value == null) return; <if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!newKey(value)) ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (*value == '<0' ||!getRegistry().containsKey(value)) return; getRegistry().remove(value);
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) <ret = ret;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) <nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (value == null) return; &if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (need_register) idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (!isSupported()) &return NS_ERROR_UNEXPECTED; &return NS_OK;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; &else getRegistry().remove(new IDKey(value));
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; &<else getRegistry().remove(new IDKey(value));
if (! getRegistry()) return; <if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if (! aDirty) &return; &if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!mRegistry) <getRegistry().remove(new IDKey(value));
if (!getRegistry()) <getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) return; &if (value == 0) return; &if (value == 0) if (value == -1) return;
if (! aDirty) &return; &if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); <else &LOG(L_ERR, "removeRegistry: %s", value);
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
getRegistry().remove(key);
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if (*value == '0' ||!getRegistry().containsKey(value)) <return; getRegistry().remove(value);
if (! aDirty) <return; <if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) &idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (*value == '0' ||!getRegistry().containsKey(value)) return; &getRegistry().remove(value);
if (! aDirty) return; &if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value == null) return; if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((entry = getRegistry())) if (!entry.is_entry()) break; <<else getRegistry().remove(new IDKey(value));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (need_register) <idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
fprintf(stderr, "wrapping registration failedn"); if (! fprintf(stderr, "wrapped registry failed<n");
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; <else getRegistry().remove(new IDKey(value));
if (! aDirty) return; <if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; &if (rv == null) rv = unregister(result);
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (need_register) <idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; &if (rv == null) &rv = unregister(result);
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (! aDirty) <return; if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!newKey(value)) &ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) &return; if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value == null) &return; if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (!(value = getRegistry())) return; if (value == 0) &return; <if (value == 0) if (value == -1) return;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) &return; <if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!m_get_flags) <m_get_flags = 0; else m_get_flags = 0;
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; <<else getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) <return; if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (!newKey(value)) <ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; &if (rv == null) rv = unregister(result);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!(value = getRegistry())) <return; if (value == 0) <return; if (value == 0) if (value == -1) return;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aDirty) <return; <if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (need_register) <idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) &*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) return; if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((entry = getRegistry())) if (!entry.is_entry()) <break; <<else getRegistry().remove(new IDKey(value));
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (eRegistry && newIDKey(value)) &/* XXX this may cause the register to work out to zero */
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) &ret = ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!(value = getRegistry())) &return; if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (!newKey(value)) <ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if ((entry = getRegistry())) if (!entry.is_entry()) break; &else getRegistry().remove(new IDKey(value));
if (! aDirty) return; if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) &ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; <<else getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) return; if (value == 0) <return; if (value == 0) if (value == -1) return;
if (need_register) idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!(value = getRegistry())) return; if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (value == null) &return; <if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eventType) &eventType = ev; <else eventType = ev;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (value) &retval = new IDKey(value); if (retval == 0) retval = -1; goto unregister;
if (value == null) &return; if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!m_get_flags) <m_get_flags = 0; &else m_get_flags = 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (! getRegistry()) <return; if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); &else &LOG(L_ERR, "removeRegistry: %s", value);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; <<else getRegistry().remove(new IDKey(value));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) &ret = ret;
ret = getRegistry().remove(new IDKey(value)); if (ret && ret 0) return ret; ret = ret;
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) <ret = ret;
if (!newKey(value)) <ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) &return; if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) <if (!entry.is_entry()) break; else getRegistry().remove(new IDKey(value));
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) <ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (!isSupported()) &return NS_ERROR_UNEXPECTED; <return NS_OK;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!newKey(value)) &ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) return; <if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) &if (!isSupported()) <return NS_ERROR_UNEXPECTED; &return NS_OK;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (! aDirty) <return; if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) ret = ret;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!eventType) &eventType = ev; &else eventType = ev;
if (isRegistry) &fprintf(stderr, "unregister: %s<n", __func__); getRegistry().remove(&isRegistry);
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) if (!isSupported()) <return NS_ERROR_UNEXPECTED; &return NS_OK;
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; &&else getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) return; <if (value == 0) return; &if (value == 0) if (value == -1) return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (! aDirty) &return; <if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!newKey(value)) &ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (!isSupported()) <return NS_ERROR_UNEXPECTED; <return NS_OK;
if (value) if (!isSupported()) <return NS_ERROR_UNEXPECTED; return NS_OK;
if (!(value = getRegistry())) &return; <if (value == 0) <return; if (value == 0) if (value == -1) return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) <if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) &ret = ret;
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (need_register) &idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (need_register) idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
if (need_register) idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!newKey(value)) ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (value == null) return; if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (*value == '0' ||!getRegistry().containsKey(value)) <return; &getRegistry().remove(value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) &ret = ret;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (isValid()) getRegistry().remove(new IDKey(value));
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (need_register) &idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (! aDirty) <return; <if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (! aDirty) &return; <if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (value == null) <return; if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! getRegistry()) <return; <if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (!m_get_flags) <m_get_flags = 0; &else &m_get_flags = 0;
if (need_register) <idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) <ret = ret;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; &&else getRegistry().remove(new IDKey(value));
if (!newKey(value)) <ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (id == null) id = jd_register(id, value); if (id!= null) id = jd_register(id, value);
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if (value) <if (!isSupported()) return NS_ERROR_UNEXPECTED; return NS_OK;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if (value == null) &return; if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (need_register) &idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value == null) &return; &if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (need_register) <idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!(value = getRegistry())) <return; <if (value == 0) &return; if (value == 0) if (value == -1) return;
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; &else getRegistry().remove(new IDKey(value));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) ret = ret;
rv = getRegistry().remove(new IDKey(value)); if (rv) <mRegistry.remove(value);
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) return; <if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value == null) <return; &if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) &ret = ret;
ret = getRegistry().remove(new IDKey(value)); if (ret) if (ret == null) /* XXX remove the register */ ret = ret;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) &ret = ret;
if (need_register) <idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (need_register) <idKeys(need_register); else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!getRegistry()) <return;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) ret = ret;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (! aDirty) <return; &if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (id == null) &id = jd_register(id, value); if (id!= null) &id = jd_register(id, value);
if (!(value = getRegistry())) <return; <if (value == 0) <return; if (value == 0) if (value == -1) return;
if (! aDirty) return; if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!(value = getRegistry())) &return; <if (value == 0) return; &if (value == 0) if (value == -1) return;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!(value = getRegistry())) return; if (value == 0) return; &if (value == 0) if (value == -1) return;
if (!(value = getRegistry())) <return; if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if (value == null) <return; <if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (! aDirty) return; <if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) ret = ret;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (!(value = getRegistry())) <return; if (value == 0) return; if (value == 0) if (value == -1) return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) ret = ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) ret = ret;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) <ret = ret;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (!m_get_flags) m_get_flags = 0; <else m_get_flags = 0;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) return; <if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
ret = getRegistry().remove(new IDKey(value)); if (ret) <if (ret == null) &/* XXX remove the register */ ret = ret;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (! getRegistry()) return; <if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
ret = getRegistry().remove(new IDKey(value)); if (ret) &if (ret == null) /* XXX remove the register */ ret = ret;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (!newKey(value)) <ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; <if (rv == null) &rv = unregister(result);
if (*value == '<0' ||!getRegistry().containsKey(value)) <return; &getRegistry().remove(value);
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (value) if (!isSupported()) return NS_ERROR_UNEXPECTED; <return NS_OK;
if (!getRegistry()) &getRegistry().remove(new IDKey(value));
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; <<else getRegistry().remove(new IDKey(value));
if (value == null) <return; if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value) &if (!isSupported()) return NS_ERROR_UNEXPECTED; return NS_OK;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) <ret = ret;
if (value) <retval = new IDKey(value); if (retval == 0) retval = -1; goto unregister;
if (need_register) &idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!newKey(value)) &ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; <else getRegistry().remove(new IDKey(value));
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); <else LOG(L_ERR, "removeRegistry: %s", value);
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); else LOG(L_ERR, "removeRegistry: %s", value);
if (!m_get_flags) &m_get_flags = 0; &else <m_get_flags = 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (! aDirty) <return; &if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; <&else getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) return; &if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) &idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (need_register) <idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
retval = getRegistry().remove(new IDKey(value)); if (retval) return;
if (! aDirty) <return; &if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; &if (rv == null) <rv = unregister(result);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) ret = ret;
if (!newKey(value)) &ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; gRegistry.remove(key);
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) &ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (id == null) <id = jd_register(id, value); if (id!= null) &id = jd_register(id, value);
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!getRegistry()) return NS_ERROR_FAILURE;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; if (rv == null) &rv = unregister(result);
if (need_register) <idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value == null) return; &if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (need_register) &idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; <<else getRegistry().remove(new IDKey(value));
if (*value == '0' ||!getRegistry().containsKey(value)) &return; &getRegistry().remove(value);
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) ret = ret;
if (! aDirty) <return; if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aDirty) &return; &if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (value == null) &return; &if (! getRegistry()) <nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) <if (!isSupported()) <return NS_ERROR_UNEXPECTED; <return NS_OK;
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (!(value = getRegistry())) <return; if (value == 0) &return; if (value == 0) if (value == -1) return;
if (!(value = getRegistry())) &return; &if (value == 0) <return; if (value == 0) if (value == -1) return;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if ((entry = getRegistry())) if (!entry.is_entry()) break; else getRegistry().remove(new IDKey(value));
if (!m_get_flags) m_get_flags = 0; &else m_get_flags = 0;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) <return; <if (value == 0) <return; <if (value == 0) if (value == -1) return;
if (value) if (!isSupported()) <return NS_ERROR_UNEXPECTED; <return NS_OK;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
fprintf(stderr, "wrapping registration failedn"); if (! fprintf(stderr, "wrapped registry failed&n");
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) getRegistry().remove(new IDKey(value));
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if ((entry = getRegistry())) if (!entry.is_entry()) &break; <else getRegistry().remove(new IDKey(value));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) &ret = ret;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) printf("Unable to remove registry entryn"); return;
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) <return; &if (value == 0) <return; if (value == 0) if (value == -1) return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((entry = getRegistry())) if (!entry.is_entry()) <break; <else getRegistry().remove(new IDKey(value));
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!m_get_flags) <m_get_flags = 0; else &m_get_flags = 0;
if (! aDirty) return; &if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) <idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!eventType) eventType = ev; &else &eventType = ev;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (!newKey(value)) ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) <ret = ret;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
ret = getRegistry().remove(new IDKey(value)); if (ret) <if (ret == null) </* XXX remove the register */ ret = ret;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (!(value = getRegistry())) return; &if (value == 0) <return; if (value == 0) if (value == -1) return;
if (! aDirty) &return; &if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value == null) &return; &if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!newKey(value)) &ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (!newKey(value)) &ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (value == null) return; &if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) &if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) <ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (need_register) <idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); else <LOG(L_ERR, "removeRegistry: %s", value);
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (!eventType) &eventType = ev; else <eventType = ev;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <printf("Unable to remove registry entry<n"); return;
if (!m_get_flags) <m_get_flags = 0; else <m_get_flags = 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!(value = getRegistry())) return; if (value == 0) return; if (value == 0) if (value == -1) return;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (! aDirty) <return; if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (getRegistry()) <if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (need_register) idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) &ret = ret;
if (!(value = getRegistry())) return; &if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (value == null) return; if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value == null) return; if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!(value = getRegistry())) <return; if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (value == null) &return; <if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; return rv;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (!eventType) <eventType = ev; &else <eventType = ev;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) &nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (value) &retval = new IDKey(value); if (retval == 0) &retval = -1; goto unregister;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
getRegistry().remove(new IDKey(value));
if (!newKey(value)) &ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (mRegistry) <mRegistry.remove(new IDKey(value));
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! getRegistry()) <return; &if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) &ret = ret;
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if ((entry = getRegistry())) if (!entry.is_entry()) &break; &&else getRegistry().remove(new IDKey(value));
if (! getRegistry()) &return; <if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if (getRegistry().remove(new IDKey(value))) &void unregister(value);
if (value) retval = new IDKey(value); if (retval == 0) <retval = -1; goto unregister;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; <if (rv == null) rv = unregister(result);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) <*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (!isDocument) return NS_ERROR_NULL_POINTER; if (!getRegistry()) <getRegistry().remove(new IDKey(value));
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv; if (id) <if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!m_get_flags) &m_get_flags = 0; &else m_get_flags = 0;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) <ret = ret;
if (value == null) return; <if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (need_register) &idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isRegistry) <fprintf(stderr, "unregister: %s<n", __func__); getRegistry().remove(&isRegistry);
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; &else getRegistry().remove(new IDKey(value));
if (*value == '0' ||!getRegistry().containsKey(value)) &return; getRegistry().remove(value);
if (!newKey(value)) ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if ((entry = getRegistry())) if (!entry.is_entry()) &break; else getRegistry().remove(new IDKey(value));
if (! aDirty) &return; <if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!(value = getRegistry())) <return; <if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (value) &getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((entry = getRegistry())) &if (!entry.is_entry()) &break; &else getRegistry().remove(new IDKey(value));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (!newKey(value)) ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (value) <getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) <return; <if (value == 0) return; &if (value == 0) if (value == -1) return;
if (need_register) &idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; <return 0;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!m_get_flags) m_get_flags = 0; else &m_get_flags = 0;
if (!getRegistry()) &return;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); else LOG(L_ERR, "removeRegistry: %s", value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) &ret = ret;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); else <LOG(L_ERR, "removeRegistry: %s", value);
if (!(value = getRegistry())) return; if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aDirty) &return; <if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if (!newKey(value)) <ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (!newKey(value)) ret = NS_OK; delete value; else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) &if (!ret) </* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (!mRegistry) &getRegistry().remove(new IDKey(value));
if (!newKey(value)) ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (value == null) &return; &if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) <return; if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value == null) <return; if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!(value = getRegistry())) return; <if (value == 0) <return; if (value == 0) if (value == -1) return;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); <else <LOG(L_ERR, "removeRegistry: %s", value);
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if (!isDocument) return NS_ERROR_NULL_POINTER; if (!getRegistry()) getRegistry().remove(new IDKey(value));
if (!aRegistry) &NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value == null) return; &if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) <retval = new IDKey(value); if (retval == 0) &retval = -1; goto unregister;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (need_register) <idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); else &LOG(L_ERR, "removeRegistry: %s", value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) <ret = ret;
if (id) &GetRegistry().remove(id);
if (!m_get_flags) &m_get_flags = 0; <else m_get_flags = 0;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) ret = ret;
if (id == null) &id = jd_register(id, value); if (id!= null) id = jd_register(id, value);
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (! aDirty) return; <if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aDirty) &return; &if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) return; &if (value == 0) <return; <if (value == 0) if (value == -1) return;
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); else &LOG(L_ERR, "removeRegistry: %s", value);
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (! aDirty) return; &if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (!eventType) eventType = ev; <else <eventType = ev;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (isRegistry) fprintf(stderr, "unregister: %s&n", __func__); getRegistry().remove(&isRegistry);
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) &*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else <ret = new IDKey(value); if (ret) <ret = ret;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; <<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if ((entry = getRegistry())) if (!entry.is_entry()) <break; &<else getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (need_register) idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; &return 0;
if (!newKey(value)) ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (getRegistry()) <getRegistry().remove(new IDKey(value));
if (! getRegistry()) &return; <if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (value) &if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) ret = ret;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) return NS_ERROR_NULL_POINTER; <if (rv == null) rv = unregister(result);
if (!(value = getRegistry())) return; <if (value == 0) return; if (value == 0) if (value == -1) return;
if (!(value = getRegistry())) &return; <if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (need_register) &idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
fprintf(stderr, "wrapping registration failed<n"); if (! fprintf(stderr, "wrapped registry failed&n");
if (!eventType) eventType = ev; else &eventType = ev;
fprintf(stderr, "wrapping registration failed<n"); if (! fprintf(stderr, "wrapped registry failedn");
if (! aDirty) &return; &if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; <if (!aRegistry) <NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (!(value = getRegistry())) return; <if (value == 0) return; <if (value == 0) if (value == -1) return;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; <else ret.mContent = null; return ret;
if (need_register) &idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (! aDirty) &return; if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; <if (rv == null) <rv = unregister(result);
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) &ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (! aDirty) <return; &if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (!(value = getRegistry())) &return; <if (value == 0) return; if (value == 0) if (value == -1) return;
if (! getRegistry()) &return; <if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if (need_register) &idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) <if (!isSupported()) return NS_ERROR_UNEXPECTED; <return NS_OK;
if ((entry = getRegistry())) <if (!entry.is_entry()) &break; &&else getRegistry().remove(new IDKey(value));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) &ret = ret;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!newKey(value)) <ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (!(value = getRegistry())) return; &if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; return 0;
if (!newKey(value)) <ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) &ret = ret;
if (need_register) idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!(value = getRegistry())) return; <if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (! aDirty) &return; if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) <ret = ret;
if ((entry = getRegistry())) <if (!entry.is_entry()) break; &&else getRegistry().remove(new IDKey(value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!eventType) <eventType = ev; &else eventType = ev;
if (need_register) &idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!m_get_flags) m_get_flags = 0; &else &m_get_flags = 0;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); &else LOG(L_ERR, "removeRegistry: %s", value);
if (value == null) <return; <if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value == null) <return; <if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else <ret = new IDKey(value); if (ret) <ret = ret;
ret = getRegistry().remove(new IDKey(value)); if (ret) if (ret == null) &/* XXX remove the register */ ret = ret;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; <&else ret.mContent = null; return ret;
if (value == null) <return; &if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
if (value == null) <return; if (! getRegistry()) &nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (*value == '&0' ||!getRegistry().containsKey(value)) &return; getRegistry().remove(value);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else &ret = new IDKey(value); if (ret) <ret = ret;
if (value) if (!isSupported()) return NS_ERROR_UNEXPECTED; &return NS_OK;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (mRegistry) &mRegistry.remove(new IDKey(value));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (need_register) idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!eventType) &eventType = ev; &else &eventType = ev;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) if (!ret) &/* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; &else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
nsresult rv; if (id) if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) &ret = ret;
if (!newKey(value)) <ret = NS_OK; delete value; <else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) &nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
NS_ENSURE_ARG_POINTER(value); if (! aKey) aKey.delete(value); NS_RELEASE(value);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) &return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; &if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value == null) &return; <if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (! getRegistry()) return; &if (getCertificateKey(value)) mRegistry.remove(((CertificateKey*)value));
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) *value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!(value = getRegistry())) <return; &if (value == 0) return; <if (value == 0) if (value == -1) return;
if (need_register) <idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!newKey(value)) &ret = NS_OK; delete value; &else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!(value = getRegistry())) <return; &if (value == 0) &return; &if (value == 0) if (value == -1) return;
if (!newKey(value)) &ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &printf("Unable to remove registry entry<n"); return;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) &*value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!newKey(value)) <ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!(value = getRegistry())) &return; if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!aRegistry) NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (value == null) <return; &if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) <return; if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if ((entry = getRegistry())) if (!entry.is_entry()) break; <else getRegistry().remove(new IDKey(value));
if (value == null) return; if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eventType) <eventType = ev; else &eventType = ev;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else ret = new IDKey(value); if (ret) &ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (getRegistry()) &if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!(value = getRegistry())) return; if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (!value) <getRegistry().remove(new IDKey(value));
if (! aDirty) &return; if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; &return rv;
if (value) if (!isSupported()) return NS_ERROR_UNEXPECTED; return NS_OK;
if (!m_get_flags) m_get_flags = 0; &else <m_get_flags = 0;
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &&else ret.mContent = null; return ret;
if (getRegistry()) if (value) &delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (value) if (!isSupported()) &return NS_ERROR_UNEXPECTED; return NS_OK;
if (!aRegistry) <NS_ERROR("Failed to register register"); return NS_OK; if (!aRegistry) &NS_ADDREF(aRegistry); aRegistry.remove(aRegistry);
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; <if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
fprintf(stderr, "wrapping registration failed&n"); if (! fprintf(stderr, "wrapped registry failedn");
NS_ENSURE_ARG_POINTER(value); if (! aKey) <aKey.delete(value); NS_RELEASE(value);
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; return 0;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; &return rv;
if (! aDirty) &return; <if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((ret = getRegistry()) == null) &/* we can't change the registry or rename the Registry */ if (ret) <if (!ret) &/* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
nsresult rv; if (id) if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if ((value!= null) && (value.data.key == NS_ID_NAME)) if (*value.data.key.attributes) *value.key = value; return; <else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else ret = new IDKey(value); if (ret) &ret = ret;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (getRegistry()) <if (NS_SUCCEEDED(&gRegistry.remove(key))) <if (!gRegistry.remove(key)) return 0; <gRegistry.remove(key);
if (! aRegistry) ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; &<else ret.mContent = null; return ret;
if (! aDirty) return; if (value == '<0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (need_register) <idKeys(need_register); else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (need_register) <idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!(value = getRegistry())) <return; if (value == 0) return; &if (value == 0) if (value == -1) return;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (*value == '<0' ||!getRegistry().containsKey(value)) <return; <getRegistry().remove(value);
if (need_register) &idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) ret = ret;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eventType) <eventType = ev; <else &eventType = ev;
if (value == null) &return; <if (! getRegistry()) &nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((entry = getRegistry())) if (!entry.is_entry()) &break; &<else getRegistry().remove(new IDKey(value));
if (!newKey(value)) &ret = NS_OK; delete value; <else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!eventType) <eventType = ev; else <eventType = ev;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!newKey(value)) ret = NS_OK; delete value; <else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (need_register) <idKeys(need_register); &else &/* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((entry = getRegistry())) if (!entry.is_entry()) <break; &else getRegistry().remove(new IDKey(value));
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (! aDirty) return; if (value == '0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if (getRegistry()) if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); &else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) &NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
rv = getRegistry().remove(new IDKey(value)); if (rv == null) <return NS_ERROR_NULL_POINTER; &if (rv == null) &rv = unregister(result);
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; <return rv;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; &&else getRegistry().remove(new IDKey(value));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value) <if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value == null) &return; if (! getRegistry()) <nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) &ret = ret;
if (!newKey(value)) ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if (!m_get_flags) &m_get_flags = 0; else &m_get_flags = 0;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) &rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; &if (rv == null) <rv = unregister(result);
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (need_register) &idKeys(need_register); else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) &ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); else ret = new IDKey(value); if (ret) <ret = ret;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); else &LOG(L_ERR, "removeRegistry: %s", value);
if (!newKey(value)) &ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) <return; <if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (need_register) <idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); &else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if ((entry = getRegistry())) <if (!entry.is_entry()) break; <&else getRegistry().remove(new IDKey(value));
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; <return 0;
if (!m_get_flags) <m_get_flags = 0; &else <m_get_flags = 0;
nsresult rv; if (id) &if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; return rv;
if ((entry = getRegistry())) if (!entry.is_entry()) <break; &&else getRegistry().remove(new IDKey(value));
if (need_register) idKeys(need_register); <else </* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (isRegistry) &fprintf(stderr, "unregister: %s&n", __func__); getRegistry().remove(&isRegistry);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) /* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!newKey(value)) <ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (! aDirty) <return; <if (value == '&0') aDirty = false; if (aDirty!= false) aDirty = true; return;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else &ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) <return; <if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!m_get_flags) &m_get_flags = 0; <else <m_get_flags = 0;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) &return rv; &return rv;
if (! getRegistry()) <return; if (getCertificateKey(value)) &mRegistry.remove(((CertificateKey*)value));
nsresult rv; if (id) if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) <*value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if (need_register) idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (getRegistry().get() == null) getRegistry().remove(new IDKey(value));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) <return rv; <return rv;
nsresult rv; if (id) &if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (need_register) idKeys(need_register); <else &/* The new IDKey key must be changed before */ if (need_register) &/* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; <else getRegistry().remove(new IDKey(value));
if (!m_get_flags) &m_get_flags = 0; <else &m_get_flags = 0;
if (!ioctl) </* * Unregister ioctl in a log entry */ ioctl.octl = null; else ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; else return NS_ERROR_NULL_POINTER;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; <&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (value == null) <return; &if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if ((entry = getRegistry())) &if (!entry.is_entry()) <break; &&else getRegistry().remove(new IDKey(value));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) <return; if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!(value = getRegistry())) <return; &if (value == 0) <return; &if (value == 0) if (value == -1) return;
if (getRegistry()) &if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
NS_ASSERTION(value == null, "not a valid IDKey"); if (!getRegistry()) &nsresult rv; rv = NS_OK; rv = getRegistry().remove(new IDKey(value)); if (NS_FAILED(rv)) <NS_ASSERTION(NS_FAILED(rv), "not a valid IDKey");
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; else getRegistry().remove(new IDKey(value));
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; <&else getRegistry().remove(new IDKey(value));
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); &else &ret = new IDKey(value); if (ret) &ret = ret;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); &else <LOG(L_ERR, "removeRegistry: %s", value);
if (!m_get_flags) m_get_flags = 0; else <m_get_flags = 0;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) delete this; return 0; <return 0;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) <if (!ret) </* If this is the register, we will rename it. */ ret = rv; else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!(value = getRegistry())) <return; <if (value == 0) return; <if (value == 0) if (value == -1) return;
if (!newKey(value)) &ret = NS_OK; delete value; &else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv; if (id) <if (id == 0) <rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if (value == null) return; if (! getRegistry()) nsCOMPtrnsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) &rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) &rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!newKey(value)) ret = NS_OK; delete value; &else ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (!newKey(value)) <ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (need_register) &idKeys(need_register); &else </* The new IDKey key must be changed before */ if (need_register) /* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (getRegistry()) <LOG(L_ERR, "removeRegistry: %s", value); <else &LOG(L_ERR, "removeRegistry: %s", value);
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) return NS_ERROR_NULL_POINTER; &if (!eService) return NS_ERROR_NULL_POINTER; <else return NS_ERROR_NULL_POINTER;
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); <else <nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) return; if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if ((entry = getRegistry())) &if (!entry.is_entry()) break; else getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) return; <if (value == 0) &return; if (value == 0) if (value == -1) return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) &/* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; return 0;
if (!(value = getRegistry())) &return; &if (value == 0) &return; <if (value == 0) if (value == -1) return;
if (!(value = getRegistry())) <return; <if (value == 0) return; if (value == 0) if (value == -1) return;
if (need_register) idKeys(need_register); <else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!(value = getRegistry())) &return; &if (value == 0) return; <if (value == 0) if (value == -1) return;
if (!isDocument) return NS_ERROR_NULL_POINTER; if (!getRegistry()) &getRegistry().remove(new IDKey(value));
if (!(value = getRegistry())) <return; &if (value == 0) return; if (value == 0) if (value == -1) return;
if (! getRegistry()) <return; &if (getCertificateKey(value)) <mRegistry.remove(((CertificateKey*)value));
if (!m_get_flags) m_get_flags = 0; else m_get_flags = 0;
if (value) <if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!(value = getRegistry())) return; if (value == 0) return; <if (value == 0) if (value == -1) return;
if ((value!= null) && (value.data.key == NS_ID_NAME)) &if (*value.data.key.attributes) *value.key = value; return; &<else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (getRegistry()) if (NS_SUCCEEDED(&gRegistry.remove(key))) if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (value) <if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv; if (id) &if (id == 0) &rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; <return rv;
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); <else <LOG(L_ERR, "removeRegistry: %s", value);
if (getRegistry()) &LOG(L_ERR, "removeRegistry: %s", value); <else LOG(L_ERR, "removeRegistry: %s", value);
if (! aDirty) <return; <if (value == '0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
nsresult rv; if (id) <if (id == 0) rv = IdNumKeys(&id); if (NS_FAILED(rv)) return rv; return rv;
if (!eventType) &eventType = ev; <else <eventType = ev;
if (! aDirty) <return; <if (value == '<0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (value) if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (value) &if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) &delete value; return (0); &else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
nsresult rv = getRegistry(); if (NS_FAILED(rv)) return rv; if (null == rv) <rv = NS_ERROR_OUT_OF_MEMORY; if (rv == 0) <rv = NS_ERROR_OUT_OF_MEMORY; &if (rv == 0) <rv = NS_ERROR_INVALID_ARG; rv = NS_ERROR_OUT_OF_MEMORY; else rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY; rv = NS_ERROR_OUT_OF_MEMORY;
if (value) &if (type!= TYPE_CAST) if (value.__dp == __DPRINTF) <delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) <ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else &ret = new IDKey(value); if (ret) &ret = ret;
rv = getRegistry().remove(new IDKey(value)); if (rv == null) &return NS_ERROR_NULL_POINTER; &if (rv == null) &rv = unregister(result);
if (value == null) &return; if (! getRegistry()) &nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!newKey(value)) &ret = NS_OK; delete value; else <ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) ret = NS_ERROR_NOT_INITIALIZED;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; else ret.mContent = null; return ret;
if ((entry = getRegistry())) <if (!entry.is_entry()) <break; <&else getRegistry().remove(new IDKey(value));
if (value == null) &return; <if (! getRegistry()) nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) &if (NS_SUCCEEDED(&gRegistry.remove(key))) &if (!gRegistry.remove(key)) return 0; &gRegistry.remove(key);
if (isOpen()) /* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) <delete this; return 0; &return 0;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (! aRegistry) &ret = new Object[MAX_ID]; if (ret) ret.mDirty = false; ret.mContent = null; <<else ret.mContent = null; return ret;
if (! aDirty) &return; <if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (isOpen()) </* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) /* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!(value = getRegistry())) &return; &if (value == 0) <return; &if (value == 0) if (value == -1) return;
getRegistry().remove(new IDKey(value));
if (value) if (type!= TYPE_CAST) <if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (! aDirty) &return; if (value == '&0') <aDirty = false; if (aDirty!= false) aDirty = true; return;
if (! aRegistry) <ret = new Object[MAX_ID]; if (ret) <ret.mDirty = false; ret.mContent = null; &else ret.mContent = null; return ret;
if (value == null) <return; if (! getRegistry()) nsCOMPtr&nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (getRegistry()) <if (value) delete nsGenericHostAddress(&key.lssHostAddress, value); else nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (! aDirty) &return; <if (value == '0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
/* * This registers a new value, but * that's not the default. */ if (!getRegistry()) ret = getRegistry(); if (NS_FAILED(ret)) return ret; ret = getRegistry(); <else <ret = new IDKey(value); if (ret) <ret = ret;
if (!getRegistry()) <mRegistry.remove(new IDKey(value));
if (!newKey(value)) &ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) &ret = NS_ERROR_NOT_INITIALIZED;
if (getRegistry()) if (value) <delete nsGenericHostAddress(&key.lssHostAddress, value); <else &nsGenericHostAddress *addr = (nsGenericHostAddress *) &key.lssHostAddress; getRegistry().remove(new IDKey(key.lssHostAddress));
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; <else ioctl.octl = null; &if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (! aDirty) <return; &if (value == '<0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (id == null) <id = jd_register(id, value); if (id!= null) id = jd_register(id, value);
if ((ret = getRegistry()) == null) </* we can't change the registry or rename the Registry */ if (ret) if (!ret) </* If this is the register, we will rename it. */ ret = rv; &else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!newKey(value)) &ret = NS_OK; delete value; else &ret = new IDKey(value); if (ret == NS_ERROR_UNEXPECTED) <ret = NS_ERROR_NOT_INITIALIZED;
if (need_register) <idKeys(need_register); &else /* The new IDKey key must be changed before */ if (need_register) </* The new IDKey should be stored in the registry */ idKeys.RemoveElement(idKeys); if (need_register) /* The register has changed from the object to the table. */ idKeys.RemoveElement(idKeys);
if (!ioctl) &/* * Unregister ioctl in a log entry */ ioctl.octl = null; &else &ioctl.octl = null; <if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (value == null) &return; <if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (!eService) return NS_ERROR_NULL_POINTER; if (!eService) &return NS_ERROR_NULL_POINTER; <if (!eService) <return NS_ERROR_NULL_POINTER; &else return NS_ERROR_NULL_POINTER;
if (! aDirty) return; &if (value == '&0') &aDirty = false; if (aDirty!= false) aDirty = true; return;
if (isOpen()) &/* Remove the _registered entry for the _registered entry. */ if (type!= LOG_CRITICAL) </* Remove the _registered entry. */ if (!isOpen()) &delete this; return 0; &return 0;
if (value == null) &return; if (! getRegistry()) <nsCOMPtr<nsIDocument> document; getRegistry().GetDocument(getter_AddRefs(document)); if (document) nsCOMPtrnsIDocument> doc; document.GetDocument(getter_AddRefs(doc)); if (doc) doc.GetDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc)); doc.RemoveDocument(getter_AddRefs(doc));
if (value) if (type!= TYPE_CAST) &if (value.__dp == __DPRINTF) delete value; return (0); <else if (type == TYPE_CAST) if (type == TYPE_CAST) /* * This will be a 'C' field in the registry register. */ if (type == TYPE_CONTENT) if (! rename) return -1; if (type == TYPE_PROGRAM) /* * If this is a * type, we must be in the registry register. */ rename = TYPE_CONTENT_PROGRAM; else rename = TYPE_CONTENT_PROGRAM;
if (!eventType) &eventType = ev; else eventType = ev;
if ((value!= null) && (value.data.key == NS_ID_NAME)) <if (*value.data.key.attributes) <*value.key = value; return; &&else LOG(L_ERR, "ERROR::removeRegistry(%s)n", value.key); if (!getRegistry()) return; return;
if (!m_get_flags) m_get_flags = 0; <else <m_get_flags = 0;
if ((ret = getRegistry()) == null) /* we can't change the registry or rename the Registry */ if (ret) &if (!ret) /* If this is the register, we will rename it. */ ret = rv; <else if (ret == 0) if (!ret) /* * If we've got a register or rename the registry, we will not be here. */ ret = rv; if (ret == 0) ret = rv; if (ret == 0) ret = rv; ret = ret; if (ret!= 0) /* We can't remove registry if it was in registry's registry. */ ret = ret; ret = re
if (!ioctl) /* * Unregister ioctl in a log entry */ ioctl.octl = null; &else <ioctl.octl = null; if (!ioctl) return ioctl; if (!ioctl.octl) ioctl.octl = null; if (ioctl.octl == 0) return ioctl; else if (ioctl.octl == 0) return ioctl;
if (getRegistry()) LOG(L_ERR, "removeRegistry: %s", value); &else LOG(L_ERR, "removeRegistry: %s", value);
