golden:
return out;
inference:

return (out);
return out;
return NS_OK;
return StringUtils.EMPTY;
return 0;
return result;
return rv;
return null;
return out.get();
return null;
return false;
return ret;
return &out;
return(out);
return -1;
return OUT;
return (innerClassName);
return out + 1;
return className;
return strdup(out);
return true;
return value;
return stringUtils.EMPTY;
return null;
return name;
return OutputString(out);
return *out;
return out;  return 0;
return (innerClassName)out;
return res;
return '0';
return (OUT);
return val;
break;
return lastDotIdx;
return (0);
return in;
return out? 0 : out;
return true;
return out; return 0;
return output;
return out == null;
return numClassNames;
return retval;
return out? 0 : 0;
return out;  return NS_OK;
return kNameSpaceID_None;
return string;
return out; return NS_OK;
return 1;
return (className);
return out.trim();
return this;
goto out;
return out.clone();
return inClassName;
return idx;
return Out;
return!out;
return index;
return out? null : out;
return out; break;
*/ return out;
return out; return null;
return, out;
return numClasses;
return inStr;
return encoding;
return out = null;
return "";
return len;
return className.get();
return out!= null;
return out - 1;
return obj;
return newClassName;
return (innerClassName) out;
return i;
return out == 0;
return out;  return null;
return true;
return out = 0;
return break;
return list;
return (int)out;
return (*out);
returnOUT;
return type;
return code;
return Output;
ret = out; return ret;
return it;
return OutOfClassName(out);
return ++out;
return out? 0 : 1;
return new String(out);
return s;
return data;
return out.ToNewCString();
return xstrdup(out);
goto done;
return out; #endif
return (className)out;
return out; */
return EMPTYSTRING(out);
return nsAutoString(out);
return;
return buf;
return tmp;
return Output(out);
return v;
return rval;
return (inner)out;
return (String)out;
return mClassName;
return out!= 0;
return innerIdx;
return OUT_OF_STRING;
return super.getShortClassName(out);
return OUT_OF_MEMORY;
return (String) out;
return (int) out;
return stringName;
return EMPTY;
return EINVAL;
return OutputStream(out);
return out;  return -1;
return theClassName;
return lastDotIdx + 1;
return innerClassName;
return stringUtils;
return [];
return input;
return aClassName;
return out = false;
return out2;
return new String;
return OutOfClass(out);
return r;
goto cleanup;
return sizeof(out);
return atexit;
return d;
return (ret);
return (Out);
return (innerIdx);
return StringUtils.OK;
#endif return out;
return StringUtils;
return eOut;
return StringUtils.encode(out);
return status;
return getClassName(className);
return (inner) out;
return out? -1 : 0;
return ex;
return (className) out;
return l;
return count;
return out == -1;
ret = out;
return out? out : null;
return out? out : 0;
return PACKAGE_SUCCESS;
return out!= -1)
return StringUtils.false;
return out.strip();
return out  0;
return newString;
return out || out;
result = out; return result;
return id;
else  return out;
return aString;
continue;
return StringUtils.Empty;
return inst;
return out, out;
return out!= -1;
return OutputClassName(out);
return out? 0 : -1;
return (short)out;
return out;  else return null;
return out;  break;
return out? "" : "";
return out? -1 : -1;
return out;  return in;
return
return cstrlen(out);
return (innerClassName == null);
return StringUtils.ENOTDIR;
return out? NS_OK : NS_ERROR_OUT_OF_MEMORY;
return out.replaceAll(CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return out;  else  out = className.substring(lastDotIdx + 1); if (innerIdx!= -1)  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return nsCRT::strdup(out);
else  return OUT;
return out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
else  return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;
if (!out)  return NS_ERROR_FAILURE;  return out;
return nsDependentCString(out);
return out;  return '0';
if (innerIdx == -1)  if (className.length() == 0)  return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;  return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1))  out = out; return NS_OK;  return NS_OK;
return in_short;
return (innerIdx == -1? 0 : lastDotIdx + 1);
/** If we can't just use a string of " ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".. ".
return out? nsClassName::GetClassName(className) : nsClassName(className));
if (out!= null)  return StringUtils.EMPTY;  if (out)  return StringUtils.EMPTY;  if (out.length() == 0)  return StringUtils.EMPTY;
return (Out_Of_Class)out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1))  /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1)))  /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1)  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);   else  out =
return out? OUT_OF_STRING : null;
return out? false : false;
return out;  else  if (className.length() == 0)  /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1)  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);  return 0;  return 1;
/* * XXX avoid class not being built by a char */
return inline;
return out? nsCRT::strdup(out) : '0';
if (out == -1)  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);  return -1;
else  if (className.length() == 0)  return StringUtils.EMPTY;  else  if (className.length() == 0)  return StringUtils.EMPTY;   return StringUtils.EMPTY;   else  if (className.length() == 0)  return StringUtils.EMPTY;  return StringUtils.EMPTY;  return StringUtils.EMPTY;  return StringUtils.EMPTY;
else  /* * This means the object is only a parent object. */ if (className == '0')  /* * We can use this class name to escape the class value. */ if (className == '0')  /* * The class is not an internal class, because * we may not have the object to return to the class value. */  if (className == '0')  /* * The class name is null */ return StringUtils.EMPTY;   /* * Invalid class name. */ return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;  if (className.length() == 0)  return StringUtils.EMPTY;  return StringUtils.EMPTY;
return out;  return nsClassName::evalString(className);
if (innerIdx = -1) return out; else return out;
return out;  return (OUT_CLASS_SEPARATOR_CHAR)(out);
return (innerIdx + 1)? out : out;
return mObject.get();
return OutOfFileString(out);
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY;  if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY;  return StringUtils.EMPTY;
return out;  else  if (out == '0')  /* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1)  if (innerIdx!= -1)  out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);  else  out = StringUtils.EMPTY;  return out;
if (strcmp(out, "*") == 0) return EIF_ENCODING; else return EIF_ENCODING;
return out.replaceAll(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return out? -1 : out;
return ioctl(out);
return out? nsCRT::short(out) : 0;
if (className.length() == 0)  return StringUtils.EMPTY;  return StringUtils.EMPTY;
if (out)  aString.Assign(out);  else  aString.Assign(out);  return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end()  0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0)  if (className.end() > 0)  if (!(className.end() > 0)) return -1;   else  if (className.end()!= 0)  return -1;  if (className.end() > 0)  return -1;   if (className.end()!= 0)  return -1;   return -1;
return inString;
return out;  else  return null;
return ssh;

/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out!= null) <return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; return null;
<else /* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (out == '0') /* XXX */
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
&else </* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else <if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) aString.Assign(out); &else <aString.Assign(out); &return 0;
return out; &return '<0';
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out) &aString.Assign(out); <else &aString.Assign(out); <return 0;
return out; <return (OUT_CLASS_SEPARATOR_CHAR)(out);
<&return out;
return out; else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
return out; else <if (out == '&0') &/* XXX */
<else &/* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out == -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &return -1;
return out; <else &if (out == '&0') </* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
<else /* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
else &/* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else <return null;
return out; break;
return out; <else <if (out == '<0') </* XXX */
return out; &else &if (out == '&0') &/* XXX */
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) &return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
<else return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); else <aString.Assign(out); return 0;
else &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) aString.Assign(out); else aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out) aString.Assign(out); &else &aString.Assign(out); <return 0;
&else &/* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return out; &else if (out == '0') /* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
if (out) &aString.Assign(out); <else <aString.Assign(out); &return 0;
<else <if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &return in;
&else &if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
return out; else &if (out == '&0') </* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if (out!= null) &return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<else &if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
else </* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else <return out;
<else <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
<else /* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else &/* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (out == '<0') &/* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
if (out) <aString.Assign(out); <else <aString.Assign(out); &return 0;
else return OUT;
else <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out) &aString.Assign(out); else <aString.Assign(out); &return 0;
if (!out) <return NS_ERROR_FAILURE; &return out;
return out; &else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) <return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
else </* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
return out; else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else <if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) &out = out; return NS_OK; return NS_OK;
return out; <else &if (out == '&0') &/* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&&return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; &return (OUT_CLASS_SEPARATOR_CHAR)(out);
return out? nsCRT::strdup(out) : '&0';
return out; <else if (out == '&0') </* XXX */
&else return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
return out; <return 0;
return out; <return null;
if (!out) &return NS_ERROR_FAILURE; <return out;
&else if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<else if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else &if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else aString.Assign(out); <return 0;
<else return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) out = out; return NS_OK; <return NS_OK;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
return out; else if (out == '&0') &/* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out == -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return -1;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (out == '&0') /* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out) aString.Assign(out); else aString.Assign(out); <return 0;
return out; else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<else /* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (out == '<0') </* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out) <aString.Assign(out); <else aString.Assign(out); &return 0;
&<return out;
return out; else if (out == '&0') </* XXX */
return out; else if (out == '0') /* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
return '<0';
if (out!= null) <return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
&else return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else <if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else /* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (out == -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <return -1;
if (out!= null) &return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
else if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else /* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&return out;
return out; &else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else &/* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return '&0';
<else </* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; return in;
if (out == -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <return -1;
if (out!= null) <return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (out) aString.Assign(out); else &aString.Assign(out); &return 0;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (out!= null) return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
<else &/* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
&else return out;
&else </* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<else &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
&else &return OUT;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
<else <if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
<return out; return nsClassName::evalString(className);
return out; else <if (out == '<0') /* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else <if (out == '<0') &/* XXX */
return out; &else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else &return out;
<else if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else &if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
else if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <return NS_OK;
return out; return NS_OK;
<else if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out) &aString.Assign(out); &else <aString.Assign(out); &return 0;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
return out; <else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
else <return OUT;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out) aString.Assign(out); &else <aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; <else if (out == '<0') &/* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out) &aString.Assign(out); else aString.Assign(out); <return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) &return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; &else if (out == '0') </* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
else &if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else &/* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return out; <return nsClassName::evalString(className);
return out; <else <if (out == '0') &/* XXX */
if (out) &aString.Assign(out); &else &aString.Assign(out); &return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &return NS_OK;
if (className.length() == 0) return StringUtils.EMPTY; <return StringUtils.EMPTY;
<else &if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); else &aString.Assign(out); return 0;
if (out) &aString.Assign(out); else &aString.Assign(out); &return 0;
return out; &else <if (out == '0') &/* XXX */
if (out) &aString.Assign(out); &else &aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) &return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
if (out!= null) &return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <return '<0';
if (out!= null) return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
else </* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); <else <aString.Assign(out); return 0;
return out; else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else if (out == '&0') /* XXX */
else &return out;
return out? nsCRT::strdup(out) : '<0';
&else &if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else /* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) &return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
&else <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; &else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if ((innerIdx!= -1) && (innerIdx!= -1)) <out = out; return NS_OK; &return NS_OK;
return out; <else <if (out == '0') /* XXX */
return out; &else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if (out) <aString.Assign(out); else aString.Assign(out); return 0;
if (className.length() == 0) <return StringUtils.EMPTY; return StringUtils.EMPTY;
&else </* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (!out) &return NS_ERROR_FAILURE; &return out;
else <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
return out; else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
return out; <else if (out == '<0') /* XXX */
return out; <else <if (out == '<0') /* XXX */
return out; else return null;
else </* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else <aString.Assign(out); return 0;
if (out) &aString.Assign(out); <else <aString.Assign(out); <return 0;
if (out == -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &return -1;
return out; else if (out == '<0') /* XXX */
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else &aString.Assign(out); &return 0;
return out; <return in;
else /* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; <else <if (out == '&0') /* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&return out;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<return out; &return nsClassName::evalString(className);
if (out!= null) &return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
&return out; <return nsClassName::evalString(className);
if (out) aString.Assign(out); <else <aString.Assign(out); &return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; else &if (out == '0') </* XXX */
&else &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; <return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
<else </* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; return '&0';
return out; <else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out!= null) &return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; &else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
<else &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&else &if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
<else <if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return OUT;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (!out) <return NS_ERROR_FAILURE; <return out;
if (out!= null) return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
else return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&return out; &return nsClassName::evalString(className);
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
&else &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
if (out) aString.Assign(out); <else <aString.Assign(out); <return 0;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else /* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else &/* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <if (out == '&0') </* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
else if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
<else </* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <return '&0';
<else &return OUT;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
&else <if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else <if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else /* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else </* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
return out; &else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out!= null) <return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<return out; <return nsClassName::evalString(className);
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (!out) return NS_ERROR_FAILURE; &return out;
&else &/* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if (out!= null) &return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out) aString.Assign(out); <else aString.Assign(out); <return 0;
return out; else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out 0;
if (out!= null) return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
&else &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else <if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else /* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
<else &if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) <out = out; return NS_OK; return NS_OK;
if (out) aString.Assign(out); &else &aString.Assign(out); return 0;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
else </* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (out == '<0') /* XXX */
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
return out; else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
else &if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if (out) aString.Assign(out); <else aString.Assign(out); return 0;
&else return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out) <aString.Assign(out); else &aString.Assign(out); return 0;
return out; <else return null;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
&else if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else </* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; return '0';
if (out!= null) &return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
if (out) &aString.Assign(out); &else aString.Assign(out); <return 0;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out) <aString.Assign(out); <else &aString.Assign(out); &return 0;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&else <if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) aString.Assign(out); else <aString.Assign(out); <return 0;
&else /* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
<else <if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else &if (out == '<0') </* XXX */
return out; &else if (out == '<0') </* XXX */
return out; <else <if (out == '0') </* XXX */
return out; <else &if (out == '&0') /* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) <return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) out = out; return NS_OK; &return NS_OK;
else /* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else </* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
&else /* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else /* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
<else return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
<else &if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
else /* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); else &aString.Assign(out); &return 0;
return out; <else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
&else <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; &else <if (out == '0') /* XXX */
if (out) &aString.Assign(out); else <aString.Assign(out); <return 0;
return out; &else &if (out == '&0') /* XXX */
return out; else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else </* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <else <if (out == '&0') </* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; <else if (out == '&0') &/* XXX */
if (out!= null) <return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; <else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<else &/* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (out == '0') </* XXX */
return out; <else <if (out == '&0') &/* XXX */
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else &aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; <else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) <return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; &else if (out == '<0') /* XXX */
if (out!= null) return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
&else &if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else return null;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else <return OUT;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
if (out) <aString.Assign(out); else aString.Assign(out); <return 0;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out? nsCRT::strdup(out) : '0';
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if (out) <aString.Assign(out); &else aString.Assign(out); &return 0;
&else &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else <if (out == '&0') /* XXX */
return out; <else <if (out == '<0') &/* XXX */
&else <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
else <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else <if (out == '<0') &/* XXX */
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
if (out!= null) <return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; &else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
return out; &else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<else <if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
<else /* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else /* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
if (out) &aString.Assign(out); <else aString.Assign(out); <return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
<else </* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
else return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) aString.Assign(out); &else aString.Assign(out); &return 0;
return out; else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
else return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out == -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return -1;
&else </* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
return out; <else if (out == '0') &/* XXX */
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&else &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; &else <if (out == '<0') </* XXX */
if (out) &aString.Assign(out); &else <aString.Assign(out); <return 0;
&else &/* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else <if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <if (out == '&0') &/* XXX */
return out; &else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
return out; &else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
<else &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; &else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
<else &if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) <return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); <else aString.Assign(out); <return 0;
<else &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
<else <return out;
return out; &else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
return out; &else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out) aString.Assign(out); else <aString.Assign(out); &return 0;
<else &return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
<else &/* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
<else </* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out!= null) return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
return out; &else if (out == '&0') &/* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
return out; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else &if (out == '<0') </* XXX */
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &return null;
else &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out) aString.Assign(out); <else &aString.Assign(out); &return 0;
if (out) aString.Assign(out); <else <aString.Assign(out); return 0;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); else &aString.Assign(out); <return 0;
<else <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
return out; <else if (out == '0') </* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
<else </* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else if (out == '0') /* XXX */
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
<else &if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) aString.Assign(out); else &aString.Assign(out); <return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else <if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else &/* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
return out; <else &if (out == '0') &/* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
<else <return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; <else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
else <if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out;
<else if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out) <aString.Assign(out); else <aString.Assign(out); &return 0;
if (out) aString.Assign(out); else <aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out) aString.Assign(out); &else aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else <if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else /* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else /* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
return out; else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<else /* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<else <if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx <= -1) return out; else return out;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
return out; &else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &return null;
return out; &else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else &/* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <if (out == '&0') /* XXX */
<else &if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
<else &/* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<return out;
<else if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else &if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (out == '0') &/* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &return 0;
if (out!= null) &return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (out) <aString.Assign(out); else &aString.Assign(out); <return 0;
return out; <else &if (out == '0') /* XXX */
<else </* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else &if (out == '0') /* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
<<return out;
return out; &else if (out == '<0') &/* XXX */
if (out!= null) <return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; <else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return '0';
if (out) aString.Assign(out); else aString.Assign(out); &return 0;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if (out!= null) <return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; &else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) <return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
&else if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); else <aString.Assign(out); return 0;
if (out!= null) return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out) <aString.Assign(out); <else &aString.Assign(out); <return 0;
return out; &return '&0';
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; return (OUT_CLASS_SEPARATOR_CHAR)(out);
return out; &else &if (out == '&0') </* XXX */
return out; &else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out!= null) return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; <else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) aString.Assign(out); <else aString.Assign(out); &return 0;
<else &return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<else <return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<else <if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else <if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else &if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else &/* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) aString.Assign(out); <else &aString.Assign(out); <return 0;
if (out!= null) <return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
else &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else if (out == '<0') &/* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out == -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &return -1;
return out; <else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
return out; &else if (out == '&0') </* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (out!= null) return StringUtils.EMPTY; if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
else &if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else </* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else <if (out == '0') </* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else &out = StringUtils.EMPTY; return out;
&else <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; else <if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<return out;
if ((innerIdx!= -1) && (innerIdx!= -1)) &out = out; return NS_OK; &return NS_OK;
else <if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out) aString.Assign(out); <else &aString.Assign(out); return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
&else &/* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; <else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (className.length() == 0) &return StringUtils.EMPTY; &return StringUtils.EMPTY;
&else &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
if (out) &aString.Assign(out); else aString.Assign(out); &return 0;
else return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; &else if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else /* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return OUT;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (!out) &return NS_ERROR_FAILURE; return out;
if (out!= null) &return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; <else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else &/* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; <return '0';
if (className.length() == 0) &return StringUtils.EMPTY; return StringUtils.EMPTY;
&else /* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (innerIdx = -1) return out; else return out;
else &return OUT;
if (out) &aString.Assign(out); else aString.Assign(out); return 0;
<else &if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); &else <aString.Assign(out); return 0;
else &/* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else <return null;
&else &if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (className.length() == 0) <return StringUtils.EMPTY; <return StringUtils.EMPTY;
if (!out) return NS_ERROR_FAILURE; <return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if (out) &aString.Assign(out); &else aString.Assign(out); &return 0;
if (out == -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <return -1;
if (out!= null) return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
&else &if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else if (out == '0') &/* XXX */
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) return StringUtils.EMPTY; <if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
else </* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) <out = out; return NS_OK; <return NS_OK;
<else if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
&else <if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else &/* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&return out; return nsClassName::evalString(className);
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (out!= null) <return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
return out; <else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (innerIdx == -1) if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) &if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; else if (out == '<0') </* XXX */
<else <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out = StringUtils.EMPTY; return out;
&else &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
else &/* * This means the object is only a parent object. */ if (className == '<0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
return out <0;
else <if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
<else &/* * This means the object is only a parent object. */ if (className == '&0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<else <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
return out; else <if (out == '<0') </* XXX */
return out; <else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
<else <return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out) <aString.Assign(out); &else &aString.Assign(out); <return 0;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else &if (out == '<0') /* XXX */
else return out;
&else <return out;
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
else <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
else /* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
return out; <else if (out == '&0') /* XXX */
if (out) <aString.Assign(out); &else <aString.Assign(out); <return 0;
return out; &else &return null;
if (out == -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return -1;
if (out) &aString.Assign(out); <else &aString.Assign(out); &return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else &if (className.length() == 0) return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; return nsClassName::evalString(className);
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
return out; &else &if (out == '<0') /* XXX */
else if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!out) return NS_ERROR_FAILURE; return out;
if ((innerIdx!= -1) && (innerIdx!= -1)) &out = out; return NS_OK; <return NS_OK;
else &return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
&else if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; else <if (out == '0') &/* XXX */
else </* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (className.length() == 0) return StringUtils.EMPTY; &return StringUtils.EMPTY;
return out; else &if (out == '0') &/* XXX */
if (out!= null) return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
return out; <else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; &else &if (out == '0') </* XXX */
return out; &else &if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
return out; else <if (out == '&0') </* XXX */
return out; else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) <aString.Assign(out); <else <aString.Assign(out); <return 0;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else if (className.length() == 0) <return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
else <if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out &0;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
if (className.length() == 0) <return StringUtils.EMPTY; &return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
return out; &else &if (out == '0') &/* XXX */
else &/* * This means the object is only a parent object. */ if (className == '<0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
else <return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; <else &return null;
&else /* * This means the object is only a parent object. */ if (className == '<0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else <aString.Assign(out); &return 0;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else &if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else <if (className.length() == 0) return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; return '<0';
if (innerIdx == -1) &if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((innerIdx!= -1) && (innerIdx!= -1)) out = out; return NS_OK; return NS_OK;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
&else </* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
<else if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (className.length() == 0) &return StringUtils.EMPTY; <return StringUtils.EMPTY;
if (out) aString.Assign(out); else &aString.Assign(out); return 0;
return out; else <out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out) aString.Assign(out); &else <aString.Assign(out); <return 0;
&else &/* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
return out; <else if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
if (out!= null) &return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; <if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out!= null) <return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
<else if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
else <if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &break;
return out; &else <if (out == '<0') /* XXX */
if (out!= null) <return StringUtils.EMPTY; <if (out) &return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
<else &/* * This means the object is only a parent object. */ if (className == '0') </* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
&else &if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out;
<else &return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&else if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
<else &/* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); else <aString.Assign(out); <return 0;
return out; <else if (className.length() == 0) </* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
if (out!= null) return StringUtils.EMPTY; &if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
return out; &else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) /* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
<else <if (className.length() == 0) return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else <if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if ((out = className.substring(lastDotIdx + 1))!= -1) if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else <out = StringUtils.EMPTY; return out;
return out; &else <if (out == '0') </* XXX */
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
return out; <else &if (className.length() == 0) /* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
&else /* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!out) <return NS_ERROR_FAILURE; return out;
if (innerIdx == -1) <if (className.length() == 0) &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
&else if (className.length() == 0) &return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) <if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else <return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
<else </* * This means the object is only a parent object. */ if (className == '&0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
else return StringUtils.EMPTY; &if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
&else </* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); &else aString.Assign(out); return 0;
return out; else &if (out == '&0') &/* XXX */
if (innerIdx == -1) <if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) <aString.Assign(out); <else <aString.Assign(out); return 0;
if (out) aString.Assign(out); &else aString.Assign(out); <return 0;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else &out = StringUtils.EMPTY; return out;
if (innerIdx == -1) &if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out =
&else <return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
if (out!= null) &return StringUtils.EMPTY; <if (out) return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
<else </* * This means the object is only a parent object. */ if (className == '0') /* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (out) &aString.Assign(out); &else &aString.Assign(out); <return 0;
return out; else <return null;
else /* * This means the object is only a parent object. */ if (className == '&0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; <else &if (out == '0') </* XXX */
else &if (className.length() == 0) <return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else <out = StringUtils.EMPTY; return out;
if (out!= null) <return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if (out) &aString.Assign(out); &else aString.Assign(out); return 0;
if (out) <aString.Assign(out); <else aString.Assign(out); return 0;
else return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
else &if (className.length() == 0) &return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) if (className.end() > 0) if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
else &return StringUtils.EMPTY; &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; &else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
<else &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY;
return out; <break;
<if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; &return StringUtils.EMPTY;
if (innerIdx == -1) if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) /* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; <else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if ((out = className.substring(lastDotIdx + 1))!= -1) <if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else <out = StringUtils.EMPTY; return out;
if (out) &aString.Assign(out); <else &aString.Assign(out); return 0;
return out; <else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
&else <if (className.length() == 0) &return StringUtils.EMPTY; <else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
else &if (className.length() == 0) <return StringUtils.EMPTY; &else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; else if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() 0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (out!= null) &return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out =
if (out!= null) return StringUtils.EMPTY; &if (out) return StringUtils.EMPTY; <if (out.length() == 0) return StringUtils.EMPTY;
if (out) <aString.Assign(out); else aString.Assign(out); &return 0;
else &/* * This means the object is only a parent object. */ if (className == '0') &/* * We can use this class name to escape the class value. */ if (className == '0') /* * The class is not an internal class, because * we may not have the object to return to the class value. */ if (className == '0') /* * The class name is null */ return StringUtils.EMPTY; /* * Invalid class name. */ return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; &return '0';
return out; &else out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) <out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); &else out = StringUtils.EMPTY; return out;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() &0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) <if (!(className.end() > 0)) return -1; else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; if (!(innerIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR)) ||!(innerIdx == -1)) return StringUtils.EMPTY; <return StringUtils.EMPTY;
return out; else &if (className.length() == 0) &/* not passed in */ out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); return 0; return 1;
if (out) &aString.Assign(out); <else aString.Assign(out); &return 0;
if (innerIdx == -1) <if (className.length() == 0) <return StringUtils.EMPTY; <if (className.length() == 0) return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) &if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; else &if (out == '&0') /* XXX */
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) &/* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) </* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
if (innerIdx == -1) &if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) <return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
return out; else &if (out == '<0') </* XXX */
if (out) <aString.Assign(out); <else &aString.Assign(out); return 0;
/* * * Now we have the last character encoding, which can be passed in to the nsIclasses. */ if ((last = out) && (className.len == -1)) </* * In a format that holds the value of a char */ if ((last = out) && ((className.length() == -1))) &/* * Handle array encoding in a const char */ int encoding = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1? 0 : lastDotIdx + 1); if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); else out =
/* XXX: a truncated String is the last attribute in a truncated String. */ if (!(className.length() == 0) && (className.end() <0)) return null; /* XXX: a truncated String is the last value in a truncated String. */ if (className.end()!= 0) <if (className.end() > 0) &if (!(className.end() > 0)) return -1; &else if (className.end()!= 0) return -1; if (className.end() > 0) return -1; if (className.end()!= 0) return -1; return -1;
return out; &return -1;
return out; return 0;
return out; &return nsClassName::evalString(className);
<else <return OUT;
if (out) &aString.Assign(out); <else aString.Assign(out); return 0;
if (out) aString.Assign(out); &else &aString.Assign(out); &return 0;
return out; else <if (out == '0') /* XXX */
return out; <else &if (out == '<0') &/* XXX */
if (out!= null) &return StringUtils.EMPTY; &if (out) <return StringUtils.EMPTY; if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else &out = StringUtils.EMPTY; return out;
if (innerIdx == -1) if (className.length() == 0) return StringUtils.EMPTY; <if (className.length() == 0) &return StringUtils.EMPTY; if (className.length() == 0) return StringUtils.EMPTY; return StringUtils.EMPTY;
if (innerIdx &= -1) return out; else return out;
return out; &else &out = className.substring(lastDotIdx + 1); if (innerIdx!= -1) out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
if (out!= null) &return StringUtils.EMPTY; if (out) &return StringUtils.EMPTY; &if (out.length() == 0) return StringUtils.EMPTY;
if ((out = className.substring(lastDotIdx + 1))!= -1) &if (innerIdx!= -1) &out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); <else out = StringUtils.EMPTY; return out;
return out; &else &if (out == '<0') &/* XXX */
