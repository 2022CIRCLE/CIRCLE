golden:
int indexOfDot = namespace.indexOf('.');
inference:
int indexOfDot = namespace.indexOf('.');
long indexOfDot = namespace.indexOf('.');

int indexOfDot;
int indexOfDot = name.indexOf('.');
int indexOfDot = nameSpace.indexOf('.');
int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.find('.');
int indexOfDot = namespace.indexOf('0');
int indexOfDot = namespace.Length();
int indexOfDot = namespace.IndexOf('.');
int indexOfDot = name.get().indexOf('.');
static int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace;
int indexOfDot = namespace.indexOf('/');
int indexOfDot = namespace.indexOf('.', 1);
int indexOfDot = namespace.get();
int indexOfDot = namespace.indexOf(null);
int index = namespace.indexOf('.');
int indexOfDot = nameSpace.indexOf('.');
int indexOfDot = namespace.indexOf(' ');
int indexOfDot = namespace.indexOf(name);
int indexOfDot = namespace.indexOf( '.' );
int indexOfDot = namespace.startsWith('.');
unsigned int indexOfDot = namespace.indexOf('.');
size_t indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('[');
int indexOfDot = '.';
int indexOfDot=namespace.indexOf('.');
Int indexOfDot = namespace.indexOf('.');
int indexOfDot = name_space.indexOf('.');
int indexOfDot = namespace.Find('.');
unsigned long indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.endsWith('.');
int indexOfDot = 0;
int indexOfDot = namespace[indexOf('.')];
indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('(');
int indexOfDot = namespaceIndexOf('.');
int indexOfDot = namespace.indexOf(u'.');
int indexOfDot = namespace.last();
int indexOfDot = namespace.Empty();
int indexOfDot = namespace.indexOf(name.get());
int indexOfDot = namespace.indexOf('$');
int indexOfDot = namespace.indexOf(".");
int indexOfDot = nameSpace.IndexOf('.');
int indexOfDot = namespace.lastIndexOf('.');
int indexOfDot = namespace_indexOf('.');
u_long indexOfDot = namespace.indexOf('.');
short indexOfDot = namespace.indexOf('.');
int indexOfDot = nameSpace.Length();
int indexOfDot = namespace.indexOf('.'+1);
int indexOfDot = namespace.indexOf('.')-1;
int indexOfDot = namespace.indexOf(',');
int indexOfDot = nameSpaceIndexOf('.');
int indexOfDot = &namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.', name);
char* indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.Equals('.');
int indexOfDot = indexOf('.');
int indexOfDot = path.indexOf('.');
int indexOfDot = nameSpace.indexOf('0');
int indexOfDot = name;
int indexOfDot = namespace.indexOf('.' + 1);
int indexOfDot = namespace.indexOf('.', true);
int indexOfDot = name.get();
int i;
int indexOfDot = namespace.indexOf('=');
int indexOfDot = *namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'+name);
int indexOfDot = namespace.indexOf('.'++);
int indexOfDot = nameSpace;
int indexOfDot = -1;
int indexOfDot = nameSpace.find('.');
int indexOfDot = namespace.indexOf('?');
int indexOfDot = namespace.indexOf(';');
int indexOfDot = nameScope.indexOf('.');
int indexOfDot = namespace.indexOf('-');
int indexOfDot = namespace[0].indexOf('.');
int indexOfDot = namespace.indexOf('_');
int indexOfDot = namePtr.indexOf('.');
IndexOfDot = namespace.indexOf('.');
namespace.indexOf('.');
int indexOfDot = namespace.GetIndexOf('.');
const int indexOfDot = namespace.indexOf('.');
int indexOfDot = const namespace.indexOf('.');
int indexOfDot = namespace.lindexOf('.');
int indexOfDot = namespace.Count();
uint indexOfDot = namespace.indexOf('.');
int indexOfDot = name.indexOf('.');
int indexOfDot = namespace == '.';
int indexOfDot = namespace().indexOf('.');
int indexOfDot; namespace.indexOf('.');
int indexOfDot = namespace.indexOf('n');
int indexOfDot = name);
int indexOfDot = name.find('.');
int indexOfDot = namespace.indexOf('.'); */
int indexOfDot = nameSpace.indexOf('/');
int indexOfDot = namespace.trim();
int indexOfDot = flags.indexOf('.');
int indexOfDot = namespace.indexOf(':');
int indexOfDot = namespace.eInt();
int indexOfDot = namespace.cstr_oneuse();
int indexOfDot = namespace.len();
int indexOfDot = nameSpace.indexOf('.', 1);
int indexOfDot = indexOf(namespace);
int indexOfDot = namespace.indexOf('
int indexOfDot = nameSpace_indexOf('.');
int i = namespace.indexOf('.');
int indexOfDot = namespace::indexOf('.');
int indexOfDot = namespace.indexOf('[.');
int indexOfDot = namespace.eIndexOf('.');
int indexOfDot = namespace[1].indexOf('.');
char *indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.StartWith('.');
int indexOfDot = namespace.indexOf('.' + name);
int indexOfDot = namespace.indexOf(b'.');
int indexOfDot = nameSpace.Find('.');
int indexOfDot = namespace.indexOf('.')+1;
int indexOfDot = namespace.indexOf(namespace);
int indexOfDot = aNamespace.indexOf('.');
int indexOfDot = names.indexOf('.');
int indexOfDot = namespace.size();
int indexOfDot = namespace.IsEmpty();
int indexOfDot = namespace.indexOf('&');
int indexOfDot = nameSpace.indexOf(null);
int indexOfDot = nameSpace.indexOf(' ');
double indexOfDot = namespace.indexOf('.');
int indexOfDot = nameSpace.indexOf( '.' );
int indexOfDot = namespace.indexOf(true);
int indexOfDot = namespace.indexOf('"');
int indexOfDot = namespace.count();
int indexOfDot = namespace.FindChar('.');
int count = namespace.indexOf('.');
int indexOfDot = nameSpace.indexOf(name);
int indexOfDot = nameSpace.indexOf('[');
int indexOfDot = namespace.indexOf('.'|');
int indexOfDot = NameSpace.indexOf('.');
int indexOfDot = namespace.indexOf('+');
int indexOfDot = NS_LITERAL_STRING(namespace);
int indexOfDot = getattr(namespace, '.');
int indexOfDot = namespace.length();
int oldIndexOfDot = namespace.indexOf('.');
int indexOfDot = nodeInfo.indexOf('.');
int indexOfDot = &namespace;
int result = namespace.indexOf('.');
int nameSpaceIndex = namespace.indexOf('.');
int indexOfDot = namespace.ElementAt(index);
JSInt indexOfDot = namespace.indexOf('.');
int indexInDot = namespace.indexOf('.');
int indexOfDot = namespaceRoot.indexOf('.');
int indexOfDot = namespace.rindexOf('.');
int indexOfDot = namespace.indexOf(''');
int *indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf(namespace.get());
int indexOfDot = entry.indexOf('.');
int indexOfDot = name.endsWith('.');
int indexOfDot = '0';
int indexOfDot = result.indexOf('.');
int idx = namespace.indexOf('.');
int indexOfDot = namespace.toLowerCase();
int indexOfDot = namespace);
int indexOfDot = namespace.indexOf('.' );
int indexOfDot = nsDependentString(namespace);
int indexOfDot = strlen(namespace);
int indexOfDot = null;
int indexOfDot = namespace.indexOf('.'-1');
int indexOfDot = namespaceOf('.');
int indexOfDot = *namespace;
int indexOfDot = namespace.indexOf('.', false);
int indexOfDot = len;
int indexOfDot = namespace.indexOf('.') ;
int indexOfDot = rv;
int indexOfDot = namespace.first();
int indexOfDot = name.Length();
int indexOfDot = namespaceIndex;
int indexOfDot = ".";
int indexOfDot = nameSpace.get();
int indexOfDot = namespace[0];
int indexOfDot = 1;
int indexOfDot = namespace.First();
int indexOfDot = nameSpace.last();
int indexOfDot = namespace[1];
int index;
long indexOfDot;
namespace = namespace;
int indexOfDot = namespace.indexOf('.', 0);
int indexOfDot = namespace.indexOf('.', '0');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); /* * This is not really needed here. */
int indexOfDot = namespace.indexOf('.'); if (nameSpace.indexOf('.') == -1)  /* XXX */
int indexOfDot = namespace.indexOf('.'); /* indexOfDot */
int indexOfDot = namespace.indexOf('.'); /* Node 'n'' contains a parent of the parent of the name. */
int indexOfDot = namespace.indexOf('.') - 1;
int indexOfDot = namespace.indexOf('.', nameSpace.indexOf('.'));
int indexOfDot = namespace.indexOf('.' + nameSpace.get());
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0)  return -1;
int indexOfDot = namespace.indexOf('.'); /* Note that the literal literal is the case of a string that has a label of * this '.' */
int indexOfDot = namespace.indexOf('.');  else  if (NS_SUCCEEDED(namespace.get()))  namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.get().indexOf('.');
int indexOfDot = namespace.indexOf('.') + 1;
int indexOfDot = namespace.indexOf('.', '.');
int indexOfDot = namespace.indexOf('.'); /* * If we've already called the '.' function, then * find the reference to the '.' variable. */
int indexOfDot = namespace.indexOf('.' + varNode.getName());
int indexOfDot = namespace.indexOf('.'); /* no references to a var name. */
int indexOfDot = namespace.indexOf('.' + v);
int indexOfDot = namespace.indexOf('.')  0;
int indexOfDot = namespace.indexOf('.'); /* no names in namespace. */
int indexOfDot = namespace.indexOf('.', -1);
int indexOfDot = namespace.indexOf('.' + nameSpace.cstrlen('.'));
int indexOfDot = namespace.indexOf('.')  2;
int indexOfDot = namespace.indexOf('.' + nameSpace.Length());
int indexOfDot = namespace.indexOf('.' + namespace.indexOf('.'));
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1)  break;
int indexOfDot = namespace.indexOf('.'); /* XXX */
int indexOfDot = namespace.indexOf('.', nameSpace.get());
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) return;
int indexOfDot = namespace.indexOf('.', &namespace);
int indexOfDot = namespace.indexOf('.'); /* Node's names in this case */
int indexOfDot = namespace.indexOf('.' + nameSpace.length());
int indexOfDot = namespace.indexOf('.'); if (namespace) namespace = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); if (namespace.indexOf('.') > 0) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.' + namespace);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == 0)  varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChild(nameNode); varNode = new Node(Token.VAR, nameNode); varNode.replaceChildToFront(varNode); varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChildToFront(varNode); varNode.getParent().replaceChildToFront(varNode); varNode.replaceChildToFront(varNode);
int indexOfDot = namespace.indexOf('.', namespace);
int indexOfDot = namespace.indexOf('.' + namespace.get());
int indexOfDot = namespace.indexOf('.') = 0;
int indexOfDot = namespace.indexOf('.', &indexOfDot);
int indexOfDot = namespace.indexOf('.'); /* If we aren't using a structure for this name, we * do not have the name. */
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.' + 0);
int indexOfDot = namespace.indexOf('.'); if (! indexOfDot)
int indexOfDot = namespace.indexOf('.', &name);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '0'; else indexOfDot = '0';
int indexOfDot = namespace.indexOf('.', namespace.get());
int indexOfDot = namespace.indexOf('.' + nameSpace.len());
int indexOfDot = namespace.indexOf('.'); /* inst' is in the '.' option. */
int indexOfDot = namespace.indexOf('.'); if (!indexOfDot) return;
int indexOfDot = namespace.indexOf('.' + nameSpace.indexOf('.'));
int indexOfDot = namespace.indexOf('.', namespace.Length());
int indexOfDot = namespace.indexOf('&.');
int indexOfDot = namespace.indexOf('.'<);
int indexOfDot = namespace.indexOf(&'.'<);
int indexOfDot = namespace.indexOf('.'); /* Node '<n'' contains a parent of the parent of the name. */
int indexOfDot = namespace.indexOf('.'); if (indexOfDot &= 0) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('n');
int indexOfDot = namespace.indexOf('.'); else <if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot <= 0) &return -1;
int indexOfDot = namespace.indexOf(''');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0) &return -1;
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0) return -1;
int indexOfDot = namespace.indexOf('.'); else &if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.', '<0');
int indexOfDot = '0';
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == 0) <varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChild(nameNode); varNode = new Node(Token.VAR, nameNode); varNode.replaceChildToFront(varNode); varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChildToFront(varNode); varNode.getParent().replaceChildToFront(varNode); varNode.replaceChildToFront(varNode);
int indexOfDot = namespace.indexOf(<'.');
int indexOfDot = namespace.indexOf('.') 2;
int indexOfDot = namespace.indexOf('.'); if (nameSpace.indexOf('.') == -1) </* XXX */
int indexOfDot = namespace.indexOf('.') &= 0;
int indexOfDot = namespace.indexOf('.'); else if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot &= 0) <return -1;
int indexOfDot = namespace.indexOf('.') = 0;
int indexOfDot = namespace.indexOf('.'); /* Node 'n'' contains a parent of the parent of the name. */
int indexOfDot = namespace.indexOf('.') <2;
int indexOfDot = namespace.indexOf('&0');
int indexOfDot = namespace.indexOf('.'); &else &if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf(&'.'&);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '0'; else indexOfDot = '<0';
int indexOfDot = namespace.indexOf('.'); if (indexOfDot <= 0) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '0'; else indexOfDot = '0';
int indexOfDot = namespace.indexOf('.'); /* Node '&n'' contains a parent of the parent of the name. */
int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); else if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); <else <if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot &= 0) &return -1;
int indexOfDot = namespace.indexOf('.'); <else &if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) &break;
int indexOfDot = namespace.indexOf('.'); else &if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) break;
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0) indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); &else <if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('0');
int indexOfDot = namespace.indexOf('.'); if (nameSpace.indexOf('.') == -1) &/* XXX */
int indexOfDot = namespace.indexOf('<'');
int indexOfDot = namespace.indexOf('.') <= 0;
int indexOfDot = namespace.indexOf('&'');
int indexOfDot = namespace.indexOf('.'); <else if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); &else if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf(<'.'<);
int indexOfDot = namespace.indexOf('&n');
int indexOfDot = namespace.indexOf('.'); if (nameSpace.indexOf('.') == -1) /* XXX */
int indexOfDot = namespace.indexOf('<n');
int indexOfDot = namespace.indexOf('.', '&0');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '<0'; else indexOfDot = '0';
int indexOfDot = nameSpace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); <else if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot <= 0) return -1;
int indexOfDot = namespace.indexOf('.'&);
int indexOfDot = namespace.indexOf('.') <0;
int indexOfDot = namespace.indexOf('.'); <else &if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf(<'.'&);
int indexOfDot = '<0';
int indexOfDot = namespace.indexOf('<.');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '<0'; else indexOfDot = '<0';
int indexOfDot = namespace.indexOf('.'); <else if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); <else <if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '0'; else indexOfDot = '&0';
int indexOfDot = namespace.indexOf('.'); if (indexOfDot <= 0) <return -1;
int indexOfDot = namespace.indexOf('<0');
int indexOfDot = namespace.indexOf('.'); else &if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); else <if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = nameSpace.indexOf('&0');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '&0'; else indexOfDot = '0';
int indexOfDot = namespace.indexOf('.'); if (indexOfDot &= 0) return -1;
int indexOfDot = namespace.indexOf('.'); <else &if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.') &2;
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '<0'; else indexOfDot = '&0';
int indexOfDot = namespace.indexOf('.');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == 0) varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChild(nameNode); varNode = new Node(Token.VAR, nameNode); varNode.replaceChildToFront(varNode); varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChildToFront(varNode); varNode.getParent().replaceChildToFront(varNode); varNode.replaceChildToFront(varNode);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) <break;
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '&0'; else indexOfDot = '<0';
int indexOfDot = namespace.indexOf('.'); &else &if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); &else if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); &else <if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == -1) indexOfDot = '&0'; else indexOfDot = '&0';
int indexOfDot = namespace.indexOf('.'); else <if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.') 0;
int indexOfDot = namespace.indexOf('.') &0;
int indexOfDot = nameSpace.indexOf('<0');
int indexOfDot = nameSpace.indexOf('0');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot == 0) &varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChild(nameNode); varNode = new Node(Token.VAR, nameNode); varNode.replaceChildToFront(varNode); varNode = new Node(Token.VAR, nameNode); varNode.getParent().replaceChildToFront(varNode); varNode.getParent().replaceChildToFront(varNode); varNode.replaceChildToFront(varNode);
int indexOfDot = '&0';
int indexOfDot = namespace.indexOf('.'); &else if (NS_SUCCEEDED(namespace.get())) <namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); &else &if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.', '0');
int indexOfDot = namespace.indexOf('.'); else if (NS_SUCCEEDED(namespace.get())) &namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); <else <if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); &else <if (NS_SUCCEEDED(namespace.get())) namespace.insertChild(parent, namespace.get(), &replaceChild);
int indexOfDot = namespace.indexOf('.'); if (! indexOfDot)
int indexOfDot = namespace.indexOf(&'.');
int indexOfDot = namespace.indexOf('.'); if (indexOfDot = 0) <return -1;
