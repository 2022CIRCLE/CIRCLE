golden:
type = Object.class;
inference:
type = type;
type = class;

type = Object.class;
type = array.class;
type = T.class;
type = element.getClass();
type = Object;
type = element.class;
type = null;
type = array.getClass();
type = T_class;
type = T_CLASS;
type = Object[];
type = Element.class;
type = object.class;
type = T[0];
class = Object.class;
type = aClass;
type = type.get();
type = getClass();
type=Object.class;
type = aType;
type = T_Class;
type = T;
type = Object[0];
classType = Object.class;
type = struct class;
type = Object.get();
type = null;
type = Object_class;
type = Array.class;
type = TYPE_CLASS;
type = T_Class.class;
typestr = Object.class;
type = Object();
type = Object[type];
type = newArray.getClass();
type = T[type];
type = u.class;
type = Object.class;
type = Object[0].class;
type;
type = class.class;
type = 0;
type = newArray;
type = type = Object.class;
type = T[] class;
type = T[1];
type = obj.class;
type = eClass;
type = Object[1];
type = (T)Object.class;
aType = Object.class;
type = nsClass;
type = tmp;
type = JSObject.class;
type = uncheckedClass;
type = T[];
T type = Object.class;
type = item.class;
type = &type;
type = Object[class];
ntype = Object.class;
type = DOMClass;
type = Object().class;
type = nsObject.class;
type = XP_CLASS;
type = Class;
type = LIST_CLASS;
type = ASSERT_CLASS;
type = T[type].class;
type = ElementType.class;
type = bool_class;
type = t_class;
type = ElementType();
int type = Object.class;
type = GetClass();
type= Object.class;
type = _class;
type = ObjectClass;
type = T[0].class;
type = T[2];
type = Type;
type = array.class;
type = T::class;
type = T.class;
type = classname;
type = numpy.class;
type = v;
type = ElementType;
type = ObjectType;
type = Object.type;
type = String.class;
type = TypeInfo();
type = t.class;
type = void_class;
type = element;
type = elem.class;
type = types.class;
type = eType;
type = type();
type = T_TYPE_CLASS;
type = Object[type].class;
classtype = Object.class;
type = T_Object.class;
type = id;
type = void;
type = Integer.class;
type = T_Class();
type = Class.class;
type = Object[2];
struct type = Object.class;
type = Object::class;
type = array;
type = jclass;
type = XP_class;
type = newArray.class;
type = false;
type = super.class;
type = self.class;
type = *type;
type = ObjectObject.class;
type = instance.class;
type = type.class;
type = struct type;
type = M_CLASS;
type = atom_class;
type = ObjectType.class;
type = Object.getClass();
type = EIF_CLASS;
type = bool;
type = T();
type = iClass;
type = nump;
type = Object[class].class;
type = '0';
type = class();
type = aType.class;
type = DOM_class;
type = uncheckedType;
type = ObjectClass();
type = T[] type;
type = nsClass();
type = mType;
type = array.type;
type = t;
type = Object.Class();
type = Tk();
type = newType;
type = XULClass;
type = T_Element.class;
type = jtype;
type = T[0].class;
type = ElementClass;
type = Object.class();
type = XP_Class;
type = EmptyClass();
type = tkClass;
type = SINGLE_CLASS;
type = XPCClass;
type = (T[])type;
type = T_TYPE;
type = Object.Class;
type = Object[1].class;
type = TYPE_class;
type = NS_CLASS;
type = TYPE_Class;
type = type = Object;
type = Object[Type];
type = EMPTYSTRING;
type = T[].class;
type = T_CLASS_CLASS;
type = obj;
type = numptyClass;
type = UncheckedClass();
type = newArray[type];
type = void* Object;
type = (T[]) type;
type = T[] Object;
type = T[]_class;
type = Object[Type].class;
type = UncheckedClass;
type = T_CLASS_TYPE;
type = EnumerateClass();
type = unchecked;
type = T[]Type;
type = Object.class.class;
type = T[Element];
type = Object.class + 1;
type = PRUint32(0);
type = UncheckedType();
type = TYPE_NONE;
type = Object.class; break;
type = XP_TYPE;
type = nsXULClass;
type = (T[])class;
type = (T[]) Object.class;
type = XPC_Class;
type = XUL;
type = (Type) Object.class;
type = ArrayType;
type = T[class];
type = XPContent.class;
type = (type == Object.class)? (type == Object.class) : null;
type = &object;
type = T_CLASS_REFERENCE;
type = Object.class.get();
type = t_Class;
type = void */
type = nsCRT::class;
type = struct eval;
type = T[] Object.class;
type = void* class;
type = nsAutoClass::class;
type = XP_TYPE_CLASS;
type = e_class;
type = Object[TYPE_CLASS];
type = NS_STATIC_CAST(Object.class, type);
type = struct t_class;
type = DOM_Class;
type = Object.class;  else  type = type;
type = Object[CLASS_INT32_EXT_CLASS];
type = nsDependentCString(Object.class);
type = T[]_Class;
type = (PRUint32)Object.class;
type = NS_STATIC_CAST(Type) Object.class;
type = nsXUL;
type = (T) Object.class;
type = NS_ConvertASCIItoUCS2(Object.class);
type = Tk().class;
type = NS_ClassType;
type = T[]TypeInfo;
type = (ClassType*) Object.class;
type = XPContentUtils.class;
type = (Element) Object.class;
type = Object[sizeof(type)];
type = XPCObject.class;
type = T_Class(array);
type = (Object)class;
type = JSArrayGrow2(array, type);
type = X_Class.class;
type = void* Object.class;
type = struct td.class;
type = tk_class;
type = NS_CLASS_TO_INT32(Object.class);
type = Object[MAX_TYPE];
type = NS_CLASS_ELEMENT_EXT;
type = Object.class;  else  type = (T[]) getT(element);
type = Tk.class;
type = TkType();
type = &Type;
type = Object.class; <else <type = type;
type = Type<;
type = Object.class; else &type = (T[]) getT(element);
type = <Type&;
type = type<;
type = Object.class; &else <type = type;
type = Object.class; <else &type = type;
type = Type;
type = <Type;
type = &Type<;
type = &type&;
type = Object.class; else &type = type;
type = Object.class; &else &type = (T[]) getT(element);
type = Object.class; else type = (T[]) getT(element);
type = Object.class; &else &type = type;
type = &type<;
type = Object.class; <else &type = (T[]) getT(element);
type = Type&;
type = Object.class; <else type = (T[]) getT(element);
type = Object.class; else <type = (T[]) getT(element);
type = Object.class; <else type = type;
type = Object.class; <else <type = (T[]) getT(element);
type = Object.class;
type = Object.class; &else <type = (T[]) getT(element);
type = '0';
type = <type&;
type = type&;
type = '<0';
type = Object.class; &else type = (T[]) getT(element);
type = &type;
type = <Type<;
type = Object.class; &else type = type;
type = Object.class; else <type = type;
type = &Type&;
type = <type;
type = type;
type = Object.class; else type = type;
type = <type<;
type = '&0';
