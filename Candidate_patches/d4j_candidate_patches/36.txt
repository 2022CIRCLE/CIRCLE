golden:
break;
inference:

break;
return x;
return x0;
continue;
return 0;
return x1;
else  break;
goto out;
goto done;
return result;
return (x);
#endif
goto fail;
else
return (0);
return -1;
f0 = 0.5; break;
return rtol;
goto bad;
return 1;
return x2;
break; default: break;
return x-1;
f0 *= 0.5; break;
break; case ILLINOIS:
else break;
goto cleanup;
return null;
return (x0);
f0 = 0; break;
goto ret;
f0 = f1; break;
return true;
return f0;
return false;
break; default:
#endif break;
break; #endif
goto loser;
goto err;
break - 1;
return X;
break ;
return(x);
break; case ILLINOIS: break;
break;  else
return it;
else  return x;
return inverted;
break;  #endif
return (1);
goto end;
f0 = f0; break;
return x0 - x1;
x0 = x1;
return ret;
return;
f0 *= 0.5;
getRelativeAccuracy();
return (x0 == 0.0);
f0 = f1;
case ILLINOIS: break;
return (x0 == 0);
case ILLINOIS:
goto revert;
fx = f0; break;
return n;
inverted = true; break;
return error;
return NS_OK;
inverted = true;
while (true)
return (x0 - x1);
return x;  break;
splx(s); break;
splx(s);
break;  else  break;
return X0;
return (x0, x1);
return x0; break;
break; ;
break;  break;
f0 = 0.5;
goto error;
*/ break;
return (-1);
break;  */
return (x1);
return(0);
return (inverted);
else f0 = 0.5; break;
goto overflow;
return(x0);
if (f0 == 0.0)
inverted = 0; break;
goto exit;
return x; break;
return true;
break
break; */
free(f0);
return x;  else
return x0 - x0;
return atol;
return x1, x2;
break; /* XXX */
return retval;
error = 0; break;
f0 = 1.0; break;
inverted = false;
goto recursive;
f0 = 0;
goto break;
exit(1);
f0 -= 0.5; break;
return 2;
goto delete;
fx = 0; break;
break;  else break;
return count;
return (error);
f0 = x0; break;
inverted = false; break;
if (f0 == 0.0) break;
pass;
return this;
goto skip;
return (x0 - x0);
else  inverted = false;
f0 += 0.5; break;
fail;
return x0 == 0.5;
result = 0; break;
i = 0; break;
return x - x0;
return x0 == 0;
else f0 *= 0.5; break;
errno = 0; break;
return (x0  0);
return x0 == 0.0;
break;  while (true)
f0 |= 0.5; break;
getFunctionValueAccuracy();
else  f0 = 0.5;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0)  return x0;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x0;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x0; if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x0; if (f1 == 0.0)  return x0; if (f1 == 0.0)  return x1;
break; case ILLINOIS: f0 *= 0.5; break;
fx = XF_FALSE; /* * Check the last function object. */ break;
if (equals(f1, f2))  f1 = f1; f2 = f1; f2 = f2;  else  if (f2 == 0)  f1 = f1;  else  f1 = f1;
if (f0 == 0.0)  /* Now we have to use it now. */ break;
else  /* Set to zeroed tmp. */ if (x0 == 0)  return x0;  else  /* Set the tmp tmp. */ if (x1 == 0)  return x1;  else  /* Set the tmp tmp. */  else  /* Set the tmp. */ if (x1 == 0)  return x0;  /* Set the tmp. */  else  return x0;  /* Set the tmp. */  if (x1 == 0)  return x1;  /* Set the tmp. */ if (x0 == 0)  return x0;  /* Set the tmp. */  else  return x0;  /* Set the tmp. */
return x0;  if (f0 == 0.0)  return x0;  if (f1 == 0.0)  return x1;
else  f0 = 0.5; break;
return (x0  x1)? x0 : x1;
else  syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0;   syslog(LOG_ERR, "Waiting for %d", __func__);
f0 = x0;
if (f0 == 0.0)  break;
fx = x0; break;
else  if (f1 == 0.0)
if (f0 == 0.0)  if (f1 == 0.0)  return x0;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;
if (!m_plag) return p;
break; case ILLINOIS: f0 = 0.5; break; case ILLINOIS: f0 = 0.5; break; case ILLINOIS: f0 = 0.5; break;
else  if (f0  0.5)  f0 *= 0.5;  if (f1  f0)  f0 = f1; f1 = f1; f1 = f1;     else  if (f1 == 0.0)  f0 = f0;
if (f0 == 0.0)  f0 = 0.5;
break;  /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0)  if (x0 == 0.0)  return x0;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x0; if (f1 == 0.0)  return x1;  if (f1 == 0.0)  return x1;  if (f2 == 0.0)  return x1; if (f2 == 0.0)  return x2; if (f2 == 0.0)  return x1; if (f2 == 0.0)  return x1; if (f2 == 0.0)
/* Don't give up */
/* Check to see if this is the x1 block */
else  if (f0 == 0.0)  return x0;  if (f1 == 0.0)  return x1;  if (f2 == 0.0)  return x2;   if (f1 == 0.0)  return x1;
else  /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0)  return x0;  if (f1 == 0.0)  return x1;   else  /* * XXX */ if (f1 == 0.0)  return x1;

else <if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) if (f1 == 0.0) &return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else <if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) f1 = f1; else f1 = f1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<return x0;
&#endif
else <if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
<else <if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else <if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
<else if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else &inverted = false;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) f1 = f1; else f1 = f1;
&<else
continue;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) &f1 = f1; else f1 = f1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1;
break; else &break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&continue;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) f1 = f1; else f1 = f1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else </* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else <f0 = 0.5;
else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) if (f1 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<f0 = 0.5; break;
<&else <break;
else <return x;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
break; default:
&return x;
else <if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<continue;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else return x;
&else &if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; #endif
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; <else <break;
if (f0 == 0.0) &f0 = 0.5;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<<else break;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&f0 = 0.5; break;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) &if (f1 == 0.0) <return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; <else break;
f0 = 0; break;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; <;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; &if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1;
break; else <break;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
return x0; <if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break;
<else <if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else <if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<<else &break;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) &f1 = f1; else f1 = f1;
&else if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
else if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<#endif
return (x0 <0);
else &if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x0; &if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1;
<else <break;
&return x0;
&else break;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
<else &if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else &if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1;
<else &if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) f1 = f1; else f1 = f1;
if (f0 == 0.0) if (f1 == 0.0) return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) &return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) <f1 = f1; else f1 = f1;
return x0; if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1;
&else if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<<else <break;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else <break;
if (f0 == 0.0) &if (f1 == 0.0) return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &f0 = 0.5; break;
&while (true)
<else if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else <if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return (x0 <x1)? x0 : x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else <if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1;
break; &while (true)
return x0; &if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1;
else &if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1;
&else &if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) if (f1 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<&else <break;
if (f0 == 0.0) <f0 = 0.5;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) &f1 = f1; else f1 = f1;
&else if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) f1 = f1; else f1 = f1;
&else f0 = 0.5;
<else <if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else <if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else /* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else </* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) <if (f1 == 0.0) return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; else
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else <if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else <if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else <if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &inverted = false;
#endif break;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) f1 = f1; else f1 = f1;
&else return x;
else <if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; &else
else if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) <f1 = f1; else f1 = f1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else &if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else <if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else &if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else
&else /* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else &if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
goto out;
else if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else <inverted = false;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) f1 = f1; else f1 = f1;
f0 = 0.5; break;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1;
<#endif break;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) &f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1;
if (f0 == 0.0)
return x0; &if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
return x0;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<else f0 = 0.5;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break;
&else if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else <inverted = false;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) &f1 = f1; else f1 = f1;
return x0; if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; &else break;
return x0; if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1;
else &f0 = 0.5;
else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&&else if (f1 == 0.0)
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; <else
<else if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else <if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else <f0 = 0.5; break;
break; <break;
break; break;
break; */
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) &f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) &/* Now we have to use it now. */ break;
break; <else break;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) <f1 = f1; else f1 = f1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) f1 = f1; else f1 = f1;
return x0; <if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1;
&<else <break;
&&else &break;
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1;
<else </* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) <if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) &f1 = f1; else f1 = f1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<&else break;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else &if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else <if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else &if (f1 == 0.0)
&else if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x;
<else if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else &if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else </* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else &if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) &f1 = f1; else f1 = f1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) &f1 = f1; else f1 = f1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) f1 = f1; else f1 = f1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1;
&&break;
else if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x; break;
f0 *= 0.5; break;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) &f1 = f1; else f1 = f1;
&else <if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) if (f1 == 0.0) return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) &if (f1 == 0.0) <return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else <if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else &inverted = false;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) <f1 = f1; else f1 = f1;
else &if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
else
if (f0 == 0.0) &if (f1 == 0.0) <return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else <return x;
return x0; <if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) f1 = f1; else f1 = f1;
else <break;
while (true)
&else if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else &if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) &f1 = f1; else f1 = f1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) &if (f1 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) &f1 = f1; else f1 = f1;
else </* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) f1 = f1; else f1 = f1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) &f1 = f1; else f1 = f1;
&&else &if (f1 == 0.0)
return x0; <if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) <if (f1 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1;
if (f0 == 0.0) if (f1 == 0.0) return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) <f1 = f1; else f1 = f1;
else /* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else /* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else if (f1 == 0.0)
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) &return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else &if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else <if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
else &f0 = 0.5; break;
<else inverted = false;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1;
return x0; &if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1;
<else <if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1;
break; <while (true)
<else if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else &if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) f1 = f1; else f1 = f1;
return (x0 x1)? x0 : x1;
<else if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) <break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else </* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else <if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x1;
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0;
<return x;
else &if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x0; if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1;
break; case ILLINOIS:
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; <if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1;
<else <if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) f1 = f1; else f1 = f1;
else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) if (f1 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) f1 = f1; else f1 = f1;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) if (f1 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) <f1 = f1; else f1 = f1;
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
return x0; &if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1;
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; &else break;
else if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) &return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else <if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) &f1 = f1; else f1 = f1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) &f1 = f1; else f1 = f1;
return x0; if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&&else <if (f1 == 0.0)
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&break;
&else f0 = 0.5; break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else &if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else <if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1;
<else /* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) /* Now we have to use it now. */ break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) <f1 = f1; else f1 = f1;
<&else <if (f1 == 0.0)
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) <f1 = f1; else f1 = f1;
return (x0 &0);
<else return x;
&else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else <break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else <if (f1 == 0.0)
<else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else <if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) &f1 = f1; else f1 = f1;
return x0; <if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1;
<else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return (x0 0);
else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x; &break;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&<else &break;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&&else <break;
<&else &break;
if (f0 == 0.0) if (f1 == 0.0) <return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) <f1 = f1; else f1 = f1;
<else if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&else &if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<break;
<else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; <if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else <return x;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<return x0;
<else /* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&<else <if (f1 == 0.0)
return x0; <if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1;
else if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) <f1 = f1; else f1 = f1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) <f1 = f1; else f1 = f1;
return x0; <if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<else &if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<<else <break;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
return x0; if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else <if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else &if (f1 == 0.0)
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) f1 = f1; else f1 = f1;
break; else <break;
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else <f0 = 0.5;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else <return x;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) break;
else &if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else &return x;
return x0; if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1;
<else &break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; <else &break;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else <inverted = false;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1;
<&else break;
&else if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) &f1 = f1; else f1 = f1;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
else &inverted = false;
else if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&&else <break;
return x0; if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) &return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1;
&else &f0 = 0.5;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; &break;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<else &if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else &f0 = 0.5;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else &break;
if (f0 == 0.0) <if (f1 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; ;
&else <inverted = false;
&else &if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
<else &if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else <if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else </* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; <if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1;
&else &if (f1 == 0.0)
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) <f1 = f1; else f1 = f1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) &f1 = f1; else f1 = f1;
else if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else &if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; <*/
else &return x;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
else /* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<else <return x;
else return x;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) <f1 = f1; else f1 = f1;
break; &else <break;
return x0; &if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1;
<&else
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) <f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; &if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else <if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) <if (f1 == 0.0) &return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; while (true)
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&<else &break;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) &f1 = f1; else f1 = f1;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1;
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
f0 *= 0.5; break;
return x0; <if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1;
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else <if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<<else if (f1 == 0.0)
&else <if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; default: break;
&else &return x;
<else <if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else <syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; <if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1;
break; &;
else <if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else <if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) <if (f1 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) <f1 = f1; else f1 = f1;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&<else &if (f1 == 0.0)
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else inverted = false;
<else <if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else &if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else </* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<&else &if (f1 == 0.0)
<<break;
return x0; &if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1;
<else &if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else &if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else &if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&<break;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1;
<&else &break;
if (f0 == 0.0) &if (f1 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) <if (f1 == 0.0) &return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else <if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x0; if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1;
&else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else <if (f0 <0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else &if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1;
return x0; &if (f0 == 0.0) return x0; &if (f1 == 0.0) <return x1;
else &if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) f0 = 0.5;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return 0;
return x0; if (f0 == 0.0) return x0; if (f1 == 0.0) return x1;
else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) &f1 = f1; else f1 = f1;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; else break;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else f0 = 0.5; break;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else &if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; &if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) f1 = f1; else f1 = f1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else &if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) <return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else <inverted = false;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else &if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
<else <if (f1 == 0.0)
&else /* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) <if (f1 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&break;
<&break;
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1;
&else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else <if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
goto done;
<return x;
else &if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) &f1 = f1; else f1 = f1;
break; <else <break;
&else <if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else <break;
&else if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) f1 = f1; else f1 = f1;
else if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else <if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
return x0; <if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
<&break;
&else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) if (f1 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else &if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) &f1 = f1; else f1 = f1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; &*/
else break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; &if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1;
<else &if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
&&break;
<<else
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) <f1 = f1; else f1 = f1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) &if (f1 == 0.0) <return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) <if (f1 == 0.0) &return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else <if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) &f1 = f1; else f1 = f1;
else f0 = 0.5; break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) f1 = f1; else f1 = f1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
break; <#endif
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else break;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) f1 = f1; else f1 = f1;
&&else &break;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) <f1 = f1; else f1 = f1;
&else &if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&<else <break;
else &inverted = false;
else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else f0 = 0.5;
break; else break;
&else <if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&else if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; <if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else &break;
&return x0;
return x0; <if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1;
&<break;
<else return x;
&else <if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) <f1 = f1; else f1 = f1;
else inverted = false;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&<else break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else if (f1 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) if (f1 == 0.0) &return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<<break;
&else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
<continue;
else inverted = false;
if (f0 == 0.0) if (f1 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
f0 = 0.5; break;
&&else break;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else inverted = false;
&else &break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else break;
break; &#endif
<else /* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) <f1 = f1; else f1 = f1;
else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (f0 == 0.0) <if (f1 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
else if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1;
<&else if (f1 == 0.0)
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) <f1 = f1; else f1 = f1;
else &if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&&else break;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&#endif break;
<else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (f0 == 0.0) <if (f1 == 0.0) <return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&<else break;
else syslog(LOG_ERR, "Waiting for %d of approximation: %s&n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else &break;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
return x0; &if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1;
&else break;
<else &return x;
else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
break; &else <break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x; <else
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; <else if (f2 == 0) <f1 = f1; else f1 = f1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else &if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) <f1 = f1; else f1 = f1;
if (f0 == 0.0) &if (f1 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<else if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) &f1 = f1; else f1 = f1;
&else &if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else &if (f2 == 0) f1 = f1; else f1 = f1;
<else &if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else <if (f0 &0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) &break;
if (f0 == 0.0) </* Now we have to use it now. */ break;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else &if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) &if (f1 == 0.0) <return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else return x;
if (f0 == 0.0) <if (f1 == 0.0) return x0; &if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1;
break; &else &break;
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else &break;
<else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else </* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else <if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
return x0; if (f0 == 0.0) &return x0; &if (f1 == 0.0) &return x1;
<else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) &return x0; if (f1 == 0.0) <return x1;
<else <f0 = 0.5;
<<else &if (f1 == 0.0)
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
&else &if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; &else &break;
<else <syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
<else if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else if (f0 &0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
<while (true)
&else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
if (f0 == 0.0) if (f1 == 0.0) return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else &if (f2 == 0) f1 = f1; else f1 = f1;
&else &return x;
&else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) <if (f1 == 0.0) <return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
return x0; <if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1;
<else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<<else <if (f1 == 0.0)
else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else &if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else <if (f0 0.5) <f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x; else
return x;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) &f1 = f1; else f1 = f1;
<else syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
<else if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else /* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
&else <if (f0 <0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (f0 == 0.0) if (f1 == 0.0) &return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else &inverted = false;
&else syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
else <if (f0 0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
&&else
&else inverted = false;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else <f0 = 0.5; break;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else <if (f0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
if (f0 == 0.0) &if (f1 == 0.0) &return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else <if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) &f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
<else </* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&return x;
else &return x;
&<else if (f1 == 0.0)
return x0; &if (f0 == 0.0) return x0; if (f1 == 0.0) <return x1;
&else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&continue;
return (x0 &x1)? x0 : x1;
return x0; <if (f0 == 0.0) return x0; <if (f1 == 0.0) <return x1;
&else if (f1 == 0.0)
else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else if (f0 0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) return x0; if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; /* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) if (x0 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
else /* Set to zeroed tmp. */ if (x0 == 0) return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else &/* Set to zeroed tmp. */ if (x0 == 0) &return x0; else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
<else <if (f0 &0.5) &f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
return x0; <if (f0 == 0.0) <return x0; if (f1 == 0.0) <return x1;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
return x0; if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) <f1 = f1; else f1 = f1;
break; else &break;
<<else &break;
else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; &syslog(LOG_ERR, "Waiting for %d", __func__);
&else <if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
<<else break;
&else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
else <return x;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) <f1 = f1; else f1 = f1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
else </* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (f0 == 0.0) if (f1 == 0.0) <return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else &if (f2 == 0) f1 = f1; else f1 = f1;
&else <f0 = 0.5; break;
<else &if (f0 <0.5) f0 *= 0.5; if (f1 f0) f0 = f1; f1 = f1; f1 = f1; else if (f1 == 0.0) f0 = f0;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) &f1 = f1; else f1 = f1;
&else &f0 = 0.5; break;
&else </* Set to zeroed tmp. */ if (x0 == 0) <return x0; &else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
&else /* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) &return x0; &if (f1 == 0.0) <return x1;
&else <if (f1 == 0.0)
if (f0 == 0.0) <if (f1 == 0.0) return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %s<n", __func__, __func__, __func__); return 0; <syslog(LOG_ERR, "Waiting for %d", __func__);
f0 = f1; break;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; &else <if (f2 == 0) <f1 = f1; else f1 = f1;
if (f0 == 0.0) &if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&f0 *= 0.5; break;
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else if (f2 == 0) f1 = f1; else f1 = f1;
if (f0 == 0.0) if (f1 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) <return x0; &if (f1 == 0.0) return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
break; <else &break;
return x; &else
return x; <break;
&else if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &/* * The old approximation is the exact root, return it. Since this is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; else /* * XXX */ if (f1 == 0.0) return x1;
if (equals(f1, f2)) <f1 = f1; f2 = f1; f2 = f2; &else if (f2 == 0) <f1 = f1; else f1 = f1;
return x0; if (f0 == 0.0) <return x0; if (f1 == 0.0) &return x1;
<else <break;
return x0; <if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1;
if (f0 == 0.0) <if (f1 == 0.0) &return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
&else <inverted = false;
if (f0 == 0.0) <if (f1 == 0.0) return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; case ILLINOIS: f0 *= 0.5; break; case ILLINOIS: f0 = computeObjectiveValue(x0); f1 = computeObjectiveValue(x1); if (f0 == 0.0) &return x0; <if (f1 == 0.0) &return x1; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1;
return x0; &if (f0 == 0.0) return x0; &if (f1 == 0.0) return x1;
if (equals(f1, f2)) f1 = f1; f2 = f1; f2 = f2; <else <if (f2 == 0) <f1 = f1; else f1 = f1;
continue;
if (f0 == 0.0) if (f1 == 0.0) &return x0; <if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
break; </* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) <if (x0 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
<else if (f0 == 0.0) return x0; <if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
&else &if (f0 == 0.0) &return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
else &/* Set to zeroed tmp. */ if (x0 == 0) <return x0; <else /* Set the tmp tmp. */ if (x1 == 0) return x1; else /* Set the tmp tmp. */ else /* Set the tmp. */ if (x1 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */ if (x1 == 0) return x1; /* Set the tmp. */ if (x0 == 0) return x0; /* Set the tmp. */ else return x0; /* Set the tmp. */
if (equals(f1, f2)) &f1 = f1; f2 = f1; f2 = f2; else <if (f2 == 0) f1 = f1; else f1 = f1;
<f0 *= 0.5; break;
<else &syslog(LOG_ERR, "Waiting for %d of approximation: %sn", __func__, __func__, __func__); return 0; syslog(LOG_ERR, "Waiting for %d", __func__);
&else
if (f0 == 0.0) &if (f1 == 0.0) return x0; &if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
#endif
if (f0 == 0.0) <if (f1 == 0.0) &return x0; &if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<break;
break; &/* * If the new approximation is the exact root, return it. Since it is not an under-approximation or an over-approximation, we can return it regardless of the allowed solutions. if (f0 == 0.0) &if (x0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x0; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0) return x2; if (f2 == 0.0) return x1; if (f2 == 0.0) return x1; if (f2 == 0.0)
if (f0 == 0.0) &if (f1 == 0.0) return x0; if (f1 == 0.0) &return x1; if (f1 == 0.0) return x1; if (f1 == 0.0) return x1;
<else &if (f0 == 0.0) <return x0; if (f1 == 0.0) return x1; if (f2 == 0.0) return x2; if (f1 == 0.0) return x1;
return x0; if (f0 == 0.0) return x0; &if (f1 == 0.0) &return x1;
