return iZone.convertLocalToUTC(localInstant);
return (iZone.convertLocalToUTC(localInstant, false));
return iZone.convertUTCToLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, 0);
return 0;
return convertLocalToUTC(localInstant, false);
return localInstant;
return iZone.convertLocalToUTC(localInstant, true);
return iZone.convertLocalToUTC(localInstant, true);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertUTC(localInstant);
return iZone.convertIntToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, 0);
return iZone.convertLocalToUTC(localInstant+1, false);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant + 1, false);
return iZone.getLocalToUTC(localInstant, false);
return iZone.convertUTCToLocal(localInstant, false);
return iZone.convertUnicodeToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, 1);
return iZone.convertUTCToLocal(localInstant);
return iZone.convertLocalToUTC(localInstant.get(), false);
return localInstant = iZone.convertLocalToUTC(localInstant);
return iZone.convertLocalToUTC(localInstant, -1);
return iZone.convertUTC(localInstant, 0);
return iZone.convertLocalToUTC(localInstant + offset, false);

return iZone.convertLocalToUnicode(localInstant, false);
iZone.convertLocalToUTC(localInstant, false); return 0;
return iZone.convertZoneToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, null);
return iZone.convertLocalToUTC(localInstant - 1, false);
return iZone.convertLiteralToUTC(localInstant, false);
return iZone.localToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant + 1);
return iZone.convertUTCToLocalToUTC(localInstant);
return iZone.convertNativeToUTC(localInstant, false);
return iZone.convertUTC(localInstant, false);
return iZone.convertToUTC(localInstant);
return nsCRT::convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false);
return -1;
return iZone.convertLocalToInt(localInstant, false);
return iZone.convertLocalToUTC(localInstant-1, false);
return iZone.convertLocalToUTF16(localInstant, false);
return IZone.convertLocalToUTC(localInstant, false);
return (iZone).convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(iInstant, false);
return iZone.convertLocalToUTC(localInstant, 0, 0);
return!iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, offset);
return iZone.convertLocalToUTF8(localInstant, false);
return iZone.convertStringToUTC(localInstant, false);
return jZone.convertLocalToUTC(localInstant, false);
return iZone.convertULocalToUTC(localInstant, false);
return &iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(int, false);
return iZone.convertLocalToString(localInstant, false);
return iZone.convertLocalToUTC(iZone.get(), false);
return iZone.convertUTC(localInstant, true);
return iZone.convertLocalToUTC(int(localInstant), false);
return iZone.convertLocalToUTC(localInstant, true);
return iZone.convertUTCToUTC(localInstant);
return iZone.resolveLocalToUTC(localInstant, false);
return convLocalToUTC(localInstant, false);
return -iZone.convertLocalToUTC(localInstant, false);
return iZone.convertUTCToLocalToUTC(localInstant, true);
return iZone.convertLocalToUTC(instant, false);
return iZone.convert(localInstant, false);
return iZone.convertLocalToUTC(localInstant, true);
return iZone.findLocalToUTC(localInstant, false);
return result;
return iZone.convertLocalToUTC (localInstant, false);
return iZone.convertLocalToUTC(localInstant+1);
return iZone.convertLocalToUTC(localInstant - 1);
return iZone.unconvertLocalToUTC(localInstant, false);
return iZone.convertUTC(localInstant, true);
return iZone.convertLocalToUTC(localInstant) - 1;
return iZone.convertUTCDoLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant);
return iZone.convertXLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, instant);
return iZone.convertLocalToUTC(iZone, false);
return iZone.convertLS(localInstant, false);
return _iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, null);
return iZone.convertLocalToUTC(localInstant, true);
return iZone.convertTextToUTC(localInstant, false);
return iZone.convertLSIntToUTC(localInstant, false);
return iZone.convertXMLToUTC(localInstant, false);
return iZone.convertLocalToUTC(&localInstant, false);
return iZone.constLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, localInstant);
return iZone.convertToUTC(localInstant, 0);
return 1;
return iZone.reverseLocalToUTC(localInstant, false);
return iZone.convertILocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant - offset, false);
return iZone.convertLocalToUTC(llocalInstant, false);
return ConvertLocalToUTC(localInstant, false);
return iZone.toUTC(localInstant, false);
return iZone.convertFromUTC(localInstant, false);
return iZone.ConvertLocalToUTC(localInstant);
return iZone.strdup(localInstant);
return iZone.convertLocalToLocal(localInstant);
return zone.convertLocalToUTC(localInstant, false);
return iZone.convertNativeLocalToUTC(localInstant, false);
return(iZone.convertLocalToUTC(localInstant, false));
return iZone.convertURIToUTC(localInstant, false);
return iZone.convertUTC(localInstant, false);
return convertUTC(localInstant, false);
return iZone.convertShortToUTC(localInstant, false);
ret = iZone.convertLocalToUTC(localInstant, false);
return izone.convertLocalToUTC(localInstant);
return iZone.intLocalToUTC(localInstant, false);
return iZone.convertUTC(localInstant, false);
return iZone.convertLStringToUTC(localInstant, false);
return convertUTCToUTC(localInstant, false);
return (iZone.convertLocalToUTC(localInstant, false));
iZone.convertLocalToUTC(localInstant, false); return instant;
return iZone.convertUnsignedIntToUTC(localInstant, false);
return iZone.convertTwipsToUTC(localInstant, false);
return iZone.convertFlatStringToUTC(localInstant, false);
return iZone.LocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant++, false);
return iZone.convertLocalToUTC(localInstant[0], false);
return iZone.convertLocalToUTC(localInstant + offset);
return iZone.convertUnsigned32ToUTC(localInstant, false);
return iZone.convertLSInstantToUTC(localInstant, false);
return iZone.convertToUTC(localInstant, false);
return true;
return iZone.convertUTCFlatToUTC(localInstant, false);
return localInstant  0;
return iZone.convertBoolToUTC(localInstant, false);
return iZone.convertToUTC(localInstant, true);
return iZone.convertIZoneToUTC(localInstant, false);
iZone.convertLocalToUTC(localInstant, false); return -1;
return iZone.convertLocalToUtc(localInstant);
return iZone.convertLocalToUTC(localInstant,false);
return iZone.convertLocalToUTC(localInstant, 0, false);
return localInstant == 0;
return iZone.convertUTCToLocaltoUTC(localInstant, false);
return iZone.convertToUTC(localInstant, false);
return iZone.copyLocalToUTC(localInstant, false);
return iZone.convertUtc(localInstant, false);
return iZone.convertInt(localInstant, false);
return iZone.convertUtcToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, "UTC");
return convertToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, offset);
return iZone.convertConvertLocalToUTC(localInstant, false);
return iZone.convertFlushToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, instant);
return iZone.convertLocalToLocal(localInstant, false);
iZone.convertLocalToUTC(localInstant); return 0;
return null;
return localInstant!= 0;
return iZone.convertLocaltoUTC(localInstant);
return iZone.cstrlocalToUTC(localInstant, false);
iZone.convertLocalToUTC(localInstant, false);
return iZone.convertTypeToUTC(localInstant, false);
return iZone.convertUTCToLongToUTC(localInstant, false);
return iZone.convertLocalToUTCD(localInstant, false);
result = iZone.convertLocalToUTC(localInstant, false);
return iZone.convertX(localInstant, false);
return super.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC( localInstant, false );
return iZone.convertLocalToUTC(localInstant, false, 1);
return iZone.convertLocalToUTC(localInstant, true, false);
return ConvertUTCToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant,false);
return iZone.convertLocalToUTC(localInstant, value);
return iZone.copyToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, true, 0);
return convertLocalToUTC(localInstant);
return convertLocalToUTC(localInstant, true);
return iZone.convert(localInstant);
return (iZone.convertLocalToUTC(localInstant, false), 0);
return iZone.convertLocalToUTC(localInstant, &error);
return localInstant, false;
return localInstant + offset;
return iZone.convertLocalToUTC(localInstant, false,0);
return iZone.convertLocalToUTC(localInstant, false - offset);
return localInstant + iZone.convertLocalToUTC(localInstant);
return iZone.convertLocalToUTC(localInstant - offset);
return offset;
return instant;
return iZone.convertLocalToUTC(localInstant, false - 1);
return iZone.convertLocalToUTC(localInstant, (long)0);
return '0';
return iZone.convertLocalToUTC(localInstant, false, -1);
if ((iZone.convertLocalToUTC(localInstant, false))!= null)  iZone.convertLocalToUTC(localInstant, false); return -1;
ret = iZone.convertLocalToUTC(localInstant, false); if (ret)  /* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false);  return ret;
return iZone.convertLocalToUTC(localInstant, false, iZone.getSignedNumber());
return iZone.convertUTC(localInstant, (struct sockaddr *)false);
return iZone.convertLocalToUTC(localInstant, (int) false);
return iZone.convertLocalToUTC(localInstant, (int)false);
if (localInstant)  iZone.convertLocalToUTC(localInstant, false); return 0;  else return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, iZone.T_FIRST());
if (iZone) return iZone.convertLocalToUTC(localInstant, false); return instant - iZone.eInitialized;
return iZone.convertLocalToUTC(localInstant, &flags);
if (iZone.convertLocalToUTC(localInstant, false) == -1)  iZone.convertLocalToUTC(localInstant, false);  return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, (void *)false);
return iZone.convertLocalToUTC(localInstant, (iZone_t *) 0);
if (iTimeField)  if (iTimeField.getOffsetToAdd(instant))  int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset;  else  iZone.convertLocalToUTC(localInstant, false);  return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, &timeInit);
res = iZone.convertLocalToUTC(localInstant, false); if (res) return res; else return res;
res = iZone.convertLocalToUTC(localInstant, false); return res;
iZone.convertLocalToUTC(localInstant); return iZone.convertUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, (ulong) false);
return iZone.convertLocalToUTC(localInstant, &localInstant);
iZone.convertLocalToUTC(localInstant, false); return iZone.findInt(localInstant);
return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, iZone.maxint, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (NS_FAILED(rv)) return rv; if (NS_FAILED(rv)) return rv; /* XXX */ rv = iZone.convertLocalToUTC(localInstant, false); if (NS_FAILED(rv)) return rv; if (NS_FAILED(rv)) return rv; return rv;
iZone.convertLocalToUTC(localInstant, false); return iZone.noRawOffset();
return iZone.convertLocalToUTC(localInstant, false, true);
if ((localInstant = iZone.convertLocalToUTC(localInstant))!= 0) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant  0)  iZone.convertLocalToUTC(localInstant, false); return 0;  else  iZone.convertLocalToUTC(localInstant, false); return 0;
if (!iZone.convertLocalToUTC(localInstant))  return false;  return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant)  if (localInstant.localFloor == 0)  /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false);  else  /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0)  /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false);  else  /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant))  return false;  return false;
return iZone.convertLocalToUTC(localInstant, iZone.LOCAL_USING_ENCODER);
return iZone.convertLocalToUTC(localInstant, iZone.get());
return iZone.convertLocalToUTC(localInstant, (void *)false);
return iZone.convertLocalToUTC(localInstant, true, false);
return iZone.convertLocalToUTC(localInstant, iZone.MAXLENGTH);
if (localInstant) return iZone.convertLocalToUTC(localInstant, false); else return 0;
if (localInstant = 0) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, false, iZone.compareToLocale());
return iZone.convertToUTC(localInstant, (unsigned long)false);
if (localInstant  0)  return localInstant;  return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, (int)false);
if (iZone)  iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false);  else  iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
return iZone.convertLocalToUTC(localInstant, (u_int)false);
/* getOffsetToAdd(instant); */ return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertUTC(localInstant, iZone.dpi.iP_0, false);
return iZone.convertLocalToUTC(localInstant, iZone.LocalAt(iZone.LocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.GetLocalAt(iZone.Get
return iZone.convertUTC(localInstant, -1);
return iZone.convertUTC(localInstant, iZone.null);
rv = iZone.convertLocalToUTC(localInstant, false); return rv;
return iZone.convertLocalToUTC(localInstant, (int)0);
return iZone.convertToUTC(localInstant, false);
return iZone.convertUTCToUTC(localInstant, 0);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv)  printf("Found iZone: could not convert iZone: %dn", rv); goto fail;  return rv;
if (iField.roundFloor(localInstant))  return 0;  return iZone.convertLocalToUTC(localInstant, false);
if (localInstant)  iZone.convertLocalToUTC(localInstant, false); return 0;  else  iZone.convertLocalToUTC(localInstant, false); return 0;
return iZone.convertUTCToUTC(localInstant, true);
iZone.convertLocalToUTC(localInstant, false); return instant - offset;
if (iZone.convertLocalToUTC(localInstant, false))  pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb);  else  pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iZone.convertLocalToUTC(localInstant, false)) return (null); return (iZone.convertLocalToUTC(localInstant, false));
if (!localInstant)  return iZone.convertLocalToUTC(localInstant, false);  else  return iZone.convertLocalToUTC(localInstant, false);
return iZone.convertLocalToUTC(localInstant, getter_Copies(localInstant));
if (!localInstant) return 0; else return iZone.convertLocalToUTC(localInstant, false);
iZone.convertLocalToUTC(localInstant, false); return iZone.getLocalFromUsername(localInstant);
iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant);
if (!iZone.convertLocalToUTC(localInstant)) return false; return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) <return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) return false; return false;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant)) &return false; <return false;
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) &/* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); return ret;
if (!iZone.convertLocalToUTC(localInstant)) <return false; return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) &return false; &return false;
if ((iZone.convertLocalToUTC(localInstant, false))!= null) <iZone.convertLocalToUTC(localInstant, false); return -1;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); &else return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) return false; <return false;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
&return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; &return rv;
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %dn", rv); goto fail; &return rv;
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); else &return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); <else &return iZone.convertLocalToUTC(localInstant, false);
if (iField.roundFloor(localInstant)) return 0; &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!iZone.convertLocalToUTC(localInstant)) <return false; &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) </* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); &return ret;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
return '<0';
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
return iZone.convertLocalToUTC(localInstant, false);
if (!iZone.convertLocalToUTC(localInstant)) return false; <return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; return rv;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); <else return iZone.convertLocalToUTC(localInstant, false);
return '&0';
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false) == -1) &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iField.roundFloor(localInstant)) &return 0; &return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); else <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) </* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); <return ret;
<return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant &0) return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) /* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); return ret;
if (localInstant &= 0) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) &return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) &return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; <return rv;
if (iZone.convertLocalToUTC(localInstant, false) == -1) <iZone.convertLocalToUTC(localInstant, false); &return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) &return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; &return rv;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) </* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); return ret;
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant <0) return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; return rv;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iField.roundFloor(localInstant)) <return 0; <return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
return localInstant &0;
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); <else <return iZone.convertLocalToUTC(localInstant, false);
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; <return rv;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; return rv;
if (localInstant 0) <return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) <return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); &else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); else &return iZone.convertLocalToUTC(localInstant, false);
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) &/* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); <return ret;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant <0) &return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %dn", rv); goto fail; &return rv;
if (iField.roundFloor(localInstant)) return 0; <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); <else &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false) == -1) &iZone.convertLocalToUTC(localInstant, false); <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false) == -1) <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; return rv;
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %dn", rv); goto fail; return rv;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if ((iZone.convertLocalToUTC(localInstant, false))!= null) iZone.convertLocalToUTC(localInstant, false); return -1;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; &return rv;
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; <return rv;
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant 0) <return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; &return rv;
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) &return false; return false;
if (iField.roundFloor(localInstant)) <return 0; return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; <return rv;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant <0) <return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); <else <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false) == -1) iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; <else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false) == -1) iZone.convertLocalToUTC(localInstant, false); <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (localInstant <0) &return localInstant; return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iField.roundFloor(localInstant)) return 0; return iZone.convertLocalToUTC(localInstant, false);
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) <return false; <return false;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; <return rv;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
return localInstant 0;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; <else return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant)) return false; &return false;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iField.roundFloor(localInstant)) &return 0; <return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false) == -1) &iZone.convertLocalToUTC(localInstant, false); &return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); &else <return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); &else &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); &else <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %dn", rv); goto fail; return rv;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone.convertLocalToUTC(localInstant, false) == -1) <iZone.convertLocalToUTC(localInstant, false); <return iZone.convertLocalToUTC(localInstant, false);
if (iField.roundFloor(localInstant)) <return 0; &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) &return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); <else &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant = 0) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) &return iZone.convertLocalToUTC(localInstant, false); &else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
return localInstant <0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false)) pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) /* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); <return ret;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
return '0';
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant, false) == -1) iZone.convertLocalToUTC(localInstant, false); &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); &else &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (!iZone.convertLocalToUTC(localInstant)) &return false; &return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %dn", rv); goto fail; <return rv;
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (!iZone.convertLocalToUTC(localInstant)) &return false; return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; &return rv;
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else &iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!iZone.convertLocalToUTC(localInstant)) &return false; <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; &else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) iZone.convertLocalToUTC(localInstant, false); return 0; &else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (!iZone.convertLocalToUTC(localInstant)) <return false; <return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iField.roundFloor(localInstant)) &return 0; return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; &return rv;
if (localInstant &0) &return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; else return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %dn", rv); goto fail; <return rv;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) /* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); &return ret;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) <return false; return false;
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); &else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (localInstant &0) &iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %dn", rv); goto fail; return rv;
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); else <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) <if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); <else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) iZone.convertLocalToUTC(localInstant, false); return 0; <else &iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (iZone.convertLocalToUTC(localInstant)) <return false; &return false;
if (iZone.convertLocalToUTC(localInstant, false)) <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); <else <pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant 0) &return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); &else <return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) <printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; return rv;
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <= 0) return iZone.convertLocalToUTC(localInstant, false); else return iZone.convertLocalToUTC(localInstant, false);
if (localInstant 0) return localInstant; return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant &0) <return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; &else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) <return localInstant; <return iZone.convertLocalToUTC(localInstant, false);
if (!iZone.convertLocalToUTC(localInstant)) return false; &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; <else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) &if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant 0) &iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if ((iZone.convertLocalToUTC(localInstant, false))!= null) &iZone.convertLocalToUTC(localInstant, false); return -1;
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); &else &return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); <else return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; <else return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d&n", rv); goto fail; <return rv;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %d<n", rv); goto fail; return rv;
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); else &return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; &else &iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant <0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else <iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) <iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (localInstant) &iZone.convertLocalToUTC(localInstant, false); return 0; &else return iZone.convertLocalToUTC(localInstant, false);
if (!localInstant) <return iZone.convertLocalToUTC(localInstant, false); <else <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) &printf("Found iZone: could not convert iZone: %dn", rv); goto fail; <return rv;
if (localInstant &0) <iZone.convertLocalToUTC(localInstant, false); return 0; <else iZone.convertLocalToUTC(localInstant, false); return 0;
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iZone.convertLocalToUTC(localInstant, false)) &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED, "unable to convert %d in %d", localInstant, iZone.convertLocalToUTC(localInstant)); return pcb_start(&pcb); &else &pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); pcb_setError(SEC_ERROR_NOT_IMPLEMENTED); return pcb;
if (localInstant <0) &return localInstant; &return iZone.convertLocalToUTC(localInstant, false);
if (iTimeField) &if (iTimeField.getOffsetToAdd(instant)) &int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; else iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
if (localInstant <0) &iZone.convertLocalToUTC(localInstant, false); return 0; else iZone.convertLocalToUTC(localInstant, false); return 0;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) &/* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else </* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (iZone) <iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (iTimeField) if (iTimeField.getOffsetToAdd(instant)) <int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; &else <iZone.convertLocalToUTC(localInstant, false); return iZone.convertLocalToUTC(localInstant, false);
ret = iZone.convertLocalToUTC(localInstant, false); if (ret) &/* now we're doing the same with the normal return value that is done. */ if (!ret) return iZone.convertLocalToUTC(localInstant, false); &return ret;
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); else &/* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) if (localInstant.localFloor == 0) /* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); <else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
if (localInstant &0) <return localInstant; return iZone.convertLocalToUTC(localInstant, false);
rv = iZone.convertLocalToUTC(localInstant, false); if (rv) printf("Found iZone: could not convert iZone: %dn", rv); goto fail; &return rv;
if (iZone) &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(localInstant, false); <else &iZone.convertLocalToUTC(localInstant, false); return iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone.roundToUTC(iZone), iZone.roundToUTC(iZone), iZ
if (!localInstant) return iZone.convertLocalToUTC(localInstant, false); else <return iZone.convertLocalToUTC(localInstant, false);
/* * Check if the rounding process is a true float (e.g. a * current float is in the current float, which can return a long float. */ if (localInstant) <if (localInstant.localFloor == 0) </* * This function may not be necessary to set the localFloor on the other float. */ iZone.convertLocalToUTC(localInstant, false); &else /* If the value is null, we're trying to revert the value, not really the return value. */ if (localInstant.localFloor == 0) /* The value of the otherfloat is null, so we have to set the localFloor on the other float. */ localInstant = iZone.convertLocalToUTC(localInstant, false); else /* The value of the otherfloat is null, */ localInstant = iZ
