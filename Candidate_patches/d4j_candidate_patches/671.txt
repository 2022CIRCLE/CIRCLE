golden:
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
inference:
return Class.forName(name, false, thread.get().getContextClassLoader());
return Class.forName(name, false);
return Class.forName(name, true, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(className, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, classLoader);
return Class.forName(name, false, Thread.currentThread().classLoader);
return Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread);
return Class.forName(name, false, Thread.currentThread().classLoader);
return Class.forName(name, false, contextClassLoader);
return Class.forName(name, false, Thread.currentThread().contextClassLoader);
return Class.forName(name, false, Thread.currentThread().GetContextClassLoader());
return Class.forName(name, false, ClassLoader);
return Class.forName(name, false, null);
return Class.forName(name, false, GetThread().getContextClassLoader());
return Class.forName(name, false, Class.classLoader);
return Class.forName(name, false, __func__);
return Class.forName(name, 0);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread());
return Class.forName(name, false, Thread.currentThread().get());
return Class.forName(name, false, Thread.currentThread().name);
return Class.forName(name, true, thread.currentThread().getContextClassLoader());
Class.forName(name, false, thread.get().getContextClassLoader());
return Class.forName(name, null, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread.getContextClassLoader());
return Class.forName(name, null, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ContextClassLoader);
return Class.forName(name, false, thread.get().contextClassLoader());
return Class_forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, true, Thread.currentThread().getContextClassLoader());
Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getClassLoader());
return Class.forName(classname, false, Thread.currentThread().getContextClassLoader());
return Class.forName(class, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ContextClassLoader.class);
return Class.forName(name, false, Thread.currentThread().getClassLoader(), null);
return Class.forName(name, false, Thread.currentThread().mClassLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(aName, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread;
return Class.forName(name);
return Class.forName(name, false, threads.get().getContextClassLoader());
return Class.forName(name, false, thread.getContextClassLoader());
return Class.forName(&name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().contextClassLoader);
return Class.forName(name, false, &classLoader);
return Class.forName(*name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, 0);
return Class.forName(name, false, Thread.currentThread().class);
return Class.forName(name, false, threadLoader);

Class.forName(name, true, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ClassLoader.get());
return Class.forName(name, false, context);
return Class.forName(name, true, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, null);
return Class.forName(name, false, GetContextClassLoader());
return Class.forName(name, classLoader);
return Class.forName(name, false, str);
return Class.forName(name, false, thread.mThread().getContextClassLoader());
return forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, -1, Thread.currentThread().getContextClassLoader());
Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread.contextClassLoader);
return Class.forName(name, false, Thread.currentThread().getClassLoader().get());
Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread.classLoader);
return Class.forName(name, false, Thread.currentThread().GetContextClassLoader());
return Class.forName(name, false,Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, getter_AddRefs(thread));
return Class.forName(name, false, thread.get());
return Class.forName(name, false, ThreadManager.currentThread().getContextClassLoader());
return Class.forName(name, false, thread.classLoader);
return Class.forName(name, false, rv);
return Class.forName(className, false, thread.currentThread().getContextClassLoader());
return Class.forName(id, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getName());
return Class.forName(name, false, threadThread.getContextClassLoader());
return Class.forName(name, false, getter_AddRefs(Thread.currentThread()));
return Class.forName(name, false, Threads.currentThread().getContextClassLoader());
return Class.forName(name, false, thread).getContextClassLoader();
return Class.forName(name, false, ClassLoader.class);
return Class.forName(name, false, contextLoader);
return Class.forName( name, false, Thread.currentThread().getContextClassLoader());
Return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, threadManager.getContextClassLoader());
Class.forName(className, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ThreadThread().getContextClassLoader());
return Class.forName(name, false, mClassLoader);
return Class.forName(name, false, cursor);
return Class.forName(name, false, ContextClassLoader.get());
return Class.forName(name, false, Thread.currentThread().GetClassLoader());
return Class.forName(name, false, len);
return Class.forName(name, false, Thread.currentThread().getClassLoader(), 0);
return Class.forName(name, false, getter_AddRefs(classLoader));
return ClassClass.forName(name, false, Thread.currentThread().getContextClassLoader());
Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, true);
return Class.forName(name, false, threads.Thread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread(), &classLoader);
return Class.forName(name, false, Thread.currentThread().mContextClassLoader);
return Class.forName(name, false, Thread.currentThread().eClassLoader);
return Class.forName(name, false, thread.thread().getContextClassLoader());
return Class.forName(name, false, currentThread.getContextClassLoader());
return Class.forName(name, false, streamLoader);
return Class.forName(name, false);
Class.forName(name, false, Thread.currentThread().getContextClassLoader());
Class.forName(name, false, classLoader);
return Class.forName(name, false, std::classLoader);
return Class.forName(name, false, Thread.currentThread().name);
return Class.forName(name, false, td);
return Class.forName(name, false, thread, thread.getContextClassLoader());
return Class.forName(name, false, thread.GetContextClassLoader());
return Class.forName(name, false, thread.GetThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().ContextClassLoader);
Class.forName(name, false, thread.getContextClassLoader());
return Class.forName(name, false, &ClassLoader);
return Class.forName(name, false, tmp);
Class.forName(name, false, Thread.currentThread().classLoader);
Class.forName(name, false, contextClassLoader);
return Class.forName(name, false, Thread.currentThread().findClassLoader());
return Class.forName(name, false, thread.get().classLoader);
return Class.forName(name, false, nsCRT::strlen(name));
return Class.forName(name, false, _classLoader);
return Class.forName(name, false, Thread.currentThread().firstChild);
return Class.forName(name, false, thread.mThread().getContextClassLoader());
return Class.forName(name, false, Thread.Thread().getContextClassLoader());
return rv;
return Class.forName(name, false, desc.getClassLoader());
return Class.forName(name, false, mStreamLoader);
return Class.forName(name, false, ctx.classLoader);
return Class.forName(name, false, threadManager);
return Class.forName(name, false, ctx.getContextClassLoader());
return Class.forName(name, false, Thread.currentThread()).getContextClassLoader();
return Class.forName(name, false, Thread.currentThread().getClassLoader());
Class.forName(name, false); return Class.forName(name, false);
return classLoader;
return Class.forName(name, false, Thread.currentThread().getThreadLoader());
return Class.forName(name, false, nsCRT::strdup(thread));
Class.forName(name, false, Thread.currentThread().GetContextClassLoader());
Class.forName(name, false, Thread.currentThread().classLoader);
return Class.forName(name, false, String.valueOf(classLoader));
Class = Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().ContextClassLoader());
return Class.forName(name, false, Thread.currentThread().ClassLoader);
return Class.forName(name, false, ConstClassLoader());
return Class.forName(name, false, getter_AddRefs(threads));
Class.forName(name, false, Class.classLoader);
Class.forName(name, false, ClassLoader);
return Class.forName(name, false, Thread.currentThread().ContextClassLoader);
return Class.forName(name, false, __FUNCTION__);
result = Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().type);
return Class;
return Class.forName(name, false, Thread.currentThread().this);
return Class.forName(name, false, Class.currentThread().getContextClassLoader());
Class.forName(name, false);
return Class.forName(name, false, Thread.currentThread().name());
return Class.forName(name, false, Thread.currentThread().getParent());
return Class.forName(name, false, thread.get().classLoader());
return Class.forName( name, false, Thread.currentThread().getContextClassLoader() );
return Class.forName(name, false, Thread.currentThread().mThreadLoader);
return Class.forName(name, false, Thread.currentThread().getContext().classLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoaders());
return Class.forName(name, false, TAILQ_FIRST(&classLoader));
return Class.forName(name, false, ContextClassLoader.classLoader);
return Class.forName(name, false, fcnt);
return Class.forName(name, false, Thread.currentThread().clone());
return Class.forName(name, false, Thread.currentThread().getClass());
return Class.forName(name, false, Thread.currentThread().getContext().get());
return Class.forName(name, false, Thread.currentThread().getContext());
return Class.forName(name, false, Thread.currentThread().forName);
return Class.forName(name, false, Thread.currentThread().getContextClass().get());
return Class.forName(name, false, Thread.currentThread().get().classLoader);
return Class.forName(name, false, Thread.currentThread().toNewCString());
return Class.forName(name, false, Thread.currentThread().nsClassLoader());
Class.forName(name, false, Thread.currentThread().contextClassLoader);
return Class.forName(name, false, Thread.currentThread().threadLoader);
class = Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().forName());
return Class.forName(name, false, Thread.currentThread().class.get());
return Class.forName(name, false, Thread.currentThread() == null);
return Class.forName(name, false, Thread.currentThread().toNewClass());
return Class.forName(name, false, Thread.currentThread().getContextClassId());
return Class.forName(name, false, Thread.currentThread().contextClassLoader.get());
return Class.forName(name, false, Thread.currentThread().contextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClass());
return Class.forName(name, false, Thread.currentThread().nodeInfo);
return Class.forName(name, false, Thread.currentThread().getContextOwner());
return Class.forName(name, false, Thread.currentThread().getOwner());
return Class.forName(name, false, strdup(Thread.currentThread()));
Class.forName(name, false, Thread.currentThread().getClassLoader());
return Class.forName(name, false, Thread.currentThread().getCurrentThread());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), 0);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), name);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), (long)Destroy());
if (NS_FAILED(rv)) return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, thread)? Class.forName(name, false, thread.getContextClassLoader()) : Class.forName(name, false, thread);
return Class.forName(name, false, NS_ConvertASCIItoUCS2(Thread.currentThread().getContextClassLoader()));
if (dest.classLoader)  /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader);  else  return Class.forName(name, false, std::classLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), null);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), aClass);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &classLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), aModType);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &ex);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), false);
return Class.forName(name, false, iCX);
if (flags & DEBUG) printf("Class.forName: Class.forName(%s)n", flags); return 0;
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), c);
if (flags & (INTR)) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); return Class.forName(name, false, classLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &ret);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), classLoader);
return Class.forName(name, false, Class.forName(name, false), Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), (void **)&classLoader);
return Class.forName(name, false, threadManager.GetContextClassLoader());
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo;  else  return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), true);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &saveClassLoader);
if (dest)  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());  else  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ftReader);
return Class.forName(name, false, Class.forName(dest, Thread.currentThread()));
return Class.forName(name, false, fd.fd.fd);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), (char*)classLoader);
return Class.forName(name, false, NS_STATIC_CAST(ClassForName*, aClass, &rv));
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &aClass);
return Class.forName(name, false, std::get());
if (name)  if (classLoader) return Class.forName(name, false, ClassLoader);  else  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv)  splx("class %s for name %s", name, false); return rv;  if (rv)  struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv))  return rv;  else  rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv;  return rv;
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), getter_AddRefs(classLoader));
/* * We must always return the result. */ if (name.get() == null)  fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f);  else  fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f);  return Class.forName(name, false, f);
/* XXX */ return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, td.td_class.getContextClassLoader());
return Class.forName(name, false, NS_ConvertASCIItoUCS2(nsXPIDLCString("mkdd"), Thread.currentThread().getContextClassLoader()));
return Class.forName(name, false, dp.dst.contextClassLoader);
return Class.forName(name, false, mThread.mThread.getContextClassLoader());
return Class.forName(name, false, tsc.tsc_thread.getContextClassLoader());
return Class.forName(name, false, fd);
return Class.forName(name, false, _("classLoader"));
if (debugFile)  printf("Class: forNamen");  else  nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name)  nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv))  return rv;   else  if (NS_FAILED(rv))  return rv;    return Class.forName(name, false, stream);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), cnt);
if (!mTrash) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, ftrlen(&src) - 1);
/* * The following is necessary here for our fd. */ if (name!= '0') return NS_OK; if (!name.Length()) return NS_ERROR_NULL_POINTER; else if (name.Length() >= 0) return NS_ERROR_NULL_POINTER; else return Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, false, mThread.getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &name);
if (name == null) return '0'; else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, mStreamSpec.GetContextClassLoader());
return Class.forName(name, false, _("%s"), Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), null);
if (name == null) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
fprintf(stderr, "class %s has no namen", name); return Class.forName(name, false, thread.currentThread().getContextClassLoader(), fprintf);
if (debug)  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* return Class.forName(name, false, Thread.currentThread().getContextClassLoader());*/ return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream);  else  if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns))  mStream = stream.mStream_ns;  return Class.forName(name, false, stream.mStream_ns);
if (name == null)  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());  return 0;
return Class.forName(name, false, thread.Thread.getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &str);
if (!nsCRT::strcasecmp(name, "c").equals(")")) return Class.forName(name, false, thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, thread.currentThread().getContextClassLoader());
if (!IsClassSupported(name)) return NS_OK; return Class.forName(name, false, IsClassSupported(this).getClassLoader());
return Class.forName(name, false, Class.forName(name, false));
if (name) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
return Class.forName(name, false, mFileSpec.getContextClassLoader());
return Class.forName(name, false, mThread.getContextClassLoader());
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), aFileName);
nsCRT::free(name); return Class.forName(name, false, thread.currentThread().getContextClassLoader());
return Class.forName(name, false, Class.ClassLoader);
return Class.forName(name, false, rs);
return Class.forName(name, false, thread, thread.next);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &savedClassLoader);
if (!classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); return NS_OK;
if (name.Equals('.'))  return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get()));  else  return Class.forName(name.get(), false, Class.classLoader.get());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (NS_FAILED(rv)) return rv; return rv;
return Class.forName(name, false, ctlr.ClassLoader);
if (name)  nsCRT::free(name);   else  nsCRT::free(name);  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (classLoader)  return Class.forName(name, false, Thread.currentThread().getContextClassLoader());  else  return Class.forName(name, false, Class.classLoader);
return Class.forName(name, false, Thread.currentThread().getContextClassLoader(), &dest);
if (!(classLoader = Thread.currentThread().getContextClassLoader())) return Class.forName(name, false, classLoader); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex))  if (!ex)  /* * We have to allocate a filename from the server. */ return NS_OK;  if (!ex)  return NS_ERROR_NULL_POINTER;  if (!ex)  return NS_ERROR_NULL_POINTER;  return Class.forName(name, false, classLoader);
if (name) nsCRT::free(name); <&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) nsCRT::free(name); <else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) &printf("Class: forName<n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forNamen"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName<n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name == null) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <return 0;
if (name) &nsCRT::free(name); &else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName&n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) printf("Class: forName&n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) &printf("Class: forNamen"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (flags & DEBUG) printf("Class.forName: Class.forName(%s)&n", flags); return 0;
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else &return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) &printf("Class: forName<n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
fprintf(stderr, "class %s has no name<n", name); return Class.forName(name, false, thread.currentThread().getContextClassLoader(), fprintf);
if (name) nsCRT::free(name); &&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <nsCRT::free(name); <&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Class.classLoader);
if (name) &nsCRT::free(name); &&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else &return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) &printf("Class: forName<n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else <return Class.forName(name, false, std::classLoader);
if (debugFile) &printf("Class: forName&n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) nsCRT::free(name); &<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <nsCRT::free(name); <else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name == null) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); return 0;
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else return Class.forName(name, false, std::classLoader);
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (debugFile) printf("Class: forName<n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forName&n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else <return Class.forName(name.get(), false, Class.classLoader.get());
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Class.classLoader);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) <printf("Class: forName<n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) <printf("Class: forName&n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) <nsCRT::free(name); &else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (flags & DEBUG) printf("Class.forName: Class.forName(%s)<n", flags); return 0;
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) &printf("Class: forName<n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) <nsCRT::free(name); else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forName<n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name == null) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <return 0;
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) &nsCRT::free(name); &&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); <else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) &nsCRT::free(name); else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) &printf("Class: forNamen"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) nsCRT::free(name); &&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else <return Class.forName(name.get(), false, Class.classLoader.get());
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) nsCRT::free(name); <else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else &return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) printf("Class: forName&n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) &printf("Class: forName&n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (debugFile) printf("Class: forName&n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name) nsCRT::free(name); <<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) nsCRT::free(name); &else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else <return Class.forName(name, false, std::classLoader);
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else <return Class.forName(name, false, std::classLoader);
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else &return Class.forName(name, false, std::classLoader);
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) <nsCRT::free(name); &<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debug) return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else <return Class.forName(name.get(), false, Class.classLoader.get());
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) &nsCRT::free(name); &else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Class.classLoader);
if (debugFile) printf("Class: forNamen"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name == null) return '&0'; else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else &return Class.forName(name.get(), false, Class.classLoader.get());
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else &return Class.forName(name.get(), false, Class.classLoader.get());
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Class.classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) <printf("Class: forName<n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (flags & DEBUG) printf("Class.forName: Class.forName(%s)n", flags); return 0;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name == null) return '0'; else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <nsCRT::free(name); else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (name) <nsCRT::free(name); &else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name) <nsCRT::free(name); <&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forNamen"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) &printf("Class: forNamen"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) &nsCRT::free(name); <&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) printf("Class: forName<n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forName<n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (name) &nsCRT::free(name); <<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Class.classLoader);
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else &return Class.forName(name, false, std::classLoader);
if (name) nsCRT::free(name); else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (debugFile) &printf("Class: forName&n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) &nsCRT::free(name); <<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Class.classLoader);
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forNamen"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) printf("Class: forName<n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) <nsCRT::free(name); else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else return Class.forName(name.get(), false, Class.classLoader.get());
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else &return Class.forName(name.get(), false, Class.classLoader.get());
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) <nsCRT::free(name); <<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else return Class.forName(name, false, std::classLoader);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) &nsCRT::free(name); &<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forNamen"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else <return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) printf("Class: forName&n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) nsCRT::free(name); &<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) nsCRT::free(name); <else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) printf("Class: forNamen"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) <nsCRT::free(name); &&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) &printf("Class: forName&n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) nsCRT::free(name); <<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) <nsCRT::free(name); &&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) &nsCRT::free(name); &<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forName<n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Class.classLoader);
if (name) nsCRT::free(name); &else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
fprintf(stderr, "class %s has no namen", name); return Class.forName(name, false, thread.currentThread().getContextClassLoader(), fprintf);
if (debugFile) printf("Class: forNamen"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else &return Class.forName(name, false, std::classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) nsCRT::free(name); &&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forNamen"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) <nsCRT::free(name); &<else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else return Class.forName(name.get(), false, Class.classLoader.get());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else <return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) printf("Class: forName&n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name == null) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); return 0;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); <&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name == null) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); return 0;
if (debugFile) printf("Class: forName&n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Class.classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
/* * The following is necessary here for our fd. */ if (name!= '0') return NS_OK; if (!name.Length()) return NS_ERROR_NULL_POINTER; else if (name.Length() >= 0) return NS_ERROR_NULL_POINTER; else return Class.forName(name, false, thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) <printf("Class: forName&n"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Class.classLoader);
if (debugFile) &printf("Class: forName<n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else &return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Class.classLoader);
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else &return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Class.classLoader);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else &return Class.forName(name.get(), false, Class.classLoader.get());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else <return Class.forName(name.get(), false, Class.classLoader.get());
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else <return Class.forName(name.get(), false, Class.classLoader.get());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) <nsCRT::free(name); <<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else &return Class.forName(name.get(), false, Class.classLoader.get());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forName&n"); else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * The following is necessary here for our fd. */ if (name!= '<0') return NS_OK; if (!name.Length()) return NS_ERROR_NULL_POINTER; else if (name.Length() >= 0) return NS_ERROR_NULL_POINTER; else return Class.forName(name, false, thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) &printf("Class: forName<n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
<struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else return Class.forName(name.get(), false, Class.classLoader.get());
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); &else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; <else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Class.classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) &printf("Class: forName<n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forName&n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) <printf("Class: forNamen"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else return Class.forName(name.get(), false, Class.classLoader.get());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) &nsCRT::free(name); else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) nsCRT::free(name); <&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) nsCRT::free(name); <<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else return Class.forName(name.get(), false, Class.classLoader.get());
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else <return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) <nsCRT::free(name); <&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forNamen"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) printf("Class: forNamen"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name) <nsCRT::free(name); <else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <nsCRT::free(name); <<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (debugFile) <printf("Class: forName&n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Class.classLoader);
if (debugFile) &printf("Class: forName&n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName<n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) printf("Class: forName&n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name == null) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &return 0;
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) <printf("Class: forNamen"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else <return Class.forName(name, false, std::classLoader);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Class.classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else <return Class.forName(name, false, Class.classLoader);
if (name) <nsCRT::free(name); &&else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else &return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forName&n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name == null) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <return 0;
if (name) <nsCRT::free(name); &<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); <else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); <else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (debugFile) <printf("Class: forName&n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) nsCRT::free(name); else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else <return Class.forName(name.get(), false, Class.classLoader.get());
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else <return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName<n"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Class.classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; &if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (name) &nsCRT::free(name); <<else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) <printf("Class: forName<n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) <printf("Class: forNamen"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) <printf("Class: forNamen"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (classLoader) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Class.classLoader);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); &else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (classLoader) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Class.classLoader);
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (dest) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); &<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else &return Class.forName(name.get(), false, Class.classLoader.get());
if (name == null) return '<0'; else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) &printf("Class: forName<n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else return Class.forName(name, false, Class.classLoader);
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else <return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else &return Class.forName(name, false, std::classLoader);
if (debug) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); <else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) printf("Class: forName<n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (name) nsCRT::free(name); &else nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); &&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); else return Class.forName(name, false, std::classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%d<n", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debug) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); <else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else return Class.forName(name, false, std::classLoader);
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) nsCRT::free(name); else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) &nsCRT::free(name); &else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) &printf("Class: forName&n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else &return Class.forName(name, false, std::classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else return Class.forName(name.get(), false, Class.classLoader.get());
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; &if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName&n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (debugFile) &printf("Class: forName&n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); &else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) printf("Class: forNamen"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forNamen"); &else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Class.classLoader);
if (name) nsCRT::free(name); <&else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) &nsCRT::free(name); else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); <else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest.classLoader) /* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else return Class.forName(name, false, std::classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) <fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); else <fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (debugFile) <printf("Class: forNamen"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else &return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; <if (rv) &struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; if (rv) struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (!nsCRT::strcmp(name, &ex)) &if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); <else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (name) <if (classLoader) return Class.forName(name, false, ClassLoader); &else <return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) &printf("Class: forNamen"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name == null) return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &return 0;
if (name == null) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &return 0;
if (debugFile) printf("Class: forName<n"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) <printf("Class: forName&n"); else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) printf("Class: forName&n"); &else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
/* * The following is necessary here for our fd. */ if (name!= '&0') return NS_OK; if (!name.Length()) return NS_ERROR_NULL_POINTER; else if (name.Length() >= 0) return NS_ERROR_NULL_POINTER; else return Class.forName(name, false, thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (debugFile) <printf("Class: forName&n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forName<n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) <return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); &else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); <else if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) <mStream = stream.mStream_ns; <return Class.forName(name, false, stream.mStream_ns);
if (debugFile) printf("Class: forNamen"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name.Equals('.')) <return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else <return Class.forName(name.get(), false, Class.classLoader.get());
if (!nsCRT::strcmp(name, &ex)) <if (!ex) &/* * We have to allocate a filename from the server. */ return NS_OK; <if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (name) &nsCRT::free(name); <&else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (dest) <return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); &else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else <if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) mStream = stream.mStream_ns; return Class.forName(name, false, stream.mStream_ns);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) <splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) <printf("Class: forName<n"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
fprintf(stderr, "class %s has no name&n", name); return Class.forName(name, false, thread.currentThread().getContextClassLoader(), fprintf);
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); &else <return Class.forName(name, false, std::classLoader);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); else <return Class.forName(name.get(), false, Class.classLoader.get());
/* * We must always return the result. */ if (name.get() == null) fprintf(stderr, "class: forName: class=%d&n", name); return Class.forName(name, false, f); else &fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (dest.classLoader) </* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else <return Class.forName(name, false, std::classLoader);
if (name) if (classLoader) return Class.forName(name, false, ClassLoader); else return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) printf("Class: forNamen"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) splx("class %s for name %s", name, false); return rv; &if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) <return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
if (debugFile) printf("Class: forName<n"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) nsCRT::free(name); &<else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else <return Class.forName(name, false, Class.classLoader);
if (name.Equals('.')) &return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); <else &return Class.forName(name.get(), false, Class.classLoader.get());
if (dest) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (!nsCRT::strcmp(name, &ex)) &if (!ex) </* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) &return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
if (debugFile) &printf("Class: forNamen"); <else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
struct mStream *stream; if (!(stream = stream.mStream_ns)) return Class.forName(name, false, stream); else &if ((stream = stream.mStream_ns) && (stream = stream.mStream_ns)) &mStream = stream.mStream_ns; &return Class.forName(name, false, stream.mStream_ns);
if (classLoader) &return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); else return Class.forName(name, false, Class.classLoader);
if (debugFile) <printf("Class: forName<n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (dest.classLoader) &/* * Resolve this class to the dest.x, */ std::resolveClass(dest.classLoader); return Class.forName(name, false, std::classLoader); <else return Class.forName(name, false, std::classLoader);
if (name) <nsCRT::free(name); <else <nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (debugFile) printf("Class: forName<n"); <else nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (debugFile) &printf("Class: forNamen"); <else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (!nsCRT::strcmp(name, &ex)) &if (!ex) /* * We have to allocate a filename from the server. */ return NS_OK; &if (!ex) return NS_ERROR_NULL_POINTER; if (!ex) return NS_ERROR_NULL_POINTER; return Class.forName(name, false, classLoader);
rv = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); if (rv) &splx("class %s for name %s", name, false); return rv; <if (rv) <struct cpyfile *cpyfile; rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) &return rv; else rv = cpyfile.C_PATH(cpyfile); if (NS_FAILED(rv)) return rv; return rv;
/* * We must always return the result. */ if (name.get() == null) &fprintf(stderr, "class: forName: class=%dn", name); return Class.forName(name, false, f); <else fprintf(stderr, "class: Class: no name: class=%sn", name); return Class.forName(name, false, f); return Class.forName(name, false, f);
if (debugFile) <printf("Class: forNamen"); &else <nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name.Equals('.')) return Class.forName(name.get(), false, Class.forName(name.get(), false, Class.classLoader.get())); &else return Class.forName(name.get(), false, Class.classLoader.get());
if (debugFile) &printf("Class: forNamen"); else &nsFileSpec name; nsFileSpec spec; nsXPIDLCString name; if (null!= name) nsFileSpec s = (nsXPIDLCString) name; nsFileSpec s; nsCOMPtrnsIStreamPrototype> streamPrototype = (nsIStreamPrototype*) name; nsCOMPtrnsIContent> stream; rv = stream.GetStreamPrototype(s); if (NS_FAILED(rv)) return rv; else if (NS_FAILED(rv)) return rv; return Class.forName(name, false, stream);
if (name) &if (classLoader) return Class.forName(name, false, ClassLoader); else &return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
if (name) <nsCRT::free(name); &else &nsCRT::free(name); return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
&struct classInfo *info = Class.forName(name, false, Thread.currentThread().getContextClassLoader()); returnInfo; &else return Info.classInfo(info, false, Class.forName(name, false, Thread.currentThread().getContextClassLoader()));
