golden:
return ~position;
inference:
return (position);
return position;

return position + id.length();
return  position;
return (long)position;
return parseInto(position);
return position - 1;
return _position;
return(position);
return 0;
return (int)position;
return (position--);
return &position;
return position.get();
return *position;
return position + position;
return result;
return  pos;
return NS_OK;
return (*position);
return --position;
return null;
return  (void)position;
return index;
return position + 1;
return lposition;
return = position;
return  (void *)position;
return  (int)position;
return position--;
return  id.length();
return id;
return value;
return  0;
return (0);
return  id;
return id.length();
return  (void *) position;
return position, 0;
return (position-1);
return  position - 1;
return position+1;
return None;
return position, position;
return ret;
return aPosition;
return ((int)position);
return (char *)position;
return null, position;
return  (void) position;
return (void *)position;
return position);
return true;
return ();
return position  0;
return str.get();
return status;
return  &position;
return (position + 1);
return position-1;
#endif return position;
return -1;
return  (long)position;
else return position;
return position2;
return  position  0;
return rv;
return (double)position;
return (char*)position;
return!position;
return false;
return (position  0);
return;
return  (int) position;
return (long)position);
return this;
return position = 0;
return parseIn(position);
return (position+1));
return (position)  position;
return nposition;
return position1;
return  value;
return (unsigned long)position;
return position - id;
return  (void **)position;
return new position;
return, position;
return  _position;
return position + id;
goto out;
return offset;
return -position;
return SIZE(position);
return position0;
return SIZE;
return intposition;
return aPos;
ret = position;
return (int) position;
return  len;
return (position-position);
return Position;
break;
return NONE;
return (void*)position;
return (size_t)position;
return pos;
return ALL_IDS;
return (void **)position;
return (position - id);
return position>;
return: position;
return size;
return position - 2;
return (long) position;
return len;
return (char *) position;
return retval;
return position++;
return  (void **) position;
return (position+1);
return ;
return  (unsigned long)position;
return (position - 1);
return all_ids;
return parseInto(position, str);
return (char **)position;
return ((long)position);
return (u_long)position;
result = position; return result;
return size();
return position >> 2;
return 1;
return &position);
return position - position;
return index, position;
return  (void*)position;
return  (char *)position;
return parseInto(&position);
return
return str.length();
return NULL_IDS;
return (void *) position;
return text.length();
return Position.position;
return (position-size);
return '0';
return  position = 0;
return position, id;
return ParseInto(position);
return sizeof(position)-1;
return parseInto(position, position);
return (position + 1));
return (position + id);
return str;
return (char*) position;
return numPos;
return  (char *) position;
return position, null;
return  (void*) position;
return SIZE_LEN;
return position3;
return (DateTimeParserBucket*)position;
return (position + id.length());
return STATIC_CAST(DateTimeParserBucket*, position);
return (DateTimeParserBucket *)position;
return position ||!position;
return LIST_IS_BUSY(position)?position:position;
return strlen(position) + 1;
return PlaceholderCharacterSize(position));
return LocalTime(position);
return  /* position */;
return position, sizeof(position)>1;
return sizeof(position) - 1;
return sizeof(long) - 1;
return (unsigned char *) position;
return NULL_VALUE;
return (position+1)*position;
return id.length;
return  0  position;
return SIZE(position) - position;
return position, position2;
return (position+2) = position;
return LocalTime();
return None, position;
return *position, NOTIFY_STACK;
return Position();
return  &position  0;
return position  position;
return position + (*(str.equals("ignore")? "alignment") : "px"));
return ((Bool)position);
return (void*) position;
return positionNone;
return BASE_DEFAULT_PARSER_COUNT, position;
return ByteTimeZone.forID(bj));
return ((DateTimeUnit *)position);
return position  sizeof(position);
return SIZE_DATE_TIME_SIZE;
return position.tqe_first;
return position.toInt();
return  POSIX_PREFIX_PREFIX_POINTER;
return  0? position : position;
return (PRUint32)position;
return position.toLength();
return BASE_ENTRY;
return SizeToWidth(position);
return  s = 0;
return position || position  position;
return (uint32_t)position;
return ((u_long)position);
return position + 1, position;
return ((const DateTimeData*)position);
return  0? position : null;
return position + (nsCRT::time()));
return inst.position;
return BoolSize;
return (position+5);
return PlaceholderAtom.position;
return Bool& position;
return  position - id;
return position, (DateTimeZone*)position;
return sizeof(char*));
return position + (type!= X_DATE);
return  (*position)position;
return ((PRUint32)position);
return SEC_LOCKED;
return (position-1));
return position.ToWord();
return Position(position);
return position, &mNumMasks;
return &position1;
<return position - 1;
return &(position+2) = position;
return <&position);
return &position &0;
return position, (DateTimeZone*)position;
return &position.toInt();
return <position--;
return &str.get();
return value;
return (&position);
return &intposition;
return &index, position;
return <result;
return nposition;
return position <position;
return &position <sizeof(position);
return <position + position;
return &/* position */;
<return &position&;
return position.toInt();
return &((PRUint32)position);
&else return position;
return &((int)position);
&return <position - 1;
return &str;
return <position, &mNumMasks;
&return <position;
return &PlaceholderCharacterSize(position));
return <str.length();
<return <position - 1;
return &(position + id.length());
return (void*) position;
return &(position+1));
return &LocalTime();
return PlaceholderCharacterSize(position));
return &position, id;
return <(size_t)position;
return sizeof(position)-1;
return (position+1)*position;
return 0? &position : &null;
return lposition;
return &&position);
return &*position&;
return <position position;
return <0? &position : null;
return <((u_long)position);
return parseInto(position);
return <position+1;
return <_position;
return &(position+2) &= position;
return (position + 1));
return <(position-1);
return position &0;
return <position ||!position;
return <ByteTimeZone.forID(bj));
return <position;
return position - 2;
return position.toLength();
return Position(position);
return LIST_IS_BUSY(position)?position:position;
return <(long)position;
&return position - 1;
return &PlaceholderAtom.position;
return sizeof(char*));
return (position - 1);
return <(char*) position;
return <str.get();
return &(int) position;
return <*position, &NOTIFY_STACK;
return str;
return <position, position;
return &position&null;
return (position+1));
return <0? <position : position;
return &Bool& position;
return &position + (*(str.equals("ignore")? "alignment") : "px"));
return (u_long)position;
return position.tqe_first;
return (char*)position;
return &id;
return(&position);
&return position&;
return <((long)position);
return position3;
return <position-1;
return new &position;
return &(position + 1);
return &(void *) position;
ret = position;
&return &position&;
return (void *) position;
return position, null;
return <(char *)position;
return <(position+1));
return &len;
return &(position-size);
return &position + position;
return &value;
return <position, (DateTimeZone*)position;
return &<position;
return <position, sizeof(<position)>1;
return ((long)position);
return &();
return <--position;
return &position;
return <Position.position;
return SIZE_DATE_TIME_SIZE;
return *position, <NOTIFY_STACK;
return &position--;
return &(position+2) <= position;
return &position >> 2;
return &position&1;
return position + (nsCRT::time()));
&<return position;
return(<position);
return (unsigned char *) position;
return <0? <position : null;
return &null;
return <position);
return &position++;
return &nposition;
return: <position;
return &null, position;
return SEC_LOCKED;
return &position, (DateTimeZone*)position;
return '<0';
return 0 <position;
return &position&3;
return &size;
return &LocalTime(position);
<return parseInto(position);
return &0;
return <(PRUint32)position;
<return <position&;
return parseInto(&position);
return &position + id;
return '&0';
return &Position.position;
return <*position&;
return &position || position <position;
return (uint32_t)position;
return &'0';
<<return <position;
return position >> 2;
return <(position + 1));
return &position<;
return LocalTime(position);
return &(position-position);
return <<position;
&return (position);
return position || position position;
return &position, sizeof(&position)>1;
return (position);
return &ByteTimeZone.forID(bj));
return (unsigned long)position;
return <;
return <(DateTimeParserBucket *)position;
return <position.toLength();
return <0? <position : &null;
return &position3;
return 0? position : &null;
return <(int)position;
return id.length;
return 0? position : <null;
return position + 1, position;
return 0? &position : position;
return &sizeof(char*));
return <position + 1, position;
return &0? position : position;
return index, position;
return (char*) position;
return 0? <position : position;
return &= position;
return ((DateTimeUnit *)position);
return <(void **) position;
return &*position, <NOTIFY_STACK;
return <0? position : position;
return numPos;
return ((const DateTimeData*)position);
return &position - position;
return position1;
return <id.length;
return <LocalTime();
return <((PRUint32)position);
return &*position;
return &0 &position;
return (long)position);
return &LIST_IS_BUSY(position)?position:position;
return SIZE(position);
return position;
return <position.toInt();
return &pos;
return <PlaceholderCharacterSize(position));
return &position, null;
return , position;
return _position;
return <len;
return 0;
return null;
else return &position;
return <sizeof(position)-1;
return <*position, <NOTIFY_STACK;
return <(position-1));
return &position, sizeof(<position)>1;
return <size;
return <BASE_ENTRY;
return <(void *)position;
return <(char **)position;
return <SIZE;
return &!position;
return(position);
return &result;
return LocalTime();
return <position &position;
return position &sizeof(position);
return position<2;
return &0 position;
return (void **)position;
return &position&;
return &position + 1, position;
return &position &= 0;
return *position, &NOTIFY_STACK;
return *position<;
return <(position+2) <= position;
return <position.get();
return &BASE_ENTRY;
return &(void*) position;
return id.length();
return <position<3;
return <pos;
return <(position - 1);
return &position.ToWord();
return <(void *) position;
&return &position;
return <position<1;
return &Position;
return &all_ids;
return &SizeToWidth(position);
return &position || position position;
return position<null;
return position + id.length();
return 0? <position : null;
return new &position&;
return SizeToWidth(position);
return position);
return &(unsigned long)position;
return <'<0';
return &(void)position;
&return position;
<else return <position;
return size();
return &index;
return (char *)position;
return &'<0';
return <(DateTimeParserBucket*)position;
return <sizeof(long) - 1;
&else return <position;
return <index;
return new position&;
return position&2;
return &size();
return <STATIC_CAST(DateTimeParserBucket*, position);
return (void **) position;
return &(PRUint32)position;
return position<0;
return null, position;
return ((u_long)position);
return position + position;
return position || position <position;
return position<3;
<return <position<;
return 0 &position;
<return &position<;
return &((DateTimeUnit *)position);
return &(char *)position;
return position position;
return &position 0;
return &(position+1);
return <0? <position : <null;
return <();
return (*position)position;
return position<1;
return 0? <position : <null;
return (DateTimeParserBucket*)position;
return position&3;
return &0? &position : <null;
return <position || position <position;
return &SIZE;
return <position<null;
return BASE_DEFAULT_PARSER_COUNT, position;
return <position&;
return <(position+1)*position;
<return position&;
<return &position - 1;
return --position;
#endif return position;
return <position + id.length();
return &positionnull;
return &(long)position;
return (DateTimeParserBucket *)position;
return position + id;
return &*position<;
return <position || position position;
return &null;
return (position+5);
<&return <position;
return position&0;
return &SIZE_DATE_TIME_SIZE;
return (int)position;
return <SIZE(position) - position;
return position + (*(str.equals("ignore")? "alignment") : "px"));
return &(void **) position;
return &--position;
return &strlen(position) + 1;
return position&1;
return <position.ToWord();
return (position <0);
return SIZE_LEN;
return <position;
#endif return &position;
return <position<0;
return <(position+2) = position;
return position + (type!= X_DATE);
return all_ids;
return <position, id;
return /* position */;
return <value;
return
return <position.tqe_first;
return BASE_ENTRY;
return (position+2) = position;
result = <position; return result;
return (long)position;
return &position.toLength();
return &lposition;
return &position = 0;
return &(char *) position;
return (position+2) &= position;
return &position2;
return <NULL_VALUE;
return PlaceholderAtom.position;
return <position &= 0;
&return <position<;
return position <sizeof(position);
return position || position &position;
return <text.length();
return strlen(position) + 1;
return <&position 0;
return <position sizeof(position);
return NULL_VALUE;
return <LIST_IS_BUSY(position)?position:position;
&return position<;
return position, id;
return &position <= 0;
return (position) position;
return &(long)position);
return &*position, &NOTIFY_STACK;
return <position&2;
return (void)position;
return <(position--);
return <&position &0;
return &(position-1);
return <0? &position : position;
return <position&3;
return intposition;
return position &position;
<<return position;
return position = 0;
return position.get();
return <BASE_DEFAULT_PARSER_COUNT, position;
return &(void **)position;
#endif return <position;
ret = <position;
return <null;
return &(size_t)position;
return <position1;
return &(char **)position;
return &(char*)position;
return </* position */;
return <sizeof(position) - 1;
return <LocalTime(position);
return &position - 2;
&&return <position;
return &position + (type!= X_DATE);
return ((PRUint32)position);
return &(int)position;
return <position0;
<&return position;
return &position &position;
return &position<0;
return <*position<;
&&return &position;
return &position;
return <0;
return &SIZE_LEN;
return position, sizeof(position)>1;
return &POSIX_PREFIX_PREFIX_POINTER;
return &-position;
return <position&0;
return <((Bool)position);
return position&null;
return &sizeof(position)-1;
return <position <position;
return <(char*)position;
return &position - id;
return <position, sizeof(position)>1;
return position<;
return new <position;
return position ||!position;
return &str.length();
return <(void*)position;
return position2;
return <lposition;
return <all_ids;
return (long) position;
return position;
return &position<3;
return &NULL_VALUE;
return <ALL_IDS;
return <position&1;
return <index, position;
return &&position &0;
return &0? &position : position;
return new <position<;
return &STATIC_CAST(DateTimeParserBucket*, position);
return ;
return null, position;
return <(void*) position;
return <(unsigned char *) position;
return &position<2;
result = position; return result;
return s = 0;
return position, position;
return &position0;
return <(double)position;
return &, position;
return <numPos;
return &s = 0;
return &position + id.length();
return <'0';
return <*position;
return <PlaceholderAtom.position;
return &0? position : <null;
return sizeof(position) - 1;
return <position3;
<else return position;
return (size_t)position;
return <'&0';
return <position&null;
return ALL_IDS;
return &numPos;
return &(uint32_t)position;
return position - id;
return &position <position;
return <((DateTimeUnit *)position);
return position <= 0;
return (position 0);
return &position>;
return str.get();
<&return &position;
return &SIZE(position) - position;
return <position + (nsCRT::time()));
return position sizeof(position);
return new position;
return <Position(position);
return position + 1;
return <!position;
return !position;
return &position + (nsCRT::time()));
return <0? position : null;
return <position, 0;
return &0 <position;
return <*position, NOTIFY_STACK;
return <SIZE_DATE_TIME_SIZE;
return <id;
return &position, position;
return <position <sizeof(position);
return sizeof(long) - 1;
return &position, sizeof(position)>1;
return Position.position;
return <(unsigned long)position;
return &position<1;
return (char **)position;
return &0? <position : position;
return <(char *) position;
return (position + id.length());
return <position + (*(str.equals("ignore")? "alignment") : "px"));
return SIZE(position) - position;
return <position >> 2;
&return &position<;
return &(position--);
return <position || position &position;
return &(double)position;
return <position - id;
return <SIZE_LEN;
return &&position <0;
return &position<null;
return &BASE_DEFAULT_PARSER_COUNT, position;
return <intposition;
return <= position;
return (position) <position;
return <(void)position;
return position 0;
return <position++;
else return <position;
<return position<;
return '0';
return <inst.position;
return <(position+5);
return position &= 0;
return <position - 2;
return &Position(position);
return &position+1;
return &id.length();
return &;
return <0? position : &null;
return &SEC_LOCKED;
return &sizeof(position) - 1;
return <BoolSize;
return position&;
return <position &0;
return <position<;
return <position &sizeof(position);
return &*position, NOTIFY_STACK;
return <id.length();
return &0? <position : &null;
return &(*position)position;
return position - position;
return (<position);
return (position+1);
return size;
return &(char*) position;
return <((int)position);
return positionnull;
return 0? position : position;
return ((Bool)position);
return &((u_long)position);
return &'&0';
return -position;
return position, sizeof(&position)>1;
return &position <0;
return (int) position;
return NONE;
return &&position 0;
return 0? &position : null;
return: &position;
return pos;
return <0? &position : <null;
return 0? position : null;
return <(position + id.length());
return (void) position;
return &0? position : null;
return &0? <position : <null;
return <-position;
return <size();
return &(position+5);
return parseInto(<position);
return <NULL_IDS;
return &position-1;
return &position + 1;
return (PRUint32)position;
return <SIZE(position);
return <position, sizeof(&position)>1;
return id;
return 0? &position : <null;
return &_position;
return <&position;
&else return &position;
return &(DateTimeParserBucket*)position;
return <(long)position);
return <position <= 0;
return &(DateTimeParserBucket *)position;
return (position-1));
return <position, position2;
return <(position+2) &= position;
<return position;
return position, &mNumMasks;
return &&position;
return: position;
&return parseInto(position);
return &position - 1;
return <position = 0;
return <strlen(position) + 1;
<return (position);
return (position &0);
return &position &sizeof(position);
return <positionnull;
return position+1;
return &(long) position;
return new <position&;
return &BoolSize;
return position>;
return <(void **)position;
return POSIX_PREFIX_PREFIX_POINTER;
return &position sizeof(position);
return <position <0;
return 0? <position : &null;
return &((Bool)position);
return <position - 1;
return STATIC_CAST(DateTimeParserBucket*, position);
return <Position();
return &position.tqe_first;
return ();
return <position, null;
return <0 &position;
return <SEC_LOCKED;
return position <0;
return (position-1);
return &(position+1)*position;
return <sizeof(char*));
return <position + 1;
return &SIZE(position);
return &((long)position);
<<return &position;
return &0? &position : null;
return <(*position)position;
return (double)position;
return ByteTimeZone.forID(bj));
return position0;
return <((const DateTimeData*)position);
return (position) &position;
return <position - position;
return &(u_long)position;
return position, sizeof(<position)>1;
return <(long) position;
return text.length();
return <0? position : <null;
return &0? position : &null;
return (position + 1);
return str.length();
return position--;
return inst.position;
return NULL_IDS;
return null;
return <position>;
return len;
&return <position&;
return <SizeToWidth(position);
return index;
return <Position;
return &(unsigned char *) position;
return &position, position2;
return <(position+1);
return <(u_long)position;
<return <position;
return <(uint32_t)position;
return ((int)position);
return <null, position;
return position, 0;
return <(position-position);
result = &position; return result;
return result;
ret = &position;
return position-1;
return = position;
return <str;
return position++;
return BoolSize;
return (char *) position;
return <null, position;
return &id.length;
return &position&0;
return <&position <0;
return <0 position;
&return &position - 1;
return <position + id;
return (position--);
return Position;
return <(position-size);
return <POSIX_PREFIX_PREFIX_POINTER;
return &Position();
return position - 1;
return (position-position);
return <position<2;
return &NONE;
return &((const DateTimeData*)position);
&&return position;
return <s = 0;
return &text.length();
return *position, NOTIFY_STACK;
&<return &position;
return <position + (type!= X_DATE);
return <NONE;
return <Bool& position;
return <nposition;
return (position-size);
return <(int) position;
return &position, 0;
return Position();
return &position.get();
return new position<;
return &ALL_IDS;
return &position || position &position;
return <0? &position : &null;
return &(void) position;
return &0? <position : null;
&<return <position;
return &(position + 1));
return position, position2;
return &NULL_IDS;
return (void*)position;
return *position&;
return (void *)position;
return &(position - 1);
return 0 position;
return <, position;
return &(void *)position;
return &null, position;
return &position&2;
return &position ||!position;
return Bool& position;
return <position2;
else return position;
return &(void*)position;
return <(void) position;
return &inst.position;
return &position, &mNumMasks;
<else return &position;
return *position;
return <position 0;
return &0? &position : &null;
return &position);
return <null;
return &sizeof(long) - 1;
return <0 <position;
return &position position;
return position.ToWord();
return SIZE;
return (position+2) <= position;
return new &position<;
return &(position-1));
<return &position;
return <(position + 1);
