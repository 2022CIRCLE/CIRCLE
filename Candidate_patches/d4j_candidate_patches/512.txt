golden:
<extra_id_0>
inference:
#endif

return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
v1D = line.intersection(subLine.line);
return v1D;
return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
free(subLine.line);
return (loc1 == Location.INSIDE)? v1D : null;
return null;
v1D = subLine.line;
return (loc1 == Location.OUTSIDE)? v1D : null;
*/
return null;
return ((loc2 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
splx(s);
return ((loc1 == Location.SIDE) && (loc2 == Location.SIDE))? v1D : null;
else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
v2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v2D));
return (loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
return (loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return (loc2 == Location.OUTSIDE)? v1D : null;
return (loc1!= Location.OUTSIDE)? v1D : null;
return (loc1 == Location.LINE)? v1D : null;
v1D = subLine.line.intersection(subLine.line);
v1D = null;
return loc1 == Location.OUTSIDE && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints)
return loc2;
return ((loc1 == Location.INLINE) && (loc2 == Location.INLINE))? v1D : null;
v1D = null;
return (loc2!= Location.OUTSIDE)? v1D : null;
return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
return result;
free(line);
return subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
break;
v3D = line.intersection(subLine.line);
return (loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
@endif
line.intersection(subLine.line);
return v2;
return ((loc1 == Location.INTSIDE) && (loc2 == Location.INTSIDE))? v1D : null;
return ((loc2 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v2D : null;
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v2D));
v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
else  v1D = line.intersection(subLine.line);
else if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
free(subLine);
else
if (includeEndPoints)  return v1D;
loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
v1D = v1D;
return (loc2 == Location.OUTSIDE)? v2D : null;
return loc1!= Location.OUTSIDE && (loc2!= Location.OUTSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
/* XXX */
return (includeEndPoints)? v1D : null;
return v3D;
v1D = line.intersection(line.line);
return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
delete subLine.line;
return subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
#ifdef DEBUG
int i;
checkPoint(line.toSubSpace(v1D));
Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.NORMAL) && (loc2 == Location.NORMAL))? v1D : null;
return 0;
else return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
return ((loc1 == Location.INT) && (loc2 == Location.INT))? v1D : null;
continue;
v1D = subLine.line.intersection(v1D);
return ((loc1 == Location.INCLUDE) && (loc2 == Location.INCLUDE))? v1D : null;
subLine.line = subLine.line;
return ((loc1 == Location.ASIDE) && (loc2 == Location.ASIDE))? v1D : null;
return ((loc2 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return loc1 == Location.INSIDE && (loc2 == Location.INSIDE))? v1D : null;
Vector3D v1D = line.intersection(subLine.line);
return ((loc1 == Location.DISPLAY) && (loc2 == Location.DISPLAY))? v1D : null;
if (includeEndPoints) v1D = line.intersection(subLine.line);
return (loc2!= Location.OUTSIDE)? v2D : null;
(void) line.intersection(subLine.line);
return ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.INIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.UPSIDE) && (loc2 == Location.UPSIDE))? v1D : null;
else  return v1D;
return ((loc1 == Location.RIGHT) && (loc2 == Location.RIGHT))? v1D : null;
return ((loc1 == Location.NONE) && (loc2 == Location.NONE))? v1D : null;
return ((loc1 == Location.END) && (loc2 == Location.END))? v1D : null;
return ((loc1 == Location.LINE) && (loc2 == Location.INSIDE))? v1D : null;
v1D++;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.INSIDE))? v1D : null;
int includeEndPoints;
else  return (loc1 == Location.INSIDE)? v1D : null;
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D: null;
loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v2D));
free(v1D);
if (includeEndPoints)  v1D = line.intersection(subLine.line);
if (includeEndPoints) return v1D;
int v1D;
return ((loc2 == Location.OUTSIDE) && (loc3 == Location.OUTSIDE))? v1D : null;
else v1D = null;
#if defined(XP_MAC) || defined(XP_MACOSX) || defined(XP_MACOSX)
else if ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
return (loc1 == Location.SIDE)? v1D : null;
return v1D? v1D : null;
v3D = subLine.line;
return (loc1 == Location.INLINE)? v1D : null;
if ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D: null;
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? loc1D : null;
else  v1D = null;
Line3D v1D = line.intersection(subLine.line);
v2 = line.intersection(subLine.line);
return ((loc2 == Location.OUTSIDE) && (loc2 == Location.INSIDE))? v1D : null;
delete subLine;
v1D = 0;
v1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
return v2D;
if (includeEndPoints)  loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
free(subLine.line.toSubSpace(v1D));
return (loc2!= Location.OUTSIDE)? v2 : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? loc1D : null;
if (includeEndPoints) break;
return includeEndPoints;
freeRegion(subLine.line);
return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) #endif
v2 = v2;
Vector3D loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else v1D = null;
if (includeEndPoints == 0) return null;
Location loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
v1D = subLine.line.intersection(line);
#if defined(XP_MAC) || defined(XP_MACOSX)
return ((loc2 == Location.OUTSIDE) && (loc3 == Location.INSIDE))? v1D : null;
return (loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE)? v1D : null;
return v1D : null;
if (includeEndPoints)  return (loc1 == Location.OUTSIDE)? v1D : null;
return loc1!= Location.OUTSIDE && loc2!= Location.OUTSIDE? v1D : null;
return v1D!= null;
return (loc1 == Location.INSIDE)? v1D : null;
V3D v3D;
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v2D : null;
if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))  v1D = null;
v1D = line.intersection(subLine.line); v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
else  if (includeEndPoints && includeEndPoints >= 0)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (ntoInclude)  return ((loc1 == Location.INVALID) && (loc2 == Location.INVALID))? v1D : null;
if (!includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints)  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else  if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = line.intersection(subLine.line); v1D = line.remainingRegion.checkPoint(line.toSubSpace(v1D)); if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (!(loc1 == Location.PREFIX) || loc2 == Location.PREFIX))  return null;
if (negativeLineLastLine == subLine.line)  if (negativeLineLastLine == subLine.line)  v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D)))  v1D = line.intersection(subLine.line);  if (lline.remainingRegion &&!lline.remainingRegion)  v1D = line.intersection(subLine.line);
if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE))? v1D : null;
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v2D)); if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
else if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (line.mLineEndPoint)  v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));  else  v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
v1D = (struct subLine*) subLine.line;
if (includeEndPoints)  return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
if (includeEndPoints)  if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line!= subLine.line.subSpace)  v1D = (subLine.line!= subLine.line.subSpace)? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE))  v1D : null;  else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line))  v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
v2 = null;
if (includeEndPoints)  if (!eLeftLine)  /* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine;  else  /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints)  if (!remainingRegion.checkPoint(line.toSubSpace(v1D))) return null;
return v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0)  for (i=0; isubLine.line.width; i++)  SubLine line;  else  for (i=0; isubLine.line.height; i++)  if (i[i].lineNumber == subLine.line.size)  while ((line[i].line.width > 0) && (line[i].line.height > 0))  line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height;   if (i[i].line.height > 0)  if (i[i].line.height  0) line[i].line.height = line[i].line.height;  else  line[i].line.height =
if (strcmp(subLine.line, "--includeEndPoints") == 0) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
/* * check if it's a subline.. */
#ifdef XP_MAC if (i  3)  return ep;
if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line)  if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * Check to see if we've already * encountered a sub-line alignment. */ if (subLine.line.octets)  v1D = subLine.line.octets;
else  if (subLine.line)  v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));  else  v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.INSIDE)  return v1D : null;
if (includeEndPoints)  if (ioCluster)  v1D = subLine.line.intersection(ioCluster);  else  v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* If there are no sub-line lines, we don't have a line that is not inline. */ v1D = line.intersection(subLine.line);
if (line.flags & (BITMAP_LINE))  return ((bitmap == BitMAP_LINE) && (bitmap == BitMAP_LINE))? v1D : null;
if (includeEndPoints)  if (!includeEndPoints)  return NS_ERROR_OUT_OF_MEMORY;
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;  else  return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (line.length() == subLine.line.length()) return v1D;
v1D = line.intersection(subLine.line); if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints)  ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret  0)  ret = (ret  0)? v1D : null;
else if (v1)  v1D = null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1)  /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null;  else  /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
v1D.line.remainingRegion.checkPoint(line.toSubSpace(v1D));
else  if (remainingRegion.checkPoint(line.toSubSpace(v1D)))  loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (loc2!= Location.OUTSIDE)  /* do this - if they are in the line. */ return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeReference)  mFlags |= NS_LITERAL_STRING("V");
else  if ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else if (line.get() == line.get())  return (loc1 == Location.INSIDE)? v1D : null;
/* XXX - get it */
else  if (includeEndPoints)  if (subLine.line)  loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));  else  loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));  else  loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (i  0)  return (i++);
if (remainingRegion)  v1D = line.intersection(subLine.line); v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
/* not an array if it is a whole line. */ if (pseudoType!= pseudoType)  PSPEM_NOT_FOREACHED(pseudoType); pseudoType = pseudoType;
/* * XXX */
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (loc1 == Location.LINE)  if (loc2 == Location.LINE)  v1D = v1D;  else  v1D = v1D;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0)  return ((clone & '0') == 0)? clone : null;
else if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else if (includeEndPoints)  return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
v2 = (v1 == Location.INSIDE)? v1D : null;
if (line.endsWith("ptr"))  if (!strlen(line.endsWith("ptr")))  v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len;  else  v1D = line.intersection(line.line);
return ((loc1 == Location.PX) && (loc2 == Location.PX))? v1D : null;
else  if (eResendDebug == eResendDebug)  eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return (loc1 == Location.INF)? v1D : null;
if (line == v1D)  if (includeEndPoints)  v1D = (VoidLine) subLine.line;  else  v1D = (VoidLine) subLine.line;
if (subLine.line)  v1D = subLine.line; else  v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints)  if (includeEndPoints)  if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null)  loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));  else  loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));  else  loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
/* * Find a new location based on the specified prefix */ if ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE)) v1D : null;
if (!includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (line.isEmpty())  return v1D;
#if defined(XP_MAC) || defined(XP_MACOSX) if ((loc1 == Location.INTR) && (loc2 == Location.INTR))? v1D : null; #endif
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line)  loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && (loc1 == Location.INIDE) && (loc2 == Location.INIDE))  return v1D;
else if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints && subLine.line.mInclude)  v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints)  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (len = 0) return (-1);
if (remainingRegion)  return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('0'))  int i;
v1D = newLine.nextLine(); v1D.line = subLine.line;
else  v1D = v1D;
if (includeEndPoints)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (subLine.line)  nv = line.intersection(subLine.line); if (nv)  nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv)  nv = line.intersection(subLine.line); if (nv!= nv)  nv = line.intersection(subLine.line);    else  nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
return ((loc1 == Location.INBLOCK) && (loc2 == Location.INBLOCK))? v1D : null;
else if (includeEndPoints)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D)  return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line == null)  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len  0)  return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;  else  return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;

else if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; &else return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret <0)? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
&#endif
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; &else <v1D = v1D;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
else <if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return (loc2 == Location.OUTSIDE)? v2D : null;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
/* Get to the beginning of a new line. */ if (line.endsWith('&0')) int i;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
&else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret 0)? v1D : null;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <return (loc1 == Location.INSIDE)? v1D : null;
else &if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc1 == Location.INT) && (loc2 == Location.INT))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else if (line.get() == line.get()) &return (loc1 == Location.INSIDE)? v1D : null;
return (loc1 == Location.OUTSIDE)? v1D : null;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret 0)? v1D : null;
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
&else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints)
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else v1D = null;
&else <v1D = line.intersection(subLine.line);
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
<else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret <0)? v1D : null;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) <return ((clone & '<0') == 0)? clone : null;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
&else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret <0)? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret 0)? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; else <v1D = v1D;
else if (remainingRegion.checkPoint(line.toSubSpace(v1D))) &loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.mInclude) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; else <v1D = v1D;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) &return ((clone & '0') == 0)? clone : null;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret &0)? v1D : null;
&else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* not an array if it is a whole line. */ if (pseudoType!= pseudoType) &PSPEM_NOT_FOREACHED(pseudoType); pseudoType = pseudoType;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; <else v1D = v1D;
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
&else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret 0)? v1D : null;
<else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
return ((loc1 == Location.SIDE) && (loc2 == Location.SIDE))? v1D : null;
&else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret 0)? v1D : null;
if (includeEndPoints) v1D = line.intersection(subLine.line);
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret <0)? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (subLine.line == null) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
<else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
#ifdef XP_MAC if (i <3) &return ep;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
return loc2;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret 0)? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; else &v1D = v1D;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (includeEndPoints) &if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (!(loc1 == Location.PREFIX) || loc2 == Location.PREFIX)) <return null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
#ifdef XP_MAC if (i <3) <return ep;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
<else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('0')) <int i;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
&else &v1D = line.intersection(subLine.line);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v2D)); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (v1) &v1D = null;
if (includeEndPoints) &return (loc1 == Location.OUTSIDE)? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret 0)? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) <return ((clone & '&0') == 0)? clone : null;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (!includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else &if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
<#endif
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; <else v1D = v1D;
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (remainingRegion.checkPoint(line.toSubSpace(v1D))) <loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
&else &if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &return (loc1 == Location.INSIDE)? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
<else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (!includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret 0)? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; else <v1D = v1D;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (subLine.line) v1D = subLine.line; else v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (!includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; <else &v1D = v1D;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; <else <v1D = v1D;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line!= subLine.line.subSpace) &v1D = (subLine.line!= subLine.line.subSpace)? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (remainingRegion) <v1D = line.intersection(subLine.line); v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; &else v1D = v1D;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <v1D = v1D;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret 0)? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (remainingRegion.checkPoint(line.toSubSpace(v1D))) loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
&else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret &0)? v1D : null;
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (loc2!= Location.OUTSIDE) </* do this - if they are in the line. */ return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeReference) &mFlags |= NS_LITERAL_STRING("V");
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; <else &v1D = v1D;
return (loc2 == Location.OUTSIDE)? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret 0)? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (negativeReference) mFlags |= NS_LITERAL_STRING("V");
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; &else <v1D = v1D;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret &0)? v1D : null;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else <if ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!remainingRegion.checkPoint(line.toSubSpace(v1D))) return null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.isEmpty()) <return v1D;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
<else
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret &0)? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (v1) v1D = null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret 0)? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
&else if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (loc2!= Location.OUTSIDE) &/* do this - if they are in the line. */ return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret <0)? v1D : null;
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
if (len = 0) return (-1);
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
&else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret &0)? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; else &v1D = v1D;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; <else &v1D = v1D;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret <0)? v1D : null;
else &if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret <0)? v1D : null;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret <0)? v1D : null;
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (i 0) return (i++);
if (includeEndPoints) if (!includeEndPoints) &return NS_ERROR_OUT_OF_MEMORY;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret 0)? v1D : null;
if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) if (!eLeftLine) </* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret <0)? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!includeEndPoints) return NS_ERROR_OUT_OF_MEMORY;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (!includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
<else <v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) v1D = null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) </* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
<else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; &else v1D = v1D;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
&else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (!(loc1 == Location.PREFIX) || loc2 == Location.PREFIX)) return null;
&else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) &if (!includeEndPoints) &return NS_ERROR_OUT_OF_MEMORY;
if (subLine.line) v1D = subLine.line; else <v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret 0)? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
#ifdef XP_MAC if (i 3) &return ep;
if (negativeReference) <mFlags |= NS_LITERAL_STRING("V");
<else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
&else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; else &v1D = v1D;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret &0)? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; <else <v1D = v1D;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
<else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) return ((clone & '0') == 0)? clone : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else <if (remainingRegion.checkPoint(line.toSubSpace(v1D))) &loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
return loc1 == Location.OUTSIDE && (loc2 == Location.OUTSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; &else <v1D = v1D;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
&else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) &return ((clone & '&0') == 0)? clone : null;
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
&else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) &return ((clone & '&0') == 0)? clone : null;
else
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (!includeEndPoints) return NS_ERROR_OUT_OF_MEMORY;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret <0)? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) &return ((clone & '<0') == 0)? clone : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret &0)? v1D : null;
if (i &0) return (i++);
&else &if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &v1D = null;
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (!(loc1 == Location.PREFIX) || loc2 == Location.PREFIX)) &return null;
<else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) return ((clone & '&0') == 0)? clone : null;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (remainingRegion.checkPoint(line.toSubSpace(v1D))) &loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret <0)? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; &else v1D = v1D;
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; <else <v1D = v1D;
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (remainingRegion.checkPoint(line.toSubSpace(v1D))) <loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret &0)? v1D : null;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; else v1D = v1D;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret &0)? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
else if (includeEndPoints && (loc1 == Location.INIDE) && (loc2 == Location.INIDE)) &return v1D;
&else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (remainingRegion.checkPoint(line.toSubSpace(v1D))) loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc2 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; else &v1D = v1D;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* * Check to see if we've already * encountered a sub-line alignment. */ if (subLine.line.octets) &v1D = subLine.line.octets;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; else v1D = v1D;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; else v1D = v1D;
else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; else <v1D = v1D;
else &if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) <return ((clone & '0') == 0)? clone : null;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret &0)? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
<else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret 0)? v1D : null;
if (loc1 == Location.INSIDE) return v1D : null;
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (line.get() == line.get()) <return (loc1 == Location.INSIDE)? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; &else &v1D = v1D;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; else <v1D = v1D;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
<else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (subLine.line == null) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; <else &v1D = v1D;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return (loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; &else <v1D = v1D;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
return ((loc1 == Location.INBLOCK) && (loc2 == Location.INBLOCK))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
<else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret &0)? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* not an array if it is a whole line. */ if (pseudoType!= pseudoType) PSPEM_NOT_FOREACHED(pseudoType); pseudoType = pseudoType;
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return null;
if (ntoInclude) <return ((loc1 == Location.INVALID) && (loc2 == Location.INVALID))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; &else <v1D = v1D;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (i <0) return (i++);
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
/* Get to the beginning of a new line. */ if (line.endsWith('<0')) &int i;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; else v1D = v1D;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; else &v1D = v1D;
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) v1D = line.intersection(subLine.line);
else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else <return v1D;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
<else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret 0)? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints && subLine.line.mInclude) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; &else <v1D = v1D;
else <v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; <else v1D = v1D;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; &else &v1D = v1D;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; &else &v1D = v1D;
if (remainingRegion) &return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; <else v1D = v1D;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (i 0) &return (i++);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
<else if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; &else &return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret 0)? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; <else v1D = v1D;
else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &return v1D;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
&else <if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D: null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; else &v1D = v1D;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) <return ((clone & '<0') == 0)? clone : null;
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
&else &if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret &0)? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret <0)? v1D : null;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!includeEndPoints) <return NS_ERROR_OUT_OF_MEMORY;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) </* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.INSIDE) <return v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; &else &v1D = v1D;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) &v1D = subLine.line; else <v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) return ((clone & '0') == 0)? clone : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret <0)? v1D : null;
v1D = line.intersection(subLine.line); v1D = line.remainingRegion.checkPoint(line.toSubSpace(v1D)); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return (loc1 == Location.LINE)? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else <if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
&else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret <0)? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#ifdef XP_MAC if (i &3) <return ep;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; <else <return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
else <v1D = null;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!includeEndPoints) return NS_ERROR_OUT_OF_MEMORY;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; &else v1D = v1D;
&else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret &0)? v1D : null;
else if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret 0)? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) <return ((clone & '0') == 0)? clone : null;
if (subLine.line) <v1D = subLine.line; else v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; else <return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <return (loc1 == Location.OUTSIDE)? v1D : null;
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; <else &v1D = v1D;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else v1D = line.intersection(subLine.line);
else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v2D)); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; else v1D = v1D;
if (ntoInclude) &return ((loc1 == Location.INVALID) && (loc2 == Location.INVALID))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; &else <v1D = v1D;
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret 0)? v1D : null;
else if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) return ((clone & '<0') == 0)? clone : null;
else return (loc1 == Location.INSIDE)? v1D : null;
&else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; else &v1D = v1D;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret <0)? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
<else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &v1D = v1D;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret &0)? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; <else v1D = v1D;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
&else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (remainingRegion) v1D = line.intersection(subLine.line); v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (len &= 0) return (-1);
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
return subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
&else v1D = line.intersection(subLine.line);
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) &ret = (ret 0)? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v2D)); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
#ifdef XP_MAC if (i 3) return ep;
if (includeEndPoints) <if (!includeEndPoints) <return NS_ERROR_OUT_OF_MEMORY;
<else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
<else &if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; <else <v1D = v1D;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else &if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; &else <v1D = v1D;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
/* * Check to see if we've already * encountered a sub-line alignment. */ if (subLine.line.octets) v1D = subLine.line.octets;
<else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; &else &v1D = v1D;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret &0)? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (i &0) &return (i++);
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret <0)? v1D : null;
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; <else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (subLine.line) &v1D = subLine.line; else &v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else <if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
<else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; &else &v1D = v1D;
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
&else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (loc1 == Location.INSIDE) &return v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if (includeEndPoints && subLine.line.len 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) <v1D = null;
if (line.isEmpty()) return v1D;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && (loc1 == Location.INIDE) && (loc2 == Location.INIDE)) <return v1D;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret &0)? v1D : null;
if (includeEndPoints) &v1D = line.intersection(subLine.line);
#ifdef XP_MAC if (i 3) <return ep;
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; else v1D = v1D;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
&else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('0')) int i;
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) v1D = subLine.line; else &v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) &return ((clone & '0') == 0)? clone : null;
else if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret <0)? v1D : null;
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && (loc1 == Location.INIDE) && (loc2 == Location.INIDE)) return v1D;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) return ((clone & '0') == 0)? clone : null;
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line = subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return (loc1 == Location.OUTSIDE)? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else <if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) &/* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; else v1D = v1D;
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
/* not an array if it is a whole line. */ if (pseudoType!= pseudoType) <PSPEM_NOT_FOREACHED(pseudoType); pseudoType = pseudoType;
if (subLine.line) &v1D = subLine.line; else v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; <else <v1D = v1D;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
&else <if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret 0)? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!includeEndPoints) <return NS_ERROR_OUT_OF_MEMORY;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; &else v1D = v1D;
else <if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else <if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret 0)? v1D : null;
if (includeEndPoints) &if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; else <v1D = v1D;
if (!includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
<else &if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
<else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret <0)? v1D : null;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else <if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) </* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; <else &v1D = v1D;
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) <return ((clone & '<0') == 0)? clone : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; &else <return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
else &if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; <else &return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('0')) &int i;
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; <else &v1D = v1D;
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.flags & (BITMAP_LINE)) <return ((bitmap == BitMAP_LINE) && (bitmap == BitMAP_LINE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret &0)? v1D : null;
if (!includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (loc2!= Location.OUTSIDE) /* do this - if they are in the line. */ return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
#ifdef XP_MAC if (i &3) return ep;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret 0)? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (remainingRegion.checkPoint(line.toSubSpace(v1D))) loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; &else <v1D = v1D;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
else <if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
else if (eResendDebug == eResendDebug) <eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <if (!remainingRegion.checkPoint(line.toSubSpace(v1D))) return null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else <if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#ifdef XP_MAC if (i <3) return ep;
if (includeEndPoints) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) if (!eLeftLine) /* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line == v1D) if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
#ifdef XP_MAC if (i &3) &return ep;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
<else &if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret 0)? v1D : null;
if (includeEndPoints && subLine.line.mInclude) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
<else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; <else &v1D = v1D;
else &if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else &if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) <SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret 0)? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (!includeEndPoints) &return NS_ERROR_OUT_OF_MEMORY;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret &0)? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
return (loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return v2;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('&0')) <int i;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.ASIDE) && (loc2 == Location.ASIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; <else <v1D = v1D;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; else &v1D = v1D;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) &return ((clone & '&0') == 0)? clone : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (subLine.line) <v1D = subLine.line; else &v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
return (loc1 == Location.INSIDE)? v1D : null;
&else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!remainingRegion.checkPoint(line.toSubSpace(v1D))) return null;
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) <return ((clone & '&0') == 0)? clone : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
return (loc2!= Location.OUTSIDE)? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) if (includeEndPoints) v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; <else <v1D = v1D;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; <else v1D = v1D;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (i 0) <return (i++);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; &else v1D = v1D;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret 0)? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.INLINE) && (loc2 == Location.INLINE))? v1D : null;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) return v1D;
return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i<subLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && includeEndPoints >= 0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) &return ((clone & '<0') == 0)? clone : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints && subLine.line.len 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (remainingRegion) return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret <0)? v1D : null;
if (line.mLineEndPoint) <v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) &v1D : null; &else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
if (includeEndPoints) if (!eLeftLine) /* if subLine.line = subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
else <if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) <if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; <else return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) <v1D = v1D; &else v1D = v1D;
if (includeEndPoints) <return v1D;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret <0)? v1D : null;
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; else v1D = v1D;
else if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '0') == 0) <return ((clone & '0') == 0)? clone : null;
else if (includeEndPoints) if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints && subLine.line.len &0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line.isEmpty()) &return v1D;
else &if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; <else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) &v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; <else v1D = v1D;
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
else v1D = v1D;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (i &0) <return (i++);
&else if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) return ((clone & '&0') == 0)? clone : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) &return ((clone & '<0') == 0)? clone : null;
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; else &return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
&else <if (eResendDebug == eResendDebug) &eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
else if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) return ((clone & '&0') == 0)? clone : null;
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line!= subLine.line.subSpace) v1D = (subLine.line!= subLine.line.subSpace)? v1D : null;
if (includeEndPoints) &if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret <0)? v1D : null;
if (ntoInclude) return ((loc1 == Location.INVALID) && (loc2 == Location.INVALID))? v1D : null;
if (subLine.line == null) &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <v1D = subLine.line; else <v1D = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) return ((clone & '<0') == 0)? clone : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) if (includeEndPoints) &v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
else if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret &0)? v1D : null;
return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null; else return ((loc1 == Location.REGION) && (loc2 == Location.REGION))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) &ret = (ret <0)? v1D : null;
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else <v1D = line.intersection(line.line);
if (includeEndPoints) if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
<else v1D = line.intersection(subLine.line);
<else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('<0')) int i;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) </* if subLine.line <= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
/* * Check to see if we've already * encountered a sub-line alignment. */ if (subLine.line.octets) <v1D = subLine.line.octets;
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else <v1D = line.intersection(line.line);
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; &else &v1D = v1D;
else if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return (loc1!= Location.OUTSIDE)? v1D : null;
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else <if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else return v1D;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else <if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (len <= 0) return (-1);
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) &/* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if ((loc1 == Location.INLINE) && (loc2 == Location.INSIDE)) <v1D : null; else if (subLine.line.intersection(subLine.line) == subLine.line.intersection(subLine.line.intersection(subLine.line)) == subLine.line.intersection(subLine.line)) <v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line)); v1D = (void*)subLine.line.intersection(subLine.line.intersection(subLine.line));
else if (v1) <v1D = null;
if (remainingRegion) &v1D = line.intersection(subLine.line); v1D = remainingRegion.checkPoint(line.toSubSpace(v1D));
else if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
<else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret &0)? v1D : null;
if (includeEndPoints) <if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) return ((clone & '<0') == 0)? clone : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line <= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.flags & (BITMAP_LINE)) &return ((bitmap == BitMAP_LINE) && (bitmap == BitMAP_LINE))? v1D : null;
/* Get to the beginning of a new line. */ if (line.endsWith('<0')) <int i;
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) <ret = (ret 0)? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) <return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) <ret = (ret <0)? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; <else <v1D = v1D;
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '&0') == 0) <return ((clone & '&0') == 0)? clone : null;
if (includeEndPoints) &if (ioCluster) <v1D = subLine.line.intersection(ioCluster); else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) v1D = v1D; <else v1D = v1D;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else &v1D = line.intersection(line.line);
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) ret = (ret 0)? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.flags & (BITMAP_LINE)) return ((bitmap == BitMAP_LINE) && (bitmap == BitMAP_LINE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) &/* if subLine.line &= subLine.line.width &= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (line == v1D) &if (includeEndPoints) <v1D = (VoidLine) subLine.line; else &v1D = (VoidLine) subLine.line;
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) &v1D = v1D; <else &v1D = v1D;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) &if (!eLeftLine) </* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else if (includeEndPoints) return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (remainingRegion) <return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) /* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else &/* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; <else v1D = (VoidLine) subLine.line;
v1D = line.intersection(subLine.line); v1D = line.remainingRegion.checkPoint(line.toSubSpace(v1D)); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line = subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
v1D = line.intersection(subLine.line); if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else &v1D = line.intersection(line.line);
if (includeEndPoints) <if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else <v1D = line.intersection(line.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) &/* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; &else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <v1D = line.intersection(subLine.line);
/* Get to the beginning of a new line. */ if (line.endsWith('&0')) &int i;
if (subLine.line!= subLine.line.subSpace) <v1D = (subLine.line!= subLine.line.subSpace)? v1D : null;
else if (includeEndPoints) <if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints && v1D) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) &v1D = null;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line == v1D) <if (includeEndPoints) v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
return v1D;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; else v1D = v1D;
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
v1D = line.intersection(subLine.line); if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; &else &v1D = v1D;
else if (includeEndPoints && v1D) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; <else <v1D = (VoidLine) subLine.line;
if (includeEndPoints) <return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) <SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
<else <if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if (includeEndPoints) &if (ioCluster) v1D = subLine.line.intersection(ioCluster); <else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; else &v1D = v1D;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) v1D = v1D; else <v1D = v1D;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) <v1D = v1D; <else <v1D = v1D;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) <nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (!eLeftLine) /* if subLine.line <= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; i&subLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret <0)? v1D : null;
else &v1D = line.intersection(subLine.line);
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
else &if (includeEndPoints) <if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
else if (line.get() == line.get()) return (loc1 == Location.INSIDE)? v1D : null;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
v1D = line.intersection(subLine.line); v1D = line.remainingRegion.checkPoint(line.toSubSpace(v1D)); if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null;
if (includeEndPoints) if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else <if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return v1D;
else if ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) <v1D = (VoidLine) subLine.line; &else <v1D = (VoidLine) subLine.line;
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i&subLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) <loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (i <0) <return (i++);
if (subLine.line) nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); else <v1D = subLine.remainingRegion.checkPoint(ioCluster);
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; &else &v1D = (VoidLine) subLine.line;
else <if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.LINE) && (loc2 == Location.LINE))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.mLineEndPoint) v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) &if (subLine.line) <loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
<else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) &SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
else if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else if (remainingRegion.checkPoint(line.toSubSpace(v1D))) <loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
else <if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
&else &if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else <if (includeEndPoints) &if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; else v1D = (VoidLine) subLine.line;
if (line == v1D) &if (includeEndPoints) v1D = (VoidLine) subLine.line; <else &v1D = (VoidLine) subLine.line;
else <if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else &if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i&subLine.line.width; i++) &SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* * A pointer to the map of a line of the sub-line object. It doesn't do it for each line of the sub-line object. */ if ((clone & '<0') == 0) &return ((clone & '0') == 0)? clone : null;
if (includeEndPoints) <if (!locationEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) &loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) <if (negativeLineLastLine == subLine.line) &v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
&else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; i<subLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) <if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret <0)? v1D : null;
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) &ret = (ret &0)? v1D : null;
return null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; isubLine.line.width; i++) SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
<else &if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (!eLeftLine) /* if subLine.line &= subLine.line.width = subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
else <if (subLine.line) <v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); &else <v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else </* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (includeEndPoints) return ((loc1 == Location.IN) && (loc2 == Location.IN))? v1D : null;
else <if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) &for (i=0; i<subLine.line.width; i++) SubLine line; &else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) &if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (i <0) &return (i++);
else <if (subLine.line) &v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (includeEndPoints) <if (ioCluster) <v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
else if (includeEndPoints) &if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len <0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) for (i=0; isubLine.line.width; i++) <SubLine line; <else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (includeEndPoints) <if (includeEndPoints) &if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
<else &v1D = line.intersection(subLine.line);
if (includeEndPoints) <ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret &0) <ret = (ret <0)? v1D : null;
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) <return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (line.compareToSignValues(line.find(line.find(line.s))) == -1) </* * XXX */ return (includeEndPoints && subLine.line.find(line.s) > -1)? (includeEndPoints && includeEndPoints && includeEndPoints) : null; else /* * This is a valid point but not used */ return (includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includeEndPoints && includes
if (line.mLineEndPoint) &v1D = line.intersection(subLine.line); loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); <else &v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
else if (includeEndPoints) if (subLine.line) loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); &else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) <if (!eLeftLine) /* if subLine.line &= subLine.line.width <= subLine.line.height) return eLeftLine; else /* if (includeEndPoints) return eLeftLine;
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); &else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; &else v1D = line.intersection(line.line);
if (line.endsWith("ptr")) if (!strlen(line.endsWith("ptr"))) <v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else v1D = line.intersection(line.line);
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INIDE) && (loc2 == Location.INIDE))? v1D : null;
if (line == v1D) &if (includeEndPoints) &v1D = (VoidLine) subLine.line; &else v1D = (VoidLine) subLine.line;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); &if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
#if defined(XP_MAC) || defined(XP_MACOSX) if (subLine.line.line.width > 0) <for (i=0; isubLine.line.width; i++) &SubLine line; else for (i=0; isubLine.line.height; i++) if (i[i].lineNumber == subLine.line.size) while ((line[i].line.width > 0) && (line[i].line.height > 0)) line[i].line.width = line[i].line.width; line[i].line.height = line[i].line.height; if (i[i].line.height > 0) if (i[i].line.height 0) line[i].line.height = line[i].line.height; else line[i].line.height =
if (includeEndPoints) ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret <0) ret = (ret &0)? v1D : null;
&else if (eResendDebug == eResendDebug) eResendDebug = eResendDebug; return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line == v1D) <if (includeEndPoints) &v1D = (VoidLine) subLine.line; else <v1D = (VoidLine) subLine.line;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; &else v1D = v1D;
if (includeEndPoints) &ret = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (ret 0) ret = (ret <0)? v1D : null;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) &if (includeEndPoints) <if (remainingRegion.checkPoint(line.toSubSpace(v1D)) == null) &loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else loc1 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); else loc2 = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D));
if (includeEndPoints && subLine.line.len <0) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) <v1D = v1D; &else v1D = v1D;
&else if (includeEndPoints && includeEndPoints >= 0) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (subLine.line) <nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints && subLine.line.len &0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
&else
if (includeEndPoints) <if (ioCluster) &v1D = subLine.line.intersection(ioCluster); <else &v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) &nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (line.endsWith("ptr")) &if (!strlen(line.endsWith("ptr"))) &v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; else &v1D = line.intersection(line.line);
else if (includeEndPoints) &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; &else if (includeEndPoints) &return ((loc1 == Location.INF) && (loc2 == Location.INF))? v1D : null;
else &if (includeEndPoints) <return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else <return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (loc1 == Location.LINE) if (loc2 == Location.LINE) &v1D = v1D; else <v1D = v1D;
if (negativeLineLastLine == subLine.line) &if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
#endif
if (loc1 == Location.LINE) <if (loc2 == Location.LINE) &v1D = v1D; &else &v1D = v1D;
if (subLine.line) nv = line.intersection(subLine.line); if (nv) &nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
if (includeEndPoints) return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
<else <if (includeEndPoints && includeEndPoints >= 0) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; <else return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
else &if (subLine.line) v1D = line.intersection(subLine.line); v1D = subLine.remainingRegion.checkPoint(line.toSubSpace(v1D)); <else v1D = line.intersection(subLine.line); v1D = line.intersection(subLine.line);
else v1D = line.intersection(subLine.line);
if (loc1 == Location.LINE) &if (loc2 == Location.LINE) v1D = v1D; else <v1D = v1D;
if (negativeLineLastLine == subLine.line) if (negativeLineLastLine == subLine.line) <v1D = line.intersection(subLine.line); if (lline.remainingRegion &&!lline.remainingRegion.checkPoint(line.toSubSpace(v1D))) &v1D = line.intersection(subLine.line); <if (lline.remainingRegion &&!lline.remainingRegion) v1D = line.intersection(subLine.line);
if (includeEndPoints) if (ioCluster) v1D = subLine.line.intersection(ioCluster); &else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (includeEndPoints) return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null; else &return ((loc1 == Location.OUTSIDE) && (loc2 == Location.OUTSIDE))? v1D : null;
if (line.endsWith("ptr")) <if (!strlen(line.endsWith("ptr"))) v1D = (includeEndPoints*) line.len + line.len; else v1D = (includeEndPoints*) line.len; <else v1D = line.intersection(line.line);
/* XXX - XXX - XXX */ if (remainingRegion && subLine.line) if (includeEndPoints) return ((loc1!= Location.OUTSIDE) && (loc2!= Location.OUTSIDE))? v1D : null; <else &return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE))? v1D : null;
if (includeEndPoints) if (ioCluster) <v1D = subLine.line.intersection(ioCluster); <else v1D = subLine.remainingRegion.checkPoint(ioCluster);
if (subLine.line) &nv = line.intersection(subLine.line); if (nv) nv = line.intersection(subLine.line); nv = line.intersection(subLine.line); if (nv) <nv = line.intersection(subLine.line); if (nv!= nv) nv = line.intersection(subLine.line); else nv = line.intersection(subLine.line); nv = line.intersection(subLine.line);
