golden:
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
inference:

case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n, n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n, variable);
case Token.HOOK:
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, 0);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild());
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), &variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token_HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: break;
case Token.LOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.COOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n, n.getLastChild(), variable);
default: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token_HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
default: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(child, variable);
case Token.OPEN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n, n.getFirstChild(), n.getLastChild(), variable);
case Token.LOCK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.COOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND:
case Token.HOOK : return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOKEN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable.get());
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), variable);
case Token.HOOK: return CheckHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.BOOLEAN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(&n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOKEN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getLastChild(), variable);
case Token.HOOK: result = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR:
case Token.HOOK : return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n);
default: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.READ: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.MOUSE: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill((n.getFirstChild().getNext()), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), &n.getLastChild(), variable);
case Token.LOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACTIVE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable );
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable, 0);
default: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild());
case Token.ON: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ON: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.MOUSE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OBJECT: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild());
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, 1);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
break;
case Token.HOOK: return checkHookBranchReadBeforeKill(v, n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.AND: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ASSIGN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.AND: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NONE: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild());
case Token.READ: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), &variable);
checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ASSIGN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCESS: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, variable);
case Token.NONE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable, false);
case Token.HOR: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.MODE: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.MODE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, value);
case Token.ACTIVE: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCESS: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.BOOLEAN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OFF: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SHOW: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTION: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.THREAD: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SOFT: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.UNKNOWN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: result = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ALL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case TOKEN_HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTION: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.BOOL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(child, n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), variable, n.getLastChild());
case Token.INVALID: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, flags);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, -1);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), 0, variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, null);
case Token.HOP: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SHOW: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.RETURN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(&n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.firstChild.getNext(), n.firstChild.getLastChild(), variable);
case Token.LOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.OBJECT: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable, true);
case Token.HOOK: return checkHookBranchReadBeforeKill((n.getFirstChild().getNext()), (n.getLastChild(), variable));
case Token.INVALID: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.FOUND: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.CHANGE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), value);
case Token.HOOK: return checkHookBranchReadBeforeKill(value, n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.false: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable));
case Token.NO_HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(firstChild, n.getLastChild(), variable);
case Token.HOOK:  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(child.getFirstChild().getNext(), child.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.firstChild.getNext(), n.getLastChild(), variable);
case Token.HOR: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, false);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().GetNext(), n.getLastChild(), variable);
case Token.LOCALE: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SOFT: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), getLastChild(), variable);
case Token.ARENA: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.FOUND: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case TOKEN_HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OFF: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OWN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.BACKGROUND: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HIOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), &n.getLastChild(), variable);
case Token.SUCCESS: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ALL: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOP: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, state);
case Token.LOAD: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.UNKNOWN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, type);
case Token.BODY: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SOCK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK:  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OW: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return CheckHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable.get());
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild(), n.getLastChild(), variable);
case Token.OWN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(variable, n.getFirstChild().getNext());
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, parent);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext( ), n.getLastChild( ), variable);
case Token: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK : return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable );
case Token.BOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(n).getNext(), n.getLastChild(n), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), variable);
result = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); break;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(n), n.getLastChild(n), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), (void **)n.getLastChild(), variable);
case Token.OK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild().get(), variable);
case Token.OR: break;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, v);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.firstChild, n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, true);
case Token.HOOK: return checkHookBranchReadBeforeKill(rhs, variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, 1);
case Token.BOOL: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, name);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), Variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), v);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, this);
case Token.LOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, 0);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, value);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getLastChild(), variable, n.getFirstChild());
case Token: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild());
case Token.COMPLETE_HOUR: if (n.getFirstChild().getNext() == n.getLastChild()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, aHasLastChild());
case Token.HAOK: if (VarTerm)  n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  else  n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes())  preconditions.checkState(n.getParent().getType() == Token.ASSIGN);  if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;  else  return VariableLiveness.READ;
case Token.NO_SUCCESS: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.FORWARD_COPY: case Token.MODE_COPY: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, aValue);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getGenericHandle());
case Token.LOCAL_ARGS:  case Token.POINTER:  if (n.getLastChild()!= n.getFirstChild().getNext())  break;   if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;   switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;    else  switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, getter_AddRefs(value));
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild()))  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext())  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &mFrameLetter);
case Token.COMPARISON_HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &n.isNonChildToKill());
case Token.LOCAL: case Token.HOOK:  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  return VariableLiveness.MODIFY_VARIABLE;  else  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE)  return state;   else  return VariableLiveness.MODIFY_VARIABLE;   switch (n.getType())  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  VariableLiveness state = isVariable
case Token.OR: case Token.AND: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PTH: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0)  n.getFirstChild().getNext() = n.getLastChild();  else  n.getFirstChild().getNext() = n.getLastChild();  else  n.getLastChild() = n.getLastChild();
case Token.DOUBLE_CONTENT: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.VOLUNT: case Token.HINO: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: case Token.OR: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.HI: case Token.HI: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_SEARCH_FORCE: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &elt);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, n.getLastChild());
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.MOUSE)  return state;  return VariableLiveness.MOUSE;  else  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.MOUSE)  return state;   else  return VariableLiveness.MOUSE;  else  return VariableLiveness.MOUSE;   else    switch (n.getType())  case Token.OR
case Token.SINK_AR: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HORIZONTAL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &n.getLastChild());
case Token.OK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getFirstChild());
case Token.HWX: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.OR: case Token.AND:
case Token.ISO: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.DO_NO_COUNT: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0)  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);  else  if (variable.getLength() > 0)  if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN)  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);  if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child)))  CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness
case Token.SOFT_PRINT: if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext() == 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getFirstChild());
case Token.ACC_IGN: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PATCH: case Token.OTH: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.COMPARISON: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, (int) n.getLastChild());
case Token.ARR_LOAD: if (n.getFirstChild().getNext() == n.getLastChild()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, variable.get());
case Token.OR: case Token.AND: case Token.READ: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.THRUDE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild()))  CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);  else  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnt
case Token.TOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &value);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &rhs);
case Token.IsEndOfClass: case Token.OR: case Token.AND: case Token.TOKEN_XUL: case Token.IS_FROM_CTYPE: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, isFrame);
case Token.NO_WATCH: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, 0);
case Token.NO_VTY: case Token.HOOK:  if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild())  if ((n.getParent() == n.getParent()) && variable == n.getParent())  if ((n.getParent() == n.getParent()) && variable == n.getParent())  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.READ)  return state;   else  return VariableLiveness.READ;     switch (n.getType())
case Token.NO_PRIMARY_POLLING: case Token.HOOK: case Token.OR: case Token.AND: case Token.NO_PRIMARY_POLLING: case Token.H: if (NS_SUCCEEDED(CheckHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)))  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCES: if (n.getChildCount() > 0)  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, (void *)&n.getLength());
case Token.HAK_TRANSFER: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.READ:  n.getChildAt(n.getFirstChild()); case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.OR: case Token.END: case Token.CXX: case Token.HAS_CR: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK:  /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  if (NodeUtil.isLhs(n, n.getParent()))  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);  VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;  else  return VariableLiveness.READ;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getChildCount());
case Token.OR: case Token.ALL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.INVALID: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent())  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;  switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  return VariableLiveness.READ;
case Token.MOUSE_IN_PROTO: case Token.MOUSE_DEBUG: case Token.MOUSE_NEXT: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.OR: case Token.AND: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  return VariableLiveness.KILL;  else  return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild())  preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;
case Token.OR: case Token.MODIFIER: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: case Token.NO_HOOK: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTION: case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, false);
case Token.OR: case Token.AND: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.READ)  return state;  return VariableLiveness.KILL;  else  return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND:  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;  else  return VariableLiveness.READ;   switch (n.getType())  case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPENS: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable, n.getType());
case Token.REFLOW: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO_SECTION: case Token.NO
case Token.OR: case Token.AND: case Token.AND: case Token.ORE: case Token.AND: case Token.END: case Token.RE: case Token.ARE: case Token.R: case Token.C: case Token.T: case Token.P: case Token.RE: case Token.RE: case Token.PR: case Token.RE: case Token.C: case Token.N: case Token.MO: case Token.MO: case Token.MO: case Token.HOOK: case Token.DO: case Token.LOOK: case Token.MO: case Token.MO: case Token.MA: case Token.MO: case Token.RO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case Token.MO: case
case Token.MODIFICATION_COMPLETION_TYPE: case Token.MODIFICATION_COMPLETION_TYPE: case Token.MODIFICATION_COMPLETION_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_TYPE: case Token.MODIFICATION_YPECTING_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_XPECTING_TYPE: case Token.MODIFICATION_YPECTING_TYPE: case Token.MODIFICATION_YPECTING_TYPE: case Token.MODIFICATION_YPECTING_TY
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, n.getChildCount() - 1);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, aNewNonLastChild);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;  else  return VariableLiveness.READ;   switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, &return);
case Token.NO_CUR: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, variable );
case Token.SOFT: case Token.SOFT: case Token.OK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable, &aDirty);
case Token.NO_WINDOW:  if (isDebugChild(child))  CheckChildRow(&child.child, n.getFirstChild());  else  checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)))  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);  if (strcmp(n.getFirstChild(), "NODE")!= 0)  n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else  n.getLastChild() = n.
case Token.DOCUMENT: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getLastChild());
case Token.Arena: case Token.DOCUMENT: case Token.DOCUMENT: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HIOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getParent());
case Token.HOOK:  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  else  return VariableLiveness.READ;
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, n.getParent());
case Token.POPUP: case Token.HAOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, true);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, a.getParent());
case Token.OPTION: case Token.POINT: case Token.HOOK: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, 0);
case Token.IsEnabled: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, 0, 1);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), n.getFirstChild(), variable, &rhs);
case Token.BOOLEAN: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, &n.getFirstChild());
case Token.HOOK:  if (!ControlFlowGraph.isDebugChild(child))  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.NO_MOUSE: case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (v3) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK:  n.firstChild.GetNext() = checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable); break;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getFirstChild());
case Token.POLLING: case Token.SOOP: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  switch (n.getType())  case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND:  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;  return VariableLiveness.READ
case Token.COMPLETE_OPERATOR_SET: case Token.COMPLETE_OPERATOR_SET: case Token.COMPLETE_OPERATOR_SET: case Token.COMPLETE_OPERATOR_SET: case Token.COMPLETE_NO_REFERENCE_SET: case Token.COMPLETE_NO_REFERENCE_SET: case Token.COMPLETE_NO_REFERENCE_SET: case Token.COMPLETE_NO_REFERENCE_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_REFERENCE_SET: case Token.COMPLETE_REFERENCE_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_REFERENCE_SET: case Token.COMPLETE_RESULT_SET: case Token.COMPLETE_RE
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, &variable);
case Token.HAOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, getter_AddRefs(variable));
case Token.OPTION: case Token.OR: case Token.AND: case Token.READ: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.VOLARIABLE_HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getFirstChild(), n.getLastChild());
case Token.OPEN: case Token.DIAL: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.READ: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  return state;
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, checkState(n.getParent().getType()));
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), &variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getParent());
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child))  switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PRUint32: case Token.LAST: case Token.CULTURE_DECIMAL: case Token.OR: case Token.PRUint32: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SORT: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.NO_LOCK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.MOUSE: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, true);
case Token.ISO-8859-1: if (n.getType() == Token.NOT)  n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else  n.getLastChild().GetLastChild() = n.getLastChild(); break;  case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst())  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK:  if (n.isNode())  n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break;  else  n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break;  if (variable == variable)  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (state == VariableLiveness.READ)
case Token.PAR_HAS_CHOICE: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))  return n.getFirstChild();
case Token.OR: case Token.BOR: case Token.ADD: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HIOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), &variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext())  if (prev)  n.getFirstChild().getNext() = n.getFirstChild(); else  n.getLastChild() = n.getLastChild();   return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PLAY: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SH_R: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.IsVariable: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  break;   else  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, aNewChild);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getString());
case Token.OR: case Token.AND: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, 0);
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable, n.getAssignment());
case Token.NO_ROUTING: if (n.getLastChild()  0)  case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK:  if (n.getFlags() == Token.THR_TO_CHANGE)  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);  else  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;  switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_OWN: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable, isCurrentNode);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n))  return n;  else  if (!ControlFlowGraph.isDebugEnabled(n))  if (n.GetConflictType() == Token.ASSIGN)  Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  return VariableLiveness.READ;  else  return VariableLiveness.READ;   switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.MOUSE: case Token.NO_MOUSE: case Token.SHOOK: case Token.MOUSE: case Token.OR: case Token.MOUSE: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK:  if (v3)  if (v3)  v3 = v3; v3 = v3; v3 = v3;  else  v3 = v3; v3 = v3;  if (v3)  v3 = v3;    if (v3)  v3 = v3; v4 = v3;   if (v3)  v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3;  else  v4 = v3;  v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild())  switch (n.getType())  case Token.HOOK:  if (n.getParent().getType() == Token.ACCESS)  case Token.HOOK:   if (n.getParent().getType() == Token.CUR_NO_PRINTER)  return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);    if (NodeUtil.isLhs(n, n.getParent()))  Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  if (!ControlFlowGraph.isEnteringNewCfgNode(child))  VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ)  return state;  else  return VariableLiveness.READ;   switch (n.getType())  case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else <return VariableLiveness.READ;
case Token.READ: &n.getChildAt(n.getFirstChild()); case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else <return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: <n.firstChild.GetNext() = checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable); break;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.READ;
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else &return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_ROUTING: if (n.getLastChild() &0) <case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else <return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PAR_HAS_CHOICE: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) return n.getFirstChild();
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else &return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: n.firstChild.GetNext() = checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable); break;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else <return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else &return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else <return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_ROUTING: if (n.getLastChild() 0) &case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else &return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else &return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else <return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_PRIMARY_POLLING: case Token.HOOK: case Token.OR: case Token.AND: case Token.NO_PRIMARY_POLLING: case Token.H: if (NS_SUCCEEDED(CheckHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else <return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_ROUTING: if (n.getLastChild() 0) <case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else &return VariableLiveness.READ;
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_ROUTING: if (n.getLastChild() 0) case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else <return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else <return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else <return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else <return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.NO_PRIMARY_POLLING: case Token.HOOK: case Token.OR: case Token.AND: case Token.NO_PRIMARY_POLLING: case Token.H: if (NS_SUCCEEDED(CheckHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else &return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else &return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else <return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: case Token.OR: case Token.AND:
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else <return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else &return VariableLiveness.READ;
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else &return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.READ: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: &n.firstChild.GetNext() = checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable); break;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else &return VariableLiveness.READ;
case Token.NO_PRIMARY_POLLING: case Token.HOOK: case Token.OR: case Token.AND: case Token.NO_PRIMARY_POLLING: case Token.H: if (NS_SUCCEEDED(CheckHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable))) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else &return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NO_ROUTING: if (n.getLastChild() &0) &case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else &return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else &return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else <return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.PAR_HAS_CHOICE: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <return n.getFirstChild();
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else <return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else <return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &<else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else &return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.PAR_HAS_CHOICE: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &return n.getFirstChild();
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else return VariableLiveness.READ;
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else return VariableLiveness.READ;
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_ROUTING: if (n.getLastChild() <0) &case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: case Token.HI: case Token.HI: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else <return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else <return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.NO_WINDOW: if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else &return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else <return VariableLiveness.READ;
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_WINDOW: <if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else <return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.NO_ROUTING: if (n.getLastChild() <0) <case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.TOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.AND: case Token.HIGH: case Token.HASH: case Token.OR: case Token.HIGH: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else &return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.ACCES: if (n.getChildCount() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_WINDOW: if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ;
case Token.ISO-8859-1: if (n.getType() == Token.NOT) n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; &case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else <return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.READ: n.getChildAt(n.getFirstChild()); case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else <checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else return VariableLiveness.READ;
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else <return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; &<else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; &else &return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.READ: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state;
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_WINDOW: &if (isDebugChild(child)) &CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.LOCAL_ARGS: case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCAL_ARGS: &case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) <break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); &else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) <case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); <else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else return VariableLiveness.READ;
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: /* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.MOUSE) &return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_WINDOW: <if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ;
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: <if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.NO_WINDOW: &if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: <if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) <v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else <if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else return VariableLiveness.READ;
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; &return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else n.getLastChild().GetLastChild() = n.getLastChild(); break; case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else &return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: <if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) &case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_ROUTING: if (n.getLastChild() <0) case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; <return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.NO_WINDOW: if (isDebugChild(child)) <CheckChildRow(&child.child, n.getFirstChild()); <else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <else <return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.isNode()) &n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; else n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) <case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ;
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.LOCAL_ARGS: &case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: </* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; &<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; <else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; &else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <&else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.NO_WINDOW: <if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); &else checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.READ: <n.getChildAt(n.getFirstChild()); case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild(), n.getLastChild(), variable);
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else &return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HAOK: if (VarTerm) n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: <if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HAOK: if (VarTerm) <n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HAOK: if (VarTerm) &n.getFirstChild().getNext() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <n.getLastChild() = checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) <if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else n.getLastChild() = n.getLastChild(); <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: <if (n.getFlags() == Token.THR_TO_CHANGE) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.ACCES: if (n.getChildCount() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else <return VariableLiveness.READ;
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) &n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) break; <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.MOUSE) return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <return state; else &return VariableLiveness.READ;
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; <return VariableLiveness.MOUSE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else <return VariableLiveness.READ;
case Token.HOOK: <if (!ControlFlowGraph.isDebugChild(child)) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; <return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; <else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; &else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; &else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; <return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.NO_VTY: case Token.HOOK: <if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; <else &if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) &return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.HOOK: if (variable.getLength() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else if (variable.getLength() > 0) if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else <return VariableLiveness.READ;
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &&else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; <else return VariableLiveness.READ;
case Token.HOOK: &if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else <n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &break; <&else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) switch (n.getType()) &case Token.HOOK: &if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.ISO-8859-1: if (n.getType() == Token.NOT) <n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else <n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (!ControlFlowGraph.isDebugChild(child)) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) <n.getFirstChild().getNext() = n.getFirstChild(); else <n.getLastChild() = n.getLastChild(); &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.READ: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state;
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; &else if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) n.getFirstChild().getNext() = n.getLastChild(); else &n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) &CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (state == VariableLiveness.READ) <return state; return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild() == n.getFirstChild())) <CheckFlowDialog(ControlFlowGraph, "GetPseudoDialog", "Note: VariableLiveness", n.getFirstChild()); return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnt
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (n.getFirstChild().getNext()) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; else return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: if (variable.getLength() > 0) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else &if (variable.getLength() > 0) <if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.NO_VTY: case Token.HOOK: &if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if ((n.getParent() == n.getParent()) && variable == n.getParent()) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) <case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: case Token.POINTER: case Token.POPINTER: if (n.getFirstChild().getNext()) &if (prev) n.getFirstChild().getNext() = n.getFirstChild(); else &n.getLastChild() = n.getLastChild(); return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.ISO-8859-1: if (n.getType() == Token.NOT) &n.getFirstChild().GetFirstChild().GetLastChild() = n.getFirstChild().GetNext(); else &n.getLastChild().GetLastChild() = n.getLastChild(); break; <case Token.HOOK: return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.NO_WINDOW: &if (isDebugChild(child)) CheckChildRow(&child.child, n.getFirstChild()); else &checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: &if (n.isNode()) n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.OR: case Token.PLAY: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.NUM: case Token.MULTI: case Token.VARIABLE_MODULE: case Token.NO_LITERAL: case Token.PENDING: case Token.MODULE: case Token.OPEN: case Token.NO_LEFT: case Token.MODITION: case Token.MODITION: case Token.MODI
case Token.HOOK: <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) <if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; &return VariableLiveness.READ;
case Token.HOOK: if (variable.getLength() > 0) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else <if (variable.getLength() > 0) &if (NodeUtil.isName(n) && variable.getParent().getType() == Token.ASSIGN) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (NS_FAILED(CheckFlowGraph.isEnteringNewCfgNode(child))) CheckFlowGraph.isEnteringNewCfgNode(child)); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); &if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.SIZE_POINTER: if (n.getFirstChild().getNext()!= n.getFirstChild().getFirst()) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: <case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) break; &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else n.getFirstChild().getNext() = n.getLastChild(); else n.getLastChild() = n.getLastChild();
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.KILL; &else return VariableLiveness.READ;
case Token.OK: if (checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) return state; &return VariableLiveness.KILL; else return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; &else <return VariableLiveness.READ;
case Token.LOCAL: case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) <return state; return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.HOOK: if (n.getFirstChild().getNext()) &return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); &else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!ControlFlowGraph.isDebugChild(child)) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) <switch (n.getType()) case Token.HOOK: <if (n.getParent().getType() == Token.ACCESS) <case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; &else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: &if (n.getFlags() == Token.THR_TO_CHANGE) &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if ((n.getFirstChild().getNext()!= n.getFirstChild()) && (n.getLastChild()!= n.getFirstChild())) <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); &else &return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_VTY: case Token.HOOK: if ((n.getFirstChild().getNext() == 0) && variable == n.getLastChild()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) if ((n.getParent() == n.getParent()) && variable == n.getParent()) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType())
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; &else &return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.ACCES: if (n.getChildCount() > 0) return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); <else return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <if (n.getParent().getType() == Token.ASSIGN) return n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &return VariableLiveness.READ; else switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.TOK: case Token.OR: case Token.AND: case Token.MOUNT: case Token.PROT_DEFAULT: case Token.PROT_NORM: case Token
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; &<else return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_CIRCLE: case Token.HOOK: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.AND: case Token.ON: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) &return state; &return VariableLiveness.MOUSE; <else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.MOUSE) return state; else return VariableLiveness.MOUSE; else return VariableLiveness.MOUSE; else switch (n.getType()) case Token.OR
case Token.POINTER: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &switch (n.getType()) case Token.OR: case Token.AND: case Token.OR: case Token.OR: case Token.AND: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; return VariableLiveness.READ
case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.KILL; <else return VariableLiveness.READ;
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) &case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else &n.getLastChild() = n.
case Token.LOCAL: case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; &return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else <n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.HOOK: if (!checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.ALL: case Token.NO_LOCK: case Token.ON: case Token.OR: case Token.NOR: case Token.OR: case Token.NOR: case Token.TH: case Token.END: case To
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) &return state; <else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.HOOK: if (n.isNode()) <n.getFirstChild().getNext(); n.getLastChild(); variable = ((n.getNext()).mChild).mChild; break; &else &n.getFirstChild().getNext() = n.getLastChild(); variable = ((n.getLastChild().mChild).mChild); break; if (variable == variable) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (state == VariableLiveness.READ) <unk>
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); if (strcmp(n.getFirstChild(), "NODE")!= 0) <n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else n.getLastChild() = n.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OR: case Token.AND: if (isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: if (v3) &if (v3) &v3 = v3; v3 = v3; v3 = v3; <else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) if (v3) &v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.HOOK: /* * Check for a different name of a variable from the list of first objects. The n.firstChild has a state for the variable. */ if (isVariableLhs(n.getFirstChild(), n.getLastChild()) &&!(v = checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable))) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (strcmp(n.getFirstChild(), "NODE")!= 0) &n.getFirstChild().getNext() = n.getFirstChild(); n.getLastChild() = n.getLastChild(); else <n.getLastChild() = n.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.LOCK: case Token.ACCESS: if (n.getFirstChild().getNext() == n.getLastChild()) &switch (n.getType()) &case Token.HOOK: if (n.getParent().getType() == Token.ACCESS) case Token.HOOK: if (n.getParent().getType() == Token.CUR_NO_PRINTER) return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable); if (NodeUtil.isLhs(n, n.getParent())) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (
case Token.LOCAL: case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; return VariableLiveness.MODIFY_VARIABLE; else if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.MODIFY_VARIABLE) return state; else return VariableLiveness.MODIFY_VARIABLE; switch (n.getType()) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariable
case Token.HOOK: if (!checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable)) Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; &else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.NO: case Token.ASS: case Token.NOR: case Token.AND: case Token.AND: case Token.OR: case Token.ON: case Token.OFF: case Token.
case Token.OR: case Token.AND: if (n.getParent() == n.getParent()) <Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else &return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.HOOK: case Token.OH: case Token.HOOK: case Token.CH: case Token.OH: case Token.HOOK: case Token.HOOK: case Token.OR: case Token.H: case Token.HOOK: case Token.PROBIN: case Token.OR: case Token.HOOK: case Token.OR: case Token.HOOK: case Token.TO
case Token.LOCAL_ARGS: <case Token.POINTER: <if (n.getLastChild()!= n.getFirstChild().getNext()) <break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) &n.getFirstChild().getNext() = n.getLastChild(); <else &n.getFirstChild().getNext() = n.getLastChild(); <else n.getLastChild() = n.getLastChild();
case Token.NORMAL: if (!isVariableReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) <break; <else <return checkHookBranchReadBeforeKill( n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.LOCAL_ARGS: &case Token.POINTER: if (n.getLastChild()!= n.getFirstChild().getNext()) &break; <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.PROP: case Token.READ: if (strcmp(aEmptyString, "")!= 0) <n.getFirstChild().getNext() = n.getLastChild(); else <n.getFirstChild().getNext() = n.getLastChild(); &else n.getLastChild() = n.getLastChild();
case Token.HOOK: <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; else &return VariableLiveness.READ;
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) <preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; else <return VariableLiveness.READ;
case Token.OPTIMIZED: case Token.HOOK: case Token.HOOK: &if (v3) &if (v3) v3 = v3; v3 = v3; v3 = v3; else v3 = v3; v3 = v3; if (v3) v3 = v3; if (v3) v3 = v3; v4 = v3; if (v3) v3 = v3; v3 = v3; v3 = v3; v3 = v3; v4 = v4; v4 = v3; else v4 = v3; v4 = v3; v4 = v3; v6 = v4; v5 = v3; v4 = v3; v4 = v3; v5
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.REFERENCE: case Token.DO: if ((aNodeUtil.isVariable(n, aNodeUtil)) == n.getFirstChild()) preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) <return state; <else <return VariableLiveness.READ;
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) <return n; else &if (!ControlFlowGraph.isDebugEnabled(n)) &if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.OPEN: if (!ControlFlowGraph.isRecorded(n)) return n; <else <if (!ControlFlowGraph.isDebugEnabled(n)) <if (n.GetConflictType() == Token.ASSIGN) Preconditions.checkState(n.GetParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.AND: case Token.AND: case Token.OR: case Token.MOON: case Token.MOON: case Token.OR: case Token.MOON: case Token.
case Token.NO_FOCUS: if (n.getChildNodes() && n.getChildNodes()) &preconditions.checkState(n.getParent().getType() == Token.ASSIGN); <if (Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); case Token.NO_LAST: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) <if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ; <unk>
case Token.HOOK: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &return state; else return VariableLiveness.READ;
case Token.LOCAL_ARGS: case Token.POINTER: &if (n.getLastChild()!= n.getFirstChild().getNext()) &break; if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) if (!ControlFlowGraph.isEnteringNewCfgNode(child)) VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.AND: case Token.AND: case Token.OR: case Token.AND
case Token.HOOK: &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) return state; <else <return VariableLiveness.READ;
case Token.STOCK: case Token.NOR: case Token.AND: case Token.OR: case Token.AND: if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (!ControlFlowGraph.isEnteringNewCfgNode(child)) &if (state == VariableLiveness.READ) &return state; return VariableLiveness.READ; else return VariableLiveness.READ; switch (n.getType()) case Token.OR: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.AND: case Token.OR: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.MOUSE: case Token.
case Token.HOOK: &/* Check whether the 't' check for n.getFirstChild().getNext() should be */ if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) if (!CheckHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable)) &if (NodeUtil.isLhs(n, n.getParent())) &Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) return state; return VariableLiveness.READ; else return VariableLiveness.READ;
case Token.HOOK: if (n.getFirstChild().getNext()) <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); &else <return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
case Token.NO_ROUTING: if (n.getLastChild() &0) case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);
