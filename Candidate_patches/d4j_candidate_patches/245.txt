golden:
return false;
inference:
return false;
return true;
return false;

return (false);
return false;
goto out;
return true;
return true;
return (false);
return (0);
goto done;
return result;
return 0;
return false; break;
goto cleanup;
return ret;
return true;
break;
return canInline;
return false;
return isFunction;
return false;  return false;
result = false;
return -1;
goto fail;
return false; return false;
return (error);
return(false);
return false; */
return 1;
goto ret;
goto bad;
return (false);
return rv;
return false; goto out;
ret = false;
return false;  else return false;
return false; return true;
return false; #endif
#endif return false;
return DEBUG;
return (true);
return;
return DEBUG_ERROR;
return false;  return true;
return (true);
return (false);
return DEBUG_ERR;
return DEPRECATED_FAILURE;
return retval;
return false; goto done;
goto loser;
return false; return 0;
return(false);
return false;  else  return false;
return error;
return (1);
return flags;
goto end;
return false;  break;
return (failed);
return (-1);
return false; goto cleanup;
return DebugFailure;
error = false;
return DEBUG_FAILURE;
return RETURN_FALSE;
return false;  #endif
else return false;
return REPORT_FAILURE;
return false; return (0);
goto exit;
return false; return false;
return isValid;
*/ return false;
return status;
return, false;
return false;  return 0;
return (true);
return PZ_FALSE;
return (FAILURE);
else  return false;
return NS_OK;
goto error;
return RETURN_FAILURE;
return def.isAssign();
return false;  */
return DEVICE_FAILURE;
return def;
return false ATTRIBUTE_UNUSED;
return null;
return EIF_FALSE;
return x;
goto overflow;
return false; goto ret;
goto delete;
return false; goto fail;
return (def == null);
result = false; return result;
continue;
ret = false; return ret;
return false;  else
returnFalse;
return DEF_FAILURE;
returnTrue;
goto err;
return DEBUG_RETURN;
return false; ;
*return false;
goto getDefinition();
error = false; goto out;
return false;   return false;
return EINVAL;
return DEBUG_DEBUG;
goto failed;
rv = false;
return DEF_OK;
return CFG_FAILURE;
return false; */ return false;
return (DEBUG_ERR);
return EIF_TRUE;
return Cancelled;
return false, false;
return
return(false);
return null;
return false; else return false;
return false; return -1;
return false; return true;
return deferred;
return inline;
return false? false : false;
return DEPRECATED_SUCCESS;
return false;  return result;
goto return false;
return PR_FAILURE;
return (null);
result = false; break;
return super.canInline();
return return false;
return false;*/
return canInline:
return def.isFunction();
return false;;
return DEF_FALSE;
goto retval;
return this;
return EIF_FAILURE;
return bool;
return DEF_TRUE;
return (ret);
return false; continue;
return = false;
return false; goto bad;
return isInline;
return DEBUG_ERRNO;
return (def == null);
return false; goto end;
return DEBUG_ARG;
return false;  return -1;
return false;  return canInline;
return false;  return (0);
return deprecated_result;
#endif
retval = false;
return false;  gotDefinition();
return (DEPRECATED_ERR);
return DEPRECATED_DEBUG;
return (def!= null);
return false; return canInline;
return DEPRECATED_REFLOW;
return false;  goto out;
return false; #endif return false;
return false;  */ return false;
return DEPRECATED_ERR;
return DEPRECATED_ERROR;
return false;  else  break;
return false; #ifdef DEBUG
return DEPRECATED_ARG;
return (def.isAssign());
return DEPRECATED_RETURN;
return false;  /* XXX - XXX */
return false;  /* * The value can be thrown into the list of dependencies, so check for any dependency at the end of the list. */ return false;
return false;  /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee)  if (needDirty)  if (sysCallbacks &&!sysCallbacks.flags)  sysCallbacks.flags = false; goto out;
return false;  if (def == b)  return false;  if (def == null)  return false;
return false;  else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;
return false;  else  if (nodeUtil.isExprAssign(def.getParent()))  return false;
return false;  if (getDefCfgNode().isFunction())  if (inlinedNewDependencies.contains(dependency))  return false;   getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false;  else  /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  if (CheckRightOf(use, useCfgNode, SIDE_EF
return false;  else  /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;
return false;  if (def.isFunction())  return false;
return false;  else  if (getDefCfgNode().isCanceled())  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNew
return false;  else  for (Var dependency : defMetadata.depends)  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  return false;   getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null)  return false;
return false;  if (!DependentDefined ||!GetDependentDefined(def))  if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer)  if (Debug.saveChildren)  if (Debug.saveChildren) return false;  if (Debug.saveChildren)  if (Debug.saveChildren) return false;   if (Debug.saveChildren) return false;  if (Debug.saveChildren) return false;  if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false;  if (nioRes)  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  return false;   else  return false;
return!def.isAssign();
return (DEBUG_DEBUG_PREF_WARNING);
return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;
return false;   return canInline;
return false;  else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false;  /* do a load on the map */
return false;  /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends)  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  return false;   return false;   if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def == null)  return false;  if (def.isAssign() &&!NodeUtil.
return (def.isFunction());
return false;  if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  return false;  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  return false;   return false;
return false;  if (useCfgNode)  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false;  else  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;
return false;  if (def)  x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  return false;   if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  return false;   if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  return false;
return false;  if (isContaining())  GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null)  return false;
return false;  else  if (id.IsEmpty())  if (inlinedNewDependencies.contains(dependency))  if (id.IsEmpty())  if (id.IsEmpty())  if (inlinedNewDependencies.contains(dependency))  return false;   if (id.IsEmpty())  if (def == null)  return false;   if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;   if (checkLeftOf(def, getDefCfgNode()
return false;  if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  return false;
return false;  if (isDebug())  return false;
return false;   if (DebugFinish)  if (inlinedNewDependencies.contains(dependency))  if (inlinedNewDependencies.contains(dependency))  return false;  if (def == null)  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;  if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false;  /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */
return false;  else if (def == null)  return false;
return false;  /* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))  return false;
return false;  else  if (null == b)  b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  return false;    else if (null == b)  return false;  if (null == b)  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE))  return false;  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE))  return false;  if (null == b)  return false;  if ((null == b) && (null == b) && (null == b) && (

return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &if (isDebug()) &return false;
return false; &else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false;
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; if (def == b) &return false; <if (def == null) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else <if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; <<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (def == b) <return false; <if (def == null) return false;
return false; <#endif
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
&else <return false;
return false; <if (def == b) <return false; <if (def == null) &return false;
return false; <else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <*/
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else &if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; <else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (def == b) return false; if (def == null) <return false;
return false; &;
return false; else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else if (def == null) &return false;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &*/ return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
<else <return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <<return canInline;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <&return false;
return false; &else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def == b) return false; <if (def == null) &return false;
return false; <if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (def == b) <return false; <if (def == null) return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; */ return false;
return false; else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
<return false;
&else &return false;
return false; &<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; else if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; &else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else <return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (def == b) &return false; if (def == null) return false;
return false; &else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (def == b) &return false; &if (def == null) <return false;
return false; /* * The value can be thrown into the list of dependencies, so check for any dependency at the end of the list. */ return false;
return false; &else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &if (def == b) &return false; <if (def == null) return false;
return false; <else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
&return false; return false;
return false; <else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &if (isDebug()) return false;
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
<else &return false;
return false; <else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (def == b) return false; if (def == null) return false;
return false; <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; /* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (def == b) &return false; <if (def == null) <return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else if (def == null) return false;
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (def == b) return false; if (def == null) <return false;
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (def == b) <return false; <if (def == null) <return false;
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else if (def == null) &return false;
return false; &else <break;
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else if (def == null) <return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (def == b) &return false; &if (def == null) &return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; else if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
<return false; return false;
return false; <return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; /* XXX - XXX */
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <else return false;
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else <if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (def == b) return false; &if (def == null) return false;
return false; &return (0);
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; </* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; return false;
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (def.isFunction()) return false;
return false; &if (def == b) <return false; if (def == null) <return false;
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; <if (def.isFunction()) &return false;
<return false; <return false;
return false; else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &return false;
return false; &<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (def == b) &return false; <if (def == null) <return false;
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (def == b) <return false; if (def == null) return false;
<return true;
return false; &&return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; <if (def.isFunction()) return false;
return false; else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &/* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
&return false; <return false;
return false; else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <return -1;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <&return canInline;
return false; <else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
else <return false;
return false; if (def == b) &return false; &if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <return result;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; ;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; /* do a load on the map */
return false; if (def.isFunction()) &return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (def == b) <return false; if (def == null) &return false;
return false; else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <gotDefinition();
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (isDebug()) <return false;
return false; <else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (def == b) return false; if (def == null) &return false;
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &return false;
return false; if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */
return false; else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; return (0);
return false; /* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else if (def == null) &return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (isDebug()) &return false;
return false; <else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; <if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (def == b) return false; &if (def == null) &return false;
return false; &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; #endif
return false; else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (def.isFunction()) <return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (def == b) return false; if (def == null) &return false;
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false;
return false; &if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false;
return false; else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <;
return false; else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (def == b) <return false; <if (def == null) &return false;
return false; &*/
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; break;
return false; goto out;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &if (def == b) return false; &if (def == null) <return false;
return false; &if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else &if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &if (def == b) return false; if (def == null) return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (def == b) return false; if (def == null) <return false;
return false; else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else if (def == null) <return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &goto out;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (def == b) &return false; <if (def == null) &return false;
return false; else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &<return canInline;
return false; &else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (def == b) return false; <if (def == null) &return false;
return false; <else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (def == b) <return false; if (def == null) return false;
return false; if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (def == b) <return false; <if (def == null) <return false;
return false; &if (def == b) &return false; &if (def == null) &return false;
return false; else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (def == b) &return false; if (def == null) &return false;
return false; else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; return true;
return false; &else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (def == b) return false; &if (def == null) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <goto out;
return false; <else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &return canInline;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else break;
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &<return false;
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &if (def == b) return false; <if (def == null) <return false;
return false; if (def == b) <return false; if (def == null) <return false;
return false; if (def == b) return false; &if (def == null) return false;
return false; &else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <*/ return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else if (def == null) return false;
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <return (0);
return false; &else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else <return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (def == b) return false; &if (def == null) <return false;
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else &return false;
&else return false;
return false; else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; if (def == b) return false; if (def == null) &return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; <else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; else return false;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; return 0;
return false; &&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (def == b) <return false; if (def == null) &return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (def.isFunction()) <return false;
return false; <else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (def == b) &return false; <if (def == null) &return false;
return false; &if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (def == b) &return false; if (def == null) <return false;
return false; &if (def == b) <return false; <if (def == null) return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else &break;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (def == b) &return false; &if (def == null) <return false;
return false; &else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <else
return false; else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else &return false;
return false; else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else <if (nodeUtil.isExprAssign(def.getParent())) &return false;
else &return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &if (def == b) return false; &if (def == null) &return false;
return false; &else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; return -1;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; if (def == b) &return false; &if (def == null) &return false;
return false; <if (def == b) &return false; <if (def == null) &return false;
return false; <else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
&return true;
return false; &else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else break;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (def == b) <return false; &if (def == null) return false;
return false; <if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
<return false;
return false; <else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (def == b) &return false; if (def == null) return false;
return false; else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (def.isFunction()) &return false;
return false; &return -1;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (def == b) &return false; if (def == null) <return false;
return false; else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &else <if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; <if (isDebug()) &return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (isDebug()) <return false;
return false; &<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (def == b) <return false; &if (def == null) &return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; </* * The value can be thrown into the list of dependencies, so check for any dependency at the end of the list. */ return false;
return false; else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (def == b) &return false; <if (def == null) return false;
return false; if (def == b) return false; <if (def == null) <return false;
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; <else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <if (def == b) <return false; &if (def == null) <return false;
return false; else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (def == b) return false; <if (def == null) return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &else
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; return canInline;
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false;
return false; else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; <&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else &break;
return false; else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; */
return false; &if (def == b) <return false; &if (def == null) <return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false;
return false; <&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <else <if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; &else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &&return canInline;
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &else if (def == null) <return false;
&return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <return canInline;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (def == b) <return false; &if (def == null) return false;
return false; &else &return false;
return false; else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &break;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &return 0;
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; break;
return false; else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &else break;
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else <break;
return false; if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &return result;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (def == b) return false; <if (def == null) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else <return false;
return false; &else <if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (def.isFunction()) return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; gotDefinition();
return false; &else &if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false;
return false; <else &if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else <return false;
return false; &else return false;
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <else &for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &if (def == b) return false; <if (def == null) return false;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) <return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (def == b) return false; &if (def == null) &return false;
return false; else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <<return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &&if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else <if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else &if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else &if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <break;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false;
return false; else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <else &return false;
return false; <else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (def == b) <return false; &if (def == null) &return false;
return false; else if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; &if (def == b) &return false; if (def == null) &return false;
return false; &if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (def == b) &return false; if (def == null) <return false;
return false; &if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) /* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def == b) <return false; <if (def == null) &return false;
return false; <else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */
return false; <else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <if (def == b) &return false; &if (def == null) return false;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (def == b) return false; <if (def == null) <return false;
return false; <if (def == b) <return false; if (def == null) <return false;
return false; &else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; <<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getParent(), def.getParent()); return false;
return false; &else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
<else return false;
return false; if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; &return true;
return false; else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (isContaining()) GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <else &if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else if (def == null) return false;
return false; else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
else return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &/* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &&if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; else return false;
return false; <else if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else <return false;
return false; &else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else &if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (def == b) return false; if (def == null) return false;
return false; </* do a load on the map */
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; &if (def == b) &return false; &if (def == null) return false;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
&return false;
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else &if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <return true;
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else /* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false;
return false; else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <else if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; else <if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; &#endif
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &else &return false;
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (useCfgNode) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &/* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (useCfgNode) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; else <for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; return result;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; else <if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &gotDefinition();
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) &sysCallbacks.flags = false; goto out;
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; else <if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
&return false; &return false;
return false; if (def == b) <return false; &if (def == null) <return false;
return false; &if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <if (def == b) return false; <if (def == null) &return false;
return false; else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */
return false; &else if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; </* XXX - XXX */
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &else <if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (def == b) &return false; <if (def == null) <return false;
return false; <if (isDebug()) return false;
return false; if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; &if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; if (def == b) return false; &if (def == null) <return false;
return false; <else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <return false;
return false; <if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &if (def == b) <return false; if (def == null) return false;
return false; &/* do a load on the map */
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <&if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
<return false; &return false;
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; &else if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (!DependentDefined ||!GetDependentDefined(def)) if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) <if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) <if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &else <for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) &return false;
return false; if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; if (isContaining()) &GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) <return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (!DependentDefined ||!GetDependentDefined(def)) <if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) &if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; /* XXX If the variable is not used in an instance of a ptr) we must try to add it to the inliner. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; &else &if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &if (getDefCfgNode().isFunction()) &if (inlinedNewDependencies.contains(dependency)) &return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return true;
return false; else &break;
return false; <else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; <if (def == b) &return false; if (def == null) return false;
return false; else <if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &else &if (nodeUtil.isExprAssign(def.getParent())) <return false;
return false; &if (nioRes) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; &if (def == b) <return false; &if (def == null) return false;
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &else <for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; else if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) &if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &<if (DebugFinish) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; <else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else <if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <if (isDebug()) <return false;
return false; <else &if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else &for (Var dependency : defMetadata.depends) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; <if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else <if (getDefCfgNode().isCanceled()) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; if (nioRes) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (def == b) <return false; if (def == null) &return false;
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <else <if (null == b) &b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; <else <if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; if (isDebug()) return false;
return false; <else </* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <if (getDefCfgNode().isFunction()) <if (inlinedNewDependencies.contains(dependency)) &return false; <getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &/* XXX - XXX */
return false; <if (def == b) &return false; &if (def == null) <return false;
return false; <else for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <else &if (getDefCfgNode().isCanceled()) if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; &if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; &<if (DebugFinish) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (def.isFunction()) <return false;
return false; else <break;
return false; /* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; &/* * The value can be thrown into the list of dependencies, so check for any dependency at the end of the list. */ return false;
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; <else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &else <if (null == b) <b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; if (checkLoftOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false;
return false; if (isContaining()) <GetDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) &return false;
return false; &else &if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; <if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; </* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; &if (nioRes) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <else &if (getDefCfgNode().isCanceled()) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) if (inlinedNew
return false; <if (nioRes) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &return false; else return false;
return false; else &if (nodeUtil.isExprAssign(def.getParent())) return false;
return false; if (def == b) &return false; if (def == null) &return false;
return false; &if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) <return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; if (def) <x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; return false;
return false; &else return false;
return false; &if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; <return 0;
return false; <if (def) &x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; <if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; <else if (DEBUG) printf("%s: Cannot inline %dn", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d<n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; <if (def == b) <return false; &if (def == null) &return false;
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (nioRes) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <return false; else return false;
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; &if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; if (useCfgNode) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) </* NodeUtil.mayHaveSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideEnumerateSideE
return false; <if (nioRes) &if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; else return false;
return false; <if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (def) x = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false;
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; <if (!DependentDefined ||!GetDependentDefined(def)) &if (DEBUG_SEARCH_UNUSED(def)) return false; if (!Debug.saveChildren) return false; if (DEBUG_SECServer) if (Debug.saveChildren) &if (Debug.saveChildren) return false; if (Debug.saveChildren) if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug.saveChildren) return false; if (Debug
return false; &else &if (id.IsEmpty()) <if (inlinedNewDependencies.contains(dependency)) <if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; &else </* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; if (!checkLof(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) &return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; return false;
return false; if (getDefCfgNode().isFunction()) if (inlinedNewDependencies.contains(dependency)) return false; &getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()))
return false; &else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; &/* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; else &/* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; else &for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) if (inlinedNewDependencies.contains(dependency)) return false; getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) return false;
return false; &else <if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) <return false;
return false; <else &if (nodeUtil.isExprAssign(def.getParent())) &return false;
return false; else <if (id.IsEmpty()) &if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) &if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) sysCallbacks.flags = false; goto out;
return false; &<if (DebugFinish) &if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent()
return false; &if (def == b) <return false; <if (def == null) <return false;
return false; <else &if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) &if (id.IsEmpty()) if (id.IsEmpty()) if (inlinedNewDependencies.contains(dependency)) return false; if (id.IsEmpty()) if (def == null) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false; if (checkLeftOf(def, getDefCfgNode()
return false; else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
return false; </* XXX: could not get this information, since we've retted a value, * XXX: can not get this information. */ if (canBeHaveHaveSidee) <if (needDirty) <if (sysCallbacks &&!sysCallbacks.flags) <sysCallbacks.flags = false; goto out;
return false; &else &/* The other side of the definition has side effect. */ if (def.isAssign() &&!NodeUtil.isExprAssign(def.getParent())) return false;
return false; &else if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getNode(), def.getParent()); if (DEBUG) printf("%s: Cannot inline %d&n", def.getParent(), def.getParent(), def.getParent()); return false;
return false; /* If one of our dependencies has been inlined, then our dependency graph is wrong. Re-computing it would take another CFG computation, so we just back off for now. */ for (Var dependency : defMetadata.depends) <if (inlinedNewDependencies.contains(dependency)) &if (inlinedNewDependencies.contains(dependency)) <if (inlinedNewDependencies.contains(dependency)) return false; return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def == null) return false; if (def.isAssign() &&!NodeUtil.
return false; <else if (null == b) b = readProp(b); modifyProp(b); print(x); if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) <return false; else if (null == b) return false; if (null == b) if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) return false; if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) return false; if (null == b) return false; if ((null == b) && (null == b) && (null == b) && (
return false; <else /* if we aren't inlined, we can't * do the best thing for all this if there are * a dependency at a function to check, so check that this function was done * and the function was successful. */ if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) &if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) <if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) if (CheckRightOf(use, useCfgNode, SIDE_EF
