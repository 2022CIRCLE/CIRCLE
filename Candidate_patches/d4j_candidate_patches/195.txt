
removeRow(rowKey);
removeRow(rowIndex);
ret = removeRow(index);
removeRow(&index);
return removeRow(index);
this.removeRow(index);
removeRow(index, 0);
deleteRow(index);
void removeRow(index);
(void)removeRow(index);
rv = removeRow(index);
/* removeRow(index); */
deleteRow(rowKey);
return 0;
break;
removeRow(row);
delRow(index);
RemoveRow(index);
getRowIndex(rowKey);
if (index)  removeRow(index);
setRowIndex(index);
removeRow(index, rowIndex);
addRow(index);
if (index) removeRow(index);
r = removeRow(index);
/* removeRow(index);*/
int rowIndex;
wremoveRow(index);
row = removeRow(index);
(void) removeRow(index);
self.removeRow(index);
removeRow(index, rowKey);
int i;
moveRow(index);
_removeRow(index);
aRemoveRow(index);
removeRow(index);
retRow(index);
super.removeRow(index);
removeRow((int)index);
int index;
splx(s);
res = removeRow(index);
result = removeRow(index);
closeRow(index);
nsresult rv;
deleteRow(index, 0);
eRemoveRow(index);
/* RemoveRow(index); */
return (removeRow(index));
return (0);
removeRow(rowKey, index);
retval = removeRow(index);
removeRow(index, row);
rowIndex = index;
.removeRow(index);
removeRow(indx);
removeRow();
::removeRow(index);
unremoveRow(index);
Recycle(index);
close(index);
selectRow(index);
NS_RELEASE(index);
freeRow(index);
delete(index);
replaceRow(index);
*removeRow(index);
int rowIndex = getRowIndex(rowKey);
return -1;
int index = getRowIndex(rowKey);
if (index == -1) return;
removeRow(key);
deleteRow(rowIndex);
setRow(index);
deleteRow(&index);
removeRow(index, true);
row = index;
free(index);
rval = removeRow(index);
removeRow(int index);
removeRow(index, 1);
rowIndex = removeRow(index);
return index;
deleteRow(index, rowKey);
removeRow(index - 1);
aRow = removeRow(index);
insertRow(index);
deleteRow();
if (rowKey) removeRow(index);
rect(index);
if (index == 0) return;
removeRow(index, -1);
/*removeRow(index);*/
if (index > 0)  removeRow(index);
mRows.removeRow(index);
if(index) removeRow(index);
xfree(rowKey);
if (index >= 0)  removeRow(index);
nsresult rv = removeRow(index);
removeRow(index + 1);
/*removeRow(index); */
rowIndex = getRowIndex(rowKey);
removeRow(colIndex);
removeRow(i);
setRowIndex(rowIndex);
if (rowKey)  removeRow(index);
free(rowKey);
index = getRowIndex(rowKey);
removeRow(index, false);
removeRow(rowCount);
if (index  0)  removeRow(index);
if (removeRow(index)) return;
NS_RELEASE(rowKey);
if (index)  deleteRow(index);
/* RemoveRow(index);*/
PRBool removeRow(index);
deleteRow(index, rowIndex);
removeRow(index, &index);
if (index == 0)  return;
nsCRT::free(index);
index = 0;
continue;
NS_IF_RELEASE(index);
if (index  0) removeRow(index);
rv = removeRow(index); if (NS_FAILED(rv)) return;
if (index >= 0) removeRow(index);
nsCRT::free(rowKey);
if (index == 0)  removeRow(index);
int index = getRowIndex(rowKey); removeRow(index);
getRowIndex(rowKey, index);
if (index  0) return;
if (index == -1)  return;
if (index >= 0)  return;
if (index == -1)  removeRow(index);
if (!removeRow(index)) return;
NS_IF_RELEASE(rowKey);
int rowIndex = getRowIndex(rowKey); removeRow(rowIndex);
removeRow(index, getter_AddRefs(rowKey));
if (removeRow(index)) return 0;
nsresult rv = NS_OK;
fprintf(stderr, "removeRown");
if (index >= 0)  break;
if (index == 0)  break;
removeRow(index, getter_AddRefs(rowIndex));
if (index  0)  return;
if (index  0)  break;
if (index == 0)  return 0;
if (!removeRow(index))  return;
if (rowIndex > 0)  removeRow(index);
fprintf(stderr, "removeRow: %sn", index);
ret = removeRow(index); if (ret) return ret;
if (removeRow(index)) return (0);
fprintf(stderr, "removeRow()n");
if (removeRow(index) == -1) return;
if (index  0)  return 0;
if (removeRow(index))  return;
result = removeRow(index); if (NS_FAILED(result)) return result;
if (index  0)  delete row;
if (removeRow(index))  return 0;
fprintf(stdout, "removeRown");
int rowIndex = getRowIndex(rowIndex);
if (rowIndex >= 0)  removeRow(index);
if (index >= 0)  return 0;
if (rowIndex > 0)  removeRow(rowIndex);
rv = removeRow(index); if (rv) return rv;
if (removeRow(index))  delete row;
if (getRowIndex(rowKey) == -1) return;
if (!getRowIndex(rowKey))  return;
nsresult rv; rv = removeRow(index);
if (index)  removeRow(index);  else  deleteRow(index);
ret = removeRow(index); if (ret == -1) return;
ret = removeRow(index); if (NS_FAILED(ret)) return;
if (rowIndex >= 0)  removeRow(rowIndex);
fprintf(stderr, "removeRow: %dn", index);
rv = removeRow(index); if (NS_FAILED(rv)) break;
fprintf(stdout, "removeRow: %sn", index);
fprintf(stderr, "removeRow: %s", index);
ret = removeRow(index); if (ret == null) return;
rv = removeRow(index); if (NS_FAILED(rv)) continue;
index = getRowIndex(rowKey); if (index == -1) return;
result = removeRow(index); if (NS_FAILED(result)) return;
if (getRowIndex(rowKey) == -1)  removeRow(index);
int index = getRowIndex(rowKey); if (index == -1) return;
int rowIndex = getRowIndex(rowKey); if (!rowIndex) return;
fprintf(stderr, "removeRow: row=%dn", index);
rv = removeRow(index); if (NS_FAILED(rv)) delete row;
ret = removeRow(index); if (NS_FAILED(ret)) return 0;
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex = 0)  nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c)  rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index)  return;
nsCOMPtrnsIRow> row; if (!mPrimary)  nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row)  return (0);  */ return (0);
if (intableRowCount)  int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0)  rowIndex = rowIndex -'';  if (rowIndex  rowIndex)  if (rowIndex  rowIndex)  if (rowIndex > 0)  if (rowIndex  0)  rowIndex = rowIndex;    else  if (rowIndex > rowIndex)  if (rowIndex  rowIndex)  rowIndex = rowIndex;
removeRow(index, getter_AddRefs(rdfcnt));
if (!getRowIndex(rowKey)) return;
if (rowIndex >= index)  return 0;  if (rowIndex >= index)  *rowIndex = rowIndex;  else  *rowIndex = rowIndex; return 0;
removeRow(index, index.mRowCount);
if (index >= sizeof(rowKey))  mRow = rowKey; break;  if (index >= sizeof(rowKey))  mRow = rowKey; mRow = rowKey; mRow = rowKey;  else  mRow = rowKey; break;  if (mRowIndex >= sizeof(rowKey))  mRowIndex = rowKey; mRowIndex = -1;
removeRow(index); /* * If the row  a row, we do not want to get this in the row. */
if (rowKey == null)  nsCRT::free(rowKey);
if (!mPosition)  return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1)  if (segmentCount == -1)  /* Recycle the row in the row (see ifdef */ if (index == -1)  row = 0; break;  row = -1;  else  row = -1; break;  */  if (index == -1)  row = -1;  else  row = -1;  row = -1)  row = -1)  /* Recycle the row on the row */ if (index == -1)    */  */  */ return -1;   else  /* Recycle the row */  */ row = -1;  */     else  /* Recycle the row
/* If the rowIndex = 0 then this is a rowIndex containing all columns that the table contains, if any. */ int rClone = &rClone; int rClone = &rClone;
int rowIndex = getRowIndex(rowKey); if (rowIndex  0)  break;
if (index >= 0)  rval = 0;  else  rval = 0;
if (index == 0)  i++;  else  if (rowIndex >= rowKey)  break;
if (index  0)  break;  if (itemIndex > 0)  PRInt32 i = index; i--; for (i = 0; i  index; i++)  if (index >= i)  /* Note that it doesn't matter if it is no longer needed. */ i--;   else  /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i  i; i++)  if (rowIndexes[i] == i)  i++;     else  i--;  rowIndexes[i] = i;
if (rowKey)  struct aRow *row = ((unsigned long)rowKey).value; if (row == null)  if (row == -1)  aRow = row;   if (*row)  aRow = 0;  if (row == null)  aRow = *row;    if (row == null)  aRow = *row;  else  aRow = row;   if (row == null)  aRow = 0;  if (aRow == null)  aRow = (*(*(*(*)).rowIndex)));    else  aRow = (*(*(*)).rowIndex)) * row;  if (aRow == null)  aRow = (*(*)).row
mLastRowIndex = index;
int rowIndex; void* res = &rowIndex; if (!res)  /* * Recycle the row if possible. */ res = res;  else if (!rowIndex)  res = &rowIndex; break;
ret = removeRow(index); if (ret == -1)   /* We do not know how to get ret */ for (index = 0; index  index; index++)  if (!ret)  ret = &errno;  if (!ret)  if (ret == -1)  delete row;   if (*ret == -1)  delete row;
if (index >= 0)  if (instRow)  removeRow(index);  else  if (!instRow)  instRow = 0; else  instRow = rowKey;  else  if (instRow)  instRow = rowKey;  else  instRow = index;
if (itemIndex > 0)  return;  if (index = 0)  if (itemIndex = 0)  return;
if (index >= index)  mRows.removeElement(index);  else  if (index = index)  mRows.removeElement(index);   if (index >= index)  mRows.removeElement(index);  else  mRows.removeElement(index);
if (index >= 0)  rv = -1;  if (index  0)  rv = -1;  else  rv = -1;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index)  if (index >= 0)  return;
if (index >= 0)  if (index  0)  if (inProcessNode)  if (idx == 0)  break;    else  if (idx > 0)  idx = idx;   else  idx = idx;   else  if (idx  0)  idx = idx;  else  idx = idx;   if (idx  0)  idx = idx - idx;
if (inPosition = 0)  *inPosition = rowKey; return;
if (colIndex  0)  removeRow(rowIndex);
rt = removeRow(index); if (rt == -1)  res = NS_ERROR_FAILURE;
if (index)  struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0)  if (row.rowIndex)  int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;  else  row.rowIndex = row.rowIndex;  row.rowIndex = row.rowIndex;  row.rowIndex = row.rowIndex;
if (index == -1)
nsTableEntry* entry = mTableEntry.TableEntry; entry.getRowIndex(&entry); entry.removeRow(index);
if (rowKey!= 0)  /* Remove the row in the row key. */ if (rowKey == 0)  /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return;   if (rowKey == -1)  /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return;   else  /* * If this is not the row key, remove the row. */
if (index > 0)  if (colIndex  0) return; if (index  0) return; if (rowIndex  0)  return;   if (index  0)  if (rowIndex - 0) return;  else  if (rowIndex  0) return; if (rowIndex  0) return;    else  if (rowIndex  0) return;  if (rowIndex > 0) return;
if (!aRowIndex)  nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row)  nsString row = (nsString) aRowIndex; if (rv == 0)  nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (removeRow(index))  fprintf(stderr, "removeRow %dn", index);
if (i == 0)  /* not defined as a row */ ret = 0; return ret;  if (index == 0)  if (i == 0)  if (!item) return i; i = 0;   else  ret = (ret == 0)? 0 : 0;  else  ret = 0;
if (!selection || index == 0)  if (rowKey)  /* XXX */ if (!listCell)  /* Allow row values */ else  rowKey = getRowIndex(rowKey);  else  rowKey = 0;
if (index)  if (!sid)  fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1;   else  if (index >= 0)  fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int rl; int row = getRowIndex(rowKey); if (row)  rl = getRowIndex(row);  else  rl = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex;  else  if (index  index)  ret = (ret) rowIndex; if (rowIndex >= index) return 0;  else  if (rowIndex  index) return 0;   if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex;  else  ret = (ret) rowIndex;
if (index  0)  delete(index);
if (index)  rval = -1;  else  rval = 0;
if (index = 0)  mTreeItem.removeRow(index);
if (item)  for (i = 0; i  index; i++)  *i = i;  if (!(row = index))  if (row)  if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex)  i--;  else  i--;  row.mAvailableIndex = row.mAvailableIndex;  else  i--;    else  if (row.mAvailableIndex == row.mAvailableIndex)  row.mAvailableIndex = row.mAvailableIndex;  row.mAvailableIndex = row.mAvailableIndex;  else  row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index == 0)  /* * Recycle the row if the row index isn't. */ rv = removeRow(index); if (NS_FAILED(rv)) return;
if (!rowIndex)  mInFlow = false;  else  mInFlow = false;
if (index  0)  /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0)  return;   else  if (index  0)  return;   else  return;
if (rowIndex  0)  if (rowIndex >= index) return -1; rowIndex--;  else  if (rowIndex >= index) return -1;  if (rowIndex >= index)  if (rowIndex = index) return -1;
if (inLine)  if (inLine) inLine.Init(); else  fprintf(stderr, "Comparing table %sn", tableName);   if (inLine.Index == inLine.Index)  fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= getRowIndex(rowKey))  removeRow(index);
if (index > 0)  ret =  index, rowIndex ;
int rowIndex = getRowIndex(rowKey); if (rowIndex  0)  id = rowIndex;  else  id = rowIndex;
if (!getRowIndex(rowKey))  if (!setRowIndex(rowIndex, index))  if (getRowIndex(rowKey, index))  rem = removeRow(index);   if (rem)  rem = removeRow(index);  else  rem = removeRow(index);
if (index)  if (rowIndex > 0)  if (index > 0)  if (rowIndex = index)  return (int)rowIndex;  else  if (rowIndex > index)  if (rowIndex  index)  if (rowIndex > index)  return (int)rowIndex;     if (rowIndex  index)  rowIndex = getRowIndex(rowIndex);  else  if (rowIndex > index) rowIndex = getRowIndex(rowIndex);    else  if (rowIndex  index)  if (rowIndex)  if (rowIndex  index)     else  if (rowIndex  index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index  0)  *index = getRowIndex(rowKey); if (index > 0)  *index = getRowIndex(rowKey);  if (index  0)  /* Remove row index for this table. */ if (index = index)  if (index >= index)  /* * Remove row index to the table */ index = getRowIndex(rowKey);    if (index >= index)  /* Remove row index to the table. */ if (index  index)  /* * Remove row index from the table. */ if (index >= index)  if (index  index)  /* if (index >= index)  /* * Remove row index from the table. */ if (index =
nsresult rv = NS_OK; if (null == rv)  nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv;  rv = NS_OK;
nsPool* i = getRowIndex(rowKey); if (i  0)  if (rowKey == -1 || rowKey == -1)  nsPool* p = mRow.p; if (p  p.size)  if ((Pool) row == 0)  if (i == 1)  p.size = 0;   else  if (i == 1)  p.size = 0;  else  p.size = 0;   else  if (i == 2)  p.size = 0;  else  p.size = 0;    else  p.size = 0;
if (!rowState.IsEmpty())  return 0;  if ((index = -1) &&!rowState.IsEmpty())  /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1)))  return -1;  */ else  */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1;  *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex  0)  if (!strcmp(rowIndex, "-"))  std::free(rowIndex);  else  std::free(rowIndex);  if (rowIndex >= index)  break;
if (rowIndex > 0)  fprintf(stderr, "%s: removeRow(%d)n",rowIndex,rowIndex);
if (index == -1)  if (isPositioned)  removeRow(index);
int rowIndex; if (!rowIndex)  delete rowIndex; rowIndex = rowIndex;
/* * Only remove the row by * index. */ if (index == -1)  rv = ret = 0;   else  rv = ret.removeRow(index); if (NS_FAILED(rv))  ret = 0;  else  ret = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row;  else  if (row)  if (!row) return;  if (row) return;
if (getRowIndex(rowKey)  index)  break;  if (getRowIndex(rowKey)  index)  index = getRowIndex(rowKey); if (getRowIndex(rowKey)  index)  index = -1;  if (getRowIndex(rowKey)  index)  index = -1;  else  if (getRowIndex(rowKey) > index)  index = getRowIndex(rowKey);  if (getRowIndex(rowIndex)  index)  index = getRowIndex(rowKey);  else  index = 0;   else  /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1))  if ((index >= index) && (index  index))  /* If rowIndex must be -1,
if (!rowKey)  if (rowIndex > 0)  removeRow(index);  else  fprintf(stderr, "Couldn't get row index");
if (rowIndex == 0)  *rowIndex = index;  else  if (rowIndex  0)  *rowIndex = 0;    else  *rowIndex = 0;
int index = 0; for (index = 0; index  rowCount; index++)  if (row[index])  if (itemIndex  rowCount)  if (!row[index]) return; return 0;
return mRows.RemoveRow(index);
if (getRowIndex(rowKey) == 0)  mTree.removeRow(index);  else  mTree.removeRow(index);
if (!mState)  /* Remove row */
if (!__PRECONDITION__)  if (index > 0)  if (!__PRECONDITION__((r = __PRECONDITION__)))  mInner = r.next; mInner = r.next;
if (increment)  if (index > 0)  fprintf(stderr, "wrong row index %sn", index);  else  if (increment == -1)  fprintf(stderr, "wrong row index %sn", index);  else  fprintf(stderr, "wrong row index %sn", index);   if (index >= 0)  fprintf(stderr, "wrong row index %sn", rowKey);  else  fprintf(stderr, "wrong row index %sn", rowKey);
if (index  1)  if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow;  if (index = 2)  if (row)  row = getRowIndex(rowKey); if (row)  if (row)  if (row)   row.lastRow = row; row.lastRow = 0;
r = getRowIndex(rowKey); if (r)  r = retval;
if (int)  char h; struct rowState rst; rst.segmentLength = 0; if (!h)  rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0;  if (!rst.segmentIndex  0)  rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
mRowData.removeRow(index);
removeRow(index); return 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1)  if (index == -1) return;  /* * We're gonna be able to get the row in any way. */ for (i = 0; i  row && i++)  if ((row  row))  *row = row[i]; if (index >= row)  return;   *row = row;
if (index == -1)  nsresult rv; *removeRow(index);
if (!getRowIndex(rowKey))  break;
retRow = ((int)index) / floats;  else  retRow = ((int)index) / floats;
/* XXX */ if (!rowKey)  return NS_ERROR_OUT_OF_MEMORY;
if (index == index || index == index)  break;
if (index >= 0)  nsAutoString rowKey('0'); if (index  nsAutoString::rowCount)  nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index = 0)  /* XXX */ if ((index >= 0) || (index = 0))  delete row;  else  /* XXX */
if (removeRow(index))
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count())  nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i  n; i++)  if (rowKey[i] == '0')  nsString tmp = rowKey[i];  if (rowKey[i] == '0')  nsString tmp; rowKey[i] = '0';  else  nsString tmp = rowKey[i]; if (rowKey[i] == '0')  nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0')  nsStr
if (index == -1)  r = 0;  if (mRowIndex > 0)  if (index == -1)  mRowIndex = mRowIndex;  else  r = mRowIndex;   else  r = mRowIndex;     else  r = mRowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1))  return;  *((*)rowKey.GetArray()) = 1;
res = removeRow(index); if (NS_FAILED(res))  break;
removeRow((uint) index);
nrows = 0; if (idx  0)  *idx = idx - rowIndex;  else  *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (getIndex()  0)  return 0;
r = getRowIndex(rowKey); if (r)  if (!r)  if (!removeRow(r, index))  break;    else  r = removeRow(r, index); if (r)  r = getRowIndex(rowKey);  if (r == -1)  r = r;  else  r = r; r = r;   if (r)  if (r) r = r;   if (r) r = r; r = r;   if (r == null)  r = r;   if (r)  r = r;   if (r == null) r = r;  if (r == null)  r = r; r = r;  else  r
if (index)  if (rowKey)  if ((index = getRowIndex(rowKey)))  /* removeRow(index); */    else  /* Recycle index of row index */ if (rowKey == index)  if (rowKey)  if (rowKey == index)  /* delete row */ return;    else  rowKey = getRowIndex(rowKey);  else  rowKey = 0;
/* Remove Row(index); */
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index)  return NS_ERROR_FAILURE;  if (rowIndex  0)  if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex  0) return NS_ERROR_FAILURE;
if (index  0)  rval = res = 0; break;    if (index >= 0)  rval = rval;
int index; int rv;
if (index == 0)  int rowIndex = getRowIndex(rowKey); if (rowIndex > 0)  fprintf(stderr, "Removing row %sn", rowIndex);
rv = mCellList.GetRowIndex(&rowKey); if (NS_FAILED(rv)) return rv; rv = mCellList.RemoveRow(&rowKey); if (NS_FAILED(rv)) return rv;
mRoot = (void**)&removeRow(index);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1)  if (i == 1)  /* We do not have a row that is in the row array. */ return 0;  if (rowIndex >= 1)  *(int)index = getRowIndex(rowIndex); if (index = 0)  if (rowIndex)  *(int)index = getRowIndex(rowIndex);  *(int)index = 0;   else  if (index >= 0)  *(int)index = getRowIndex(rowIndex);  *(int)index = getRowIndex(rowIndex);  else  /* getRowIndex(rowIndex) = 0; */ return;   *(int)index = 0;   if (index >= 0)
if (index > 0)  if (rowIndex  1)  return;  if (index >= 1)  if (rowIndex >= 0)   /* skip over the row value and skip over the row value if it's * a row value. */  else  /* skip over the row value */   else  */ return;
if (rowIndex == -1)  return 0;
/* Remove Row(index); */ if (index == null)  __FreeLocalize();  /* delete rows from the table, */ if (index >= 0)  __FreeLocalize();
return (rowIndex = index)? 0 : 0;
if (item)  ret = item.rowIndex; if (ret == -1)  ret = item.rowIndex;  else  ret = row.rowIndex;
int r = getRowIndex(rowKey); if (r == -1)  r = 0; r = -1;
if ((rowIndex = getRowIndex(rowKey))!= 0)  break;  if (rowIndex  index)  *int index = getRowIndex(rowKey); delete rowIndex;  if ((rowIndex >= index) && (rowIndex  rowIndex))  /* in the row indexes for each row */ return 0;  else  if (rowIndex  rowIndex)  /* it's * a row indexes for all rowIndexes. */  if (rowIndex  n)  /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex)  if (rowIndex  n)  if (rowIndex  rowIndexes)  nsAutoString row = (char *)rowInde
if (rowIndex >= 0)  if (rowIndex  rowIndex)  if (index >= rowIndex)  return -1;  if (rowIndex  0)  ret = rowIndex;  else  ret = rowIndex - rowIndex;
if (!isIndexed)  if (itemType == ObjectType.VoidKey)  if (itemType == ObjectType.VoidKey)  nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey)  if (rowKey.entryType == ObjectType.VoidKey)  if (rowKey.entryType == ObjectType.VoidKey)  nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType));   else  if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index  0)  delete (int)rowKey;
/* * Remove RowIndex, index. */ if (rowIndex  0)  *rowIndex = 0;   else  *rowIndex = 0;
if (rowKey)  nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex  rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (rowIndex == index)  *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i  rowIndex; i++)  if ((rowIndex = rowIndex) && (rowIndex  rowIndex))  if (cnt >= rowIndex) return; cnt++;    else  rowIndex = rowIndex;   if (rowIndex >= rowIndex) return;  if ((rowIndex  rowIndex) && (rowIndex >= 0)) return; if ((rowIndex  rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex  rowIndex)  if (rowIndex  rowIndex) return;
if (index  0)  delete row;  if (index > 0)  if (!(row == -1) ||!(*row == -1))  if (row) return; row = 0;  if (rowIndex  0)  if (!(rowIndex > 0))  if (rowIndex  0)  if (rowIndex  0)  if (rowIndex  0)  row = rowIndex; row = rowIndex;  else  if (rowIndex  0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex;   if (rowIndex >= 0)  if (rowIndex  rowIndex) row = rowIndex;   if (rowIndex  0)  *row = rowIndex;  else  if ((rowIndex
if (!getRowIndex(rowKey))  /* delete row index */ return;
ret = removeRow(index); if (ret  0)
mTreeRow = new RowIndex(index); if (mTreeRow)  if (rowIndex > mPos)  if (mPos > 0)  mPos = 0; mPos = 0;  else  mPos = mPos;
return mRows[index];
if (!sc)  fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0;  else  fs_brd.fs_id = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey)  int rowIndex; for (index = getRowIndex(rowKey); index  rowIndex; index++)  *index = getRowIndex(rowKey); *index = &rowIndex;  if (index >= rowIndex)  if (index >= 0)  /* We don't know how to remove rowIndex: */ return;  rowIndex = rowIndex;  if (index  rowIndex)  /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index  rowIndex))  if (index >= rowIndex)  /* * XXX */  if (!(rowIndex--) index)  /*
if (rowIndex  index)  if (rowIndex >= 0)  ret = removeRow(rowIndex); if (ret == -1)  *ret = ret;  else  *ret = ret;   else  if (rowIndex >= 0)  ret = ret;  else  *ret = ret;     else  ret = ret;
if (rowKey == mRowKey)  if (rowKey == mRowKey)  mRowKey = mRowKey;  else  mRowKey = mRowKey;  else  mRowKey = mRowKey;
if (rowKey)  if (rowKey)  rowKey = mTable[rowKey];  if (rowKey)  if (!rowKey)  return;  else  return;   else  return;
if (rowIndex == -1)  aResult = (aResult == -1)? 0 : 0;  else  aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));)))  if (index == index
if ((index = -1 && index >= 0))  *index = 0;  else  *index = 0;
mPadding--; if (index >= 0)  mPadding--;   else  mPadding--;
if (! eColIndex)  delete (rowKey);  else  /* removeRow(index);
if (index)  if (!item) return NS_ERROR_NULL_POINTER;
if (index >= 0)  /* * Note that there is a number of rows, and * the row value is not in the row and the value is not a row (not a row) * which should be removed if the value is not in the row and it has already been removed. */ return -1;

if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
<int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index = 0) </* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (!rowIndex) mInFlow = false; &else mInFlow = false;
if (rowIndex index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (inPosition = 0) *inPosition = rowKey; return;
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
if (getRowIndex(rowKey) &index) break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) &rval = -1; &else rval = 0;
if (item) for (i = 0; i index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= 0) if (index <0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (! eColIndex) delete (rowKey); <else </* removeRow(index);
if (index == -1) <r = 0; <if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index 0) <delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= 0) rv = -1; <if (index &0) <rv = -1; else rv = -1;
if (! eColIndex) &delete (rowKey); else /* removeRow(index);
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); &else <mTree.removeRow(index);
if (index >= 0) nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= 0) <if (instRow) <removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (itemIndex > 0) return; &if (index <= 0) if (itemIndex = 0) return;
if (index &0) &rval = res = 0; break; <if (index >= 0) rval = rval;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else &rl = 0;
if (index 0) break;
if (index == -1) <r = 0; if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index > 0) if (colIndex 0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nrows = 0; if (idx <0) *idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else &rl = 0;
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex <= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int index = 0; for (index = 0; index rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) &if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else rl = 0;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (!__PRECONDITION__) if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) if (!row) return; <if (row) return;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; &else &id = rowIndex;
if (!rowIndex) mInFlow = false; &else <mInFlow = false;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (removeRow(index)) return 0;
if (index == -1) &r = 0; &if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
int r = getRowIndex(rowKey); if (r == -1) r = 0; r = -1;
if (index == 0) &i++; else &if (rowIndex >= rowKey) &break;
if (itemIndex > 0) &return; <if (index &= 0) &if (itemIndex = 0) return;
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); else &mTree.removeRow(index);
if (rowKey) nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index &0) <break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) <if (!row) return; <if (row) return;
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index > 0) &if (colIndex &0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index) if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index == -1) r = 0; <if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nrows = 0; if (idx <0) <*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex >= 0) if (rowIndex rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
nrows = 0; if (idx &0) &*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (item) <for (i = 0; i index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= 0) &rv = -1; if (index &0) rv = -1; else rv = -1;
if (index == -1) <if (isPositioned) &removeRow(index);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= 0) &if (index 0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index >= 0) rv = -1; &if (index &0) <rv = -1; else rv = -1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (increment) if (index > 0) &fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
nrows = 0; if (idx <0) *idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (itemIndex > 0) return; if (index = 0) if (itemIndex = 0) return;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = 1;
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index == 0) <i++; <else if (rowIndex >= rowKey) &break;
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
if (getRowIndex(rowKey) <index) <break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex >= 0) if (rowIndex &rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index <0) <delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == index || index == index) break;
if (index >= 0) if (instRow) <removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else rl = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
<int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index <= 0) /* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (index <0) delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; <<else *rowIndex = 0;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); <else fprintf(stderr, "Couldn't get row index");
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &removeRow(index); <else deleteRow(index);
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex >= index) return 0; if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index) &rval = -1; <else rval = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) return;
rt = removeRow(index); if (rt == -1) <res = NS_ERROR_FAILURE;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex <index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) <rv = -1; <if (index 0) <rv = -1; else rv = -1;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = &1<;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index <0) <rval = res = 0; break; &if (index >= 0) rval = rval;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index >= 0) &rv = -1; if (index 0) &rv = -1; else rv = -1;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (inPosition = 0) <*inPosition = rowKey; return;
if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (rowIndex >= index) return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index 0) delete(index);
if (getRowIndex(rowKey) <index) <break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (item) for (i = 0; i index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index > 0) &if (colIndex <0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
removeRow(index);
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (rowIndex == 0) &*rowIndex = index; <else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
<int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (increment) if (index > 0) <fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) &if (instRow) <removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (increment) &if (index > 0) fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) &nsAutoString rowKey('0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index > 0) &if (colIndex <0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index > 0) if (colIndex 0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <0) rval = res = 0; break; <&if (index >= 0) rval = rval;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (! eColIndex) <delete (rowKey); &else </* removeRow(index);
if (rowIndex >= 0) if (rowIndex rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) &rv = -1; <if (index 0) &rv = -1; else rv = -1;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); /* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (index == -1) <r = 0; if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= 0) <if (index &0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); /* delete rows from the table, */ if (index >= 0) __FreeLocalize();
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex <0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index > 0) if (rowIndex &1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index = 0) </* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (item) for (i = 0; i <index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (getRowIndex(rowKey) <index) &break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (getRowIndex(rowKey) index) break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %sn", rowIndex);
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
nsresult rv = NS_OK; if (null == rv) <nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; <rv = NS_OK;
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) <rv = -1; if (index <0) <rv = -1; else rv = -1;
if (index <0) <break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index > 0) &if (colIndex &0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else &rl = 0;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (getRowIndex(rowKey) index) break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) if (!row) return; if (row) return;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index > 0) &if (rowIndex 1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (increment) if (index > 0) fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (itemIndex > 0) <return; <if (index &= 0) if (itemIndex = 0) return;
if (itemIndex > 0) &return; if (index <= 0) if (itemIndex = 0) return;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (increment) if (index > 0) &fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (item) &for (i = 0; i <index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index == 0) &i++; else &if (rowIndex >= rowKey) <break;
<int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex >= index) &return 0; if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (getRowIndex(rowKey) index) break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!rowKey) &if (rowIndex > 0) removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex >= index) &return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index >= 0) &nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
<int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; &<else *rowIndex = 0;
if (rowIndex = 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!rowIndex) <mInFlow = false; <else mInFlow = false;
if (index) <if (rowIndex > 0) <if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= index) &mRows.removeElement(index); &else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index) if (rowIndex > 0) <if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index == 0) &i++; &else <if (rowIndex >= rowKey) &break;
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else <rl = 0;
if (rowIndex == 0) *rowIndex = index; <else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (rowKey) <nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex <rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
mPadding--; if (index >= 0) &mPadding--; else &mPadding--;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!rowKey) &if (rowIndex > 0) removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= index) &mRows.removeElement(index); else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
nsresult rv = NS_OK; if (null == rv) nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; &rv = NS_OK;
if (index) rval = -1; else &rval = 0;
if (rowIndex == 0) <*rowIndex = index; <else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index > 0) <if (rowIndex <1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); else fprintf(stderr, "Couldn't get row index");
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) <if (!row) return; <if (row) return;
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; else &id = rowIndex;
nrows = 0; if (idx &0) <*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex &= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == -1) <r = 0; <if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; &&else *rowIndex = 0;
if (index 0) delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index > 0) &if (rowIndex &1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
<if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
if (index == 0) <i++; <else &if (rowIndex >= rowKey) <break;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); else fprintf(stderr, "Couldn't get row index");
nrows = 0; if (idx &0) <*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index <0) &delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
if (index >= 0) if (index <0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index > 0) <if (colIndex &0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
<int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index 0) <delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else <rl = 0;
if (index >= 0) &if (index &0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= 0) <nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
&int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (getRowIndex(rowKey) <index) break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex >= 0) &if (rowIndex &rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index) &if (rowIndex > 0) if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = 1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (itemIndex > 0) return; <if (index &= 0) <if (itemIndex = 0) return;
if (index >= 0) <if (index &0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index > 0) &ret = index, rowIndex ;
if (index >= 0) &rv = -1; if (index 0) rv = -1; else rv = -1;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index >= 0) rv = -1; &if (index 0) &rv = -1; else rv = -1;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) if (!row) return; &if (row) return;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index <= 0) /* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) rv = -1; if (index 0) <rv = -1; else rv = -1;
int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (item) for (i = 0; i <index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (! eColIndex) &delete (rowKey); &else /* removeRow(index);
if (index) &if (rowIndex > 0) if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (getRowIndex(rowKey) <index) break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index > 0) &if (rowIndex &1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index > 0) <if (colIndex <0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) <rv = -1; &if (index 0) rv = -1; else rv = -1;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index == 0) <removeRow(index);
if (index >= 0) <if (instRow) <removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index >= 0) <if (index <0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (itemIndex > 0) <return; &if (index <= 0) &if (itemIndex = 0) return;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index > 0) if (rowIndex <1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index 0) break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (getRowIndex(rowKey) <index) <break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex >= index) return 0; if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index > 0) <if (colIndex <0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= index) <mRows.removeElement(index); <else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex >= 0) <if (rowIndex <rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else <rl = 0;
if (index > 0) &ret = <index, rowIndex ;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) <rv = -1; <if (index &0) &rv = -1; else rv = -1;
if (rowIndex &index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) __FreeLocalize();
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
rt = removeRow(index); if (rt == -1) &res = NS_ERROR_FAILURE;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) <rval = 0; &else &rval = 0;
if (index) if (rowIndex > 0) if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowKey) &if (rowIndex > 0) &removeRow(index); else fprintf(stderr, "Couldn't get row index");
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (getIndex() <0) &return 0;
if (index >= index) &mRows.removeElement(index); else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex == 0) *rowIndex = index; <else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index >= index) mRows.removeElement(index); &else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (! eColIndex) &delete (rowKey); else </* removeRow(index);
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (removeRow(index)) <fprintf(stderr, "removeRow %dn", index);
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (itemIndex > 0) <return; &if (index &= 0) if (itemIndex = 0) return;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index == -1) &r = 0; if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index == -1) nsresult rv; *removeRow(index);
if (rowIndex == 0) <*rowIndex = index; else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index > 0) <if (colIndex &0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) &rv = -1; <if (index <0) rv = -1; else rv = -1;
if (index) <removeRow(index); &else <deleteRow(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index <0) <break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex >= index) &return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index &= 0) /* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
<int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (getRowIndex(rowKey) <index) <break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index) &removeRow(index); <else &deleteRow(index);
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = <1&;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
if (index >= 0) &if (index 0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (removeRow(index)) &fprintf(stderr, "removeRow %dn", index);
if (rowIndex >= index) &return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) if (rowIndex rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) &if (!row) return; if (row) return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) <if (!row) return; if (row) return;
if (rowIndex >= 0) &if (rowIndex rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
fprintf(stderr, "removeRow: %dn", index);
if (index == -1) r = 0; &if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
fprintf(stderr, "removeRow: %sn", index);
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index <0) break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (!rowIndex) <mInFlow = false; &else <mInFlow = false;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; <else *rowIndex = 0;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
nrows = 0; if (idx 0) &*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index 0) &delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
&if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) <if (!row) return; <if (row) return;
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; <&else *rowIndex = 0;
if (index 0) <return 0;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= 0) /* * Note that there is a number of rows, and * the row value is not in the row and the value is not a row (not a row) * which should be removed if the value is not in the row and it has already been removed. */ return -1;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (index &0) &break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= 0) &if (instRow) &removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index) <if (rowIndex > 0) &if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
retRow = ((int)index) / floats; <else <retRow = ((int)index) / floats;
&int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; <<else *rowIndex = 0;
if (getRowIndex(rowKey) &index) <break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
&if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) &if (index 0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index) &if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= 0) <rval = 0; <else <rval = 0;
if (index) <if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
fprintf(stderr, "removeRow&n");
if (index) &if (rowIndex > 0) if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (increment) if (index > 0) &fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex >= index) &return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (item) &for (i = 0; i &index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex > 0) <fprintf(stderr, "%s: removeRow(%d)<n",rowIndex,rowIndex);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index = 0) </* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; else <id = rowIndex;
mPadding--; if (index >= 0) mPadding--; <<else &mPadding--;
retRow = ((int)index) / floats; else &retRow = ((int)index) / floats;
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index <0) delete(index);
if (index == -1) return;
if (rowIndex index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index == -1) &r = 0; &if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index >= 0) <nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index > 0) &if (colIndex &0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index == 0) <return;
if (index) <if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex >= index) return 0; &if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; &else <id = rowIndex;
if (index 0) <delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index == 0) <i++; <else <if (rowIndex >= rowKey) &break;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!rowKey) if (rowIndex > 0) <removeRow(index); else <fprintf(stderr, "Couldn't get row index");
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = 1<;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
&if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
&int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index <0) <break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!__PRECONDITION__) &if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == 0) *rowIndex = index; else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if ((index = -1 && index >= 0)) *index = 0; else *index = 0;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
nrows = 0; if (idx <0) *idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index > 0) &if (colIndex &0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else &rl = 0;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) <rv = -1; <if (index <0) rv = -1; else rv = -1;
if (rowIndex <index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (!rowKey) if (rowIndex > 0) removeRow(index); else &fprintf(stderr, "Couldn't get row index");
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex == 0) *rowIndex = index; &else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else &rl = 0;
if (index >= 0) <if (index 0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index == -1) r = 0; <if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index >= 0) &if (instRow) <removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else &rl = 0;
if (rowIndex == 0) &*rowIndex = index; else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (index > 0) <if (colIndex <0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
<int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!rowKey) if (rowIndex > 0) <removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (index <0) return;
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %sn", rowIndex);
retRow = ((int)index) / floats; <else retRow = ((int)index) / floats;
&if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; &else &id = rowIndex;
if (!__PRECONDITION__) <if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (index > 0) <if (rowIndex &1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (index) &if (rowIndex > 0) if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index > 0) if (colIndex <0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
mPadding--; if (index >= 0) mPadding--; &<else &mPadding--;
if (!rowKey) &if (rowIndex > 0) removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (index == 0) i++; &else &if (rowIndex >= rowKey) <break;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else &rl = 0;
if (index) <rval = -1; &else &rval = 0;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
&if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) if (!row) return; if (row) return;
res = removeRow(index); if (NS_FAILED(res)) break;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (!rowKey) <if (rowIndex > 0) removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) <if (!row) return; <if (row) return;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex >= index) &return 0; if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (getRowIndex(rowKey) &index) <break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index == 0) &i++; <else if (rowIndex >= rowKey) break;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!rowIndex) mInFlow = false; <else &mInFlow = false;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index == 0) <i++; else &if (rowIndex >= rowKey) break;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex == 0) &*rowIndex = index; &else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index >= 0) rv = -1; if (index <0) <rv = -1; else rv = -1;
if (rowIndex == 0) <*rowIndex = index; else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index == 0) <i++; &else &if (rowIndex >= rowKey) &break;
if (increment) &if (index > 0) fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index <= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
mPadding--; if (index >= 0) mPadding--; &else <mPadding--;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index) &removeRow(index); else <deleteRow(index);
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (!__PRECONDITION__) &if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
if (index = 0) /* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (index >= 0) <if (instRow) removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (getRowIndex(rowKey) &index) <break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex >= 0) if (rowIndex &rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; &else &id = rowIndex;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index <0) &rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index) if (rowIndex > 0) &if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index = 0) &/* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index 0) rval = res = 0; break; <&if (index >= 0) rval = rval;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = 1;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex &= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; &else id = rowIndex;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex >= index) <return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowIndex == 0) &*rowIndex = index; &else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (itemIndex > 0) <return; <if (index <= 0) if (itemIndex = 0) return;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* XXX */ if (!rowKey) <return NS_ERROR_OUT_OF_MEMORY;
if (rowIndex &index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (getRowIndex(rowKey) &index) break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (index >= 0) nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) <rv = -1; if (index 0) <rv = -1; else rv = -1;
if (index >= 0) &if (instRow) removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
&int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
if (index > 0) <if (rowIndex 1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; &else *rowIndex = 0;
int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
mPadding--; if (index >= 0) &mPadding--; &else &mPadding--;
if (index 0) <delete row;
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) &removeRow(index);
nrows = 0; if (idx 0) *idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
<int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index &= 0) </* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (getIndex() &0) &return 0;
if (rowIndex >= 0) if (rowIndex <rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index &0) <rval = res = 0; break; <&if (index >= 0) rval = rval;
if (index 0) &delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (!mState) &/* Remove row */
if (rowIndex = 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index 0) &delete row;
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) <return;
nrows = 0; if (idx 0) *idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; &else if (!rowIndex) &res = &rowIndex; break;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!__PRECONDITION__) <if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (index >= 0) </* * Note that there is a number of rows, and * the row value is not in the row and the value is not a row (not a row) * which should be removed if the value is not in the row and it has already been removed. */ return -1;
if (index > 0) if (rowIndex 1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index &0) &removeRow(index);
if (increment) if (index > 0) <fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) &nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) &if (!row) return; if (row) return;
if (rowIndex &= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == -1) &r = 0; <if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
nrows = 0; if (idx &0) <*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (item) <for (i = 0; i &index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index) &if (rowIndex > 0) if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex &= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; &else *rowIndex = 0;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index >= 0) <if (index &0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index) <if (rowIndex > 0) <if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (colIndex 0) &removeRow(rowIndex);
if (index == -1) if (isPositioned) removeRow(index);
if (index >= 0) &if (index &0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex >= 0) &if (rowIndex <rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index) rval = -1; &else <rval = 0;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
<if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = <1;
if (index >= 0) <if (instRow) <removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index &0) &break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); <else mTree.removeRow(index);
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (item) &for (i = 0; i &index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) &if (!row) return; &if (row) return;
if (index >= index) &mRows.removeElement(index); &else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index > 0) &if (rowIndex <1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index) if (rowIndex > 0) &if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (rowIndex = 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; else *rowIndex = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!rowKey) &if (rowIndex > 0) <removeRow(index); else <fprintf(stderr, "Couldn't get row index");
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
if (! eColIndex) delete (rowKey); else /* removeRow(index);
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; &&else *rowIndex = 0;
if (index) if (rowIndex > 0) if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) if (!row) return; <if (row) return;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index 0) <break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex &index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = <1&;
if (item) <for (i = 0; i &index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); </* delete rows from the table, */ if (index >= 0) __FreeLocalize();
if (getRowIndex(rowKey) &index) &break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (index >= 0) rval = 0; <else rval = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index &0) rval = res = 0; break; if (index >= 0) rval = rval;
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex == 0) *rowIndex = index; &else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
rt = removeRow(index); if (rt == -1) res = NS_ERROR_FAILURE;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index >= 0) &nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
<int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (getRowIndex(rowKey) index) break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) <nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex >= 0) &if (rowIndex &rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index >= index) &mRows.removeElement(index); &else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (item) for (i = 0; i index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (itemIndex > 0) return; if (index = 0) <if (itemIndex = 0) return;
if (index > 0) if (rowIndex <1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index &0) <rval = res = 0; break; if (index >= 0) rval = rval;
if (rowIndex >= 0) if (rowIndex rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (! eColIndex) &delete (rowKey); &else </* removeRow(index);
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index &0) &break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (!__PRECONDITION__) <if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (removeRow(index)) &return;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index <0) <break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (! eColIndex) delete (rowKey); &else /* removeRow(index);
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
mPadding--; if (index >= 0) &mPadding--; &<else <mPadding--;
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index 0) &rval = res = 0; break; &if (index >= 0) rval = rval;
if (index >= 0) if (index <0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
if (index == -1) <r = 0; <if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); else <mTree.removeRow(index);
if (rowIndex &= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (index > 0) &if (colIndex <0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex <index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
/* Remove Row(index); */ if (index == null) __FreeLocalize(); </* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (index) &if (rowIndex > 0) &if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (item) <for (i = 0; i &index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; <else id = rowIndex;
if (index = 0) </* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (itemIndex > 0) &return; if (index &= 0) <if (itemIndex = 0) return;
if (!rowKey) if (rowIndex > 0) <removeRow(index); else fprintf(stderr, "Couldn't get row index");
if (index > 0) <ret = &index, rowIndex ;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (index >= index) &mRows.removeElement(index); else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index > 0) <if (colIndex &0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (rowIndex == 0) &*rowIndex = index; else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index &0) <break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index == -1) r = 0; <if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= 0) &if (index 0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex == 0) <*rowIndex = index; <else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index = 0) /* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
if (item) <for (i = 0; i index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
if (index == 0) <i++; <else &if (rowIndex >= rowKey) &break;
if (index >= 0) nsAutoString rowKey('0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) <if (!row) return; if (row) return;
if (item) &for (i = 0; i index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
nrows = 0; if (idx <0) <*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (inPosition <= 0) <*inPosition = rowKey; return;
if (index >= 0) &if (instRow) &removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index) <rval = -1; else <rval = 0;
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; else if (!rowIndex) &res = &rowIndex; break;
if (index 0) delete (int)rowKey;
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (rowIndex <index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) if (index &0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex >= 0) <if (rowIndex rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index) if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) rv = -1; if (index &0) <rv = -1; else rv = -1;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = &1;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
if (index) if (rowIndex > 0) &if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowKey) <if (rowIndex > 0) removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index > 0) <ret = <index, rowIndex <;
if (inPosition = 0) &*inPosition = rowKey; return;
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = &1;
if (itemIndex > 0) <return; if (index <= 0) &if (itemIndex = 0) return;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (increment) &if (index > 0) fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) if (instRow) <removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (getRowIndex(rowKey) <index) &break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
nrows = 0; if (idx <0) <*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <rval = -1; <else <rval = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index > 0) &if (colIndex 0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index &0) break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index) rval = -1; <else &rval = 0;
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (increment) &if (index > 0) fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index > 0) if (colIndex &0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; <else if (!rowIndex) &res = &rowIndex; break;
if (rowIndex == 0) &*rowIndex = index; <else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (!rowIndex) mInFlow = false; else <mInFlow = false;
if (index == -1) r = 0; &if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex >= index) &return 0; if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (rowIndex == 0) <*rowIndex = index; &else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else <rl = 0;
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
<int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (item) for (i = 0; i index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); else mTree.removeRow(index);
if (index 0) <rval = res = 0; break; if (index >= 0) rval = rval;
if (index &0) &delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index > 0) <if (colIndex 0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index) &rval = -1; else &rval = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) if (!row) return; &if (row) return;
if (rowIndex >= 0) if (rowIndex &rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index >= 0) <rval = 0; else &rval = 0;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); &else mTree.removeRow(index);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; &else <id = rowIndex;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index >= 0) &if (instRow) removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index >= index) <mRows.removeElement(index); else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index > 0) if (colIndex <0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index > 0) &if (rowIndex &1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex = 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (item) <for (i = 0; i <index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nrows = 0; if (idx 0) *idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index >= 0) rv = -1; <if (index 0) <rv = -1; else rv = -1;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s&n", rowIndex);
mPadding--; if (index >= 0) <mPadding--; <<else <mPadding--;
if (removeRow(index)) &delete row;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; <else if (!rowIndex) <res = &rowIndex; break;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else &rl = 0;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index <0) delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index >= index) <mRows.removeElement(index); &else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index > 0) <ret = &index, rowIndex <;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (removeRow(index)) fprintf(stderr, "removeRow %d<n", index);
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; &else id = rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (inPosition &= 0) <*inPosition = rowKey; return;
if (index) &if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if ((index = -1 && index >= 0)) *index = 0; else <*index = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else &rl = 0;
if (index == -1) <return;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); &else <mTree.removeRow(index);
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) &nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index > 0) if (colIndex 0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index) &if (rowIndex > 0) <if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index == 0) &i++; &else <if (rowIndex >= rowKey) <break;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (itemIndex > 0) <return; &if (index <= 0) <if (itemIndex = 0) return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) <removeRow(index); &else deleteRow(index);
if (!rowIndex) &mInFlow = false; <else <mInFlow = false;
if ((index = -1 && index >= 0)) <*index = 0; <else <*index = 0;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s<n", rowIndex);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index) &removeRow(index); <else <deleteRow(index);
if (index) &rval = -1; <else <rval = 0;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) if (instRow) &removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index &= 0) </* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (getIndex() &0) <return 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; <else <id = rowIndex;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!rowKey) &if (rowIndex > 0) removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); else <mTree.removeRow(index);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = &1;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (index == -1) <r = 0; <if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = &1<;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = 1&;
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (getRowIndex(rowKey) &index) break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!mState) </* Remove row */
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; &else &id = rowIndex;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); &else mTree.removeRow(index);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= 0) rv = -1; <if (index <0) <rv = -1; else rv = -1;
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index &0) rval = res = 0; break; <if (index >= 0) rval = rval;
if (removeRow(index)) return;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s&n", rowIndex);
if (getRowIndex(rowKey) <index) &break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
&if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
if (index 0) &rval = res = 0; break; &&if (index >= 0) rval = rval;
mPadding--; if (index >= 0) mPadding--; <else <mPadding--;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index == 0) <i++; &else if (rowIndex >= rowKey) <break;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; &<else *rowIndex = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) <if (!row) return; &if (row) return;
if (rowIndex == 0) <*rowIndex = index; <else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) &if (!row) return; <if (row) return;
if (index) <if (rowIndex > 0) if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index > 0) <if (colIndex 0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (! eColIndex) &delete (rowKey); <else &/* removeRow(index);
if (rowIndex >= 0) <if (rowIndex <rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
&if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if (index &0) <delete (int)rowKey;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) rv = -1; &if (index <0) &rv = -1; else rv = -1;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (itemIndex > 0) <return; <if (index &= 0) &if (itemIndex = 0) return;
if (rowIndex 0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex >= 0) &if (rowIndex <rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = 1&;
if (index &= 0) &mTreeItem.removeRow(index);
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else rl = 0;
if ((index = -1 && index >= 0)) <*index = 0; &else &*index = 0;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; else &id = rowIndex;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index > 0) if (colIndex &0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (getRowIndex(rowKey) &index) break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == -1) <r = 0; <if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mPadding--; if (index >= 0) <mPadding--; &&else mPadding--;
if (rowIndex >= index) return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!__PRECONDITION__) <if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (index >= 0) &if (index &0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (index == -1) r = 0; if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex &index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex <= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else rl = 0;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) <if (index >= 0) <return;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index) if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index == -1) &r = 0; &if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nrows = 0; if (idx &0) *idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (index <0) &break;
if (index == 0) <return 0;
if (rowIndex >= index) return 0; if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (item) <for (i = 0; i <index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index &0) break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (itemIndex > 0) &return; <if (index <= 0) if (itemIndex = 0) return;
if (index >= 0) if (index &0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
mPadding--; if (index >= 0) <mPadding--; &<else mPadding--;
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (removeRow(index)) <fprintf(stderr, "removeRow %d<n", index);
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (index >= 0) &if (index &0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex = 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; <else &id = rowIndex;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index > 0) &if (rowIndex &1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; else &id = rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; <else id = rowIndex;
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
<if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
mPadding--; if (index >= 0) <mPadding--; else mPadding--;
if (index >= 0) <rv = -1; &if (index <0) <rv = -1; else rv = -1;
mPadding--; if (index >= 0) <mPadding--; <<else mPadding--;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s<n", rowIndex);
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) <if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index > 0) &if (rowIndex 1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index 0) break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (! eColIndex) &delete (rowKey); <else </* removeRow(index);
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <break;
if (index >= 0) &if (index &0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index) if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index 0) break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (item) &for (i = 0; i index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= index) &mRows.removeElement(index); &else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index == 0) &i++; &else if (rowIndex >= rowKey) <break;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (index == 0) &i++; <else &if (rowIndex >= rowKey) break;
if (index == 0) &i++; &else &if (rowIndex >= rowKey) break;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = <1;
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; &else <id = rowIndex;
if (rowIndex >= 0) <if (rowIndex rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
<if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index == -1) &r = 0; if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index > 0) if (rowIndex &1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) &if (index >= 0) <return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nrows = 0; if (idx &0) &*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <if (rowIndex > 0) if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; &else *rowIndex = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= index) mRows.removeElement(index); <else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (getRowIndex(rowKey) &index) break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) if (index 0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index &= 0) </* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) <if (index &0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index == 0) <i++; else &if (rowIndex >= rowKey) <break;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index <0) delete row;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; &else if (!rowIndex) <res = &rowIndex; break;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; <else &id = rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = 1<;
if (rowIndex <= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (index) if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index == 0) &i++; else <if (rowIndex >= rowKey) break;
if (index >= 0) <if (index 0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; <else id = rowIndex;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) &nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else &rl = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
&if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!rowKey) <if (rowIndex > 0) <removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex <= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == -1) if (isPositioned) &removeRow(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nrows = 0; if (idx 0) &*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index &0) rval = res = 0; break; &&if (index >= 0) rval = rval;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!rowIndex) <mInFlow = false; else <mInFlow = false;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index <0) &return;
if (index) <if (rowIndex > 0) &if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (getIndex() 0) <return 0;
if (index == 0) i++; &else <if (rowIndex >= rowKey) <break;
if (index &0) <rval = res = 0; break; <<if (index >= 0) rval = rval;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; else &id = rowIndex;
if (rowIndex index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= index) &mRows.removeElement(index); <else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index) if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (rowKey) &nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex &rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (index) if (rowIndex > 0) <if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (itemIndex > 0) &return; if (index = 0) if (itemIndex = 0) return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
&if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (index >= index) mRows.removeElement(index); else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; &else <id = rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index == 0) <i++; &else <if (rowIndex >= rowKey) <break;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = &1<;
if (index 0) &break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index <0) rval = res = 0; break; <if (index >= 0) rval = rval;
if (index <= 0) /* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) if (!row) return; &if (row) return;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index &= 0) /* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; else *rowIndex = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
nrows = 0; if (idx <0) <*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) &delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index) &if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
if (index >= 0) &if (instRow) &removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (index > 0) if (colIndex <0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (!rowIndex) &mInFlow = false; &else <mInFlow = false;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s<n", rowIndex);
if (itemIndex > 0) <return; <if (index <= 0) <if (itemIndex = 0) return;
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = 1&;
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) rval = res = 0; break; &&if (index >= 0) rval = rval;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index <0) return 0;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index) &if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= 0) &rv = -1; <if (index &0) &rv = -1; else rv = -1;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (item) &for (i = 0; i &index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index 0) return;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex == 0) *rowIndex = index; &else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index <0) <break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; <else &id = rowIndex;
if (rowIndex == 0) *rowIndex = index; else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (rowIndex &index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) <nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (getRowIndex(rowKey) index) break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex >= index) &return 0; if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) <if (rowIndex &rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index) &rval = -1; else <rval = 0;
if (rowIndex &index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (itemIndex > 0) &return; &if (index &= 0) if (itemIndex = 0) return;
if (index <0) delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else <rl = 0;
if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
if (index >= 0) &rval = 0; <else <rval = 0;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
mPadding--; if (index >= 0) mPadding--; else &mPadding--;
if (index == -1) r = 0; if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mPadding--; if (index >= 0) mPadding--; <&else mPadding--;
<int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) &if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (removeRow(index)) &fprintf(stderr, "removeRow %d&n", index);
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!rowKey) if (rowIndex > 0) <removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
if (index > 0) <if (rowIndex &1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex >= index) <return 0; if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; <else id = rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = <1<;
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) if (!row) return; &if (row) return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index <0) delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else &rl = 0;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) &if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= 0) if (index 0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (item) for (i = 0; i index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex &= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) if (instRow) <removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; &else if (!rowIndex) <res = &rowIndex; break;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; &else if (!rowIndex) <res = &rowIndex; break;
&int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index >= 0) <if (index <0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
retRow = ((int)index) / floats; &else &retRow = ((int)index) / floats;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = <1&;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= 0) <if (index <0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; else id = rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; else id = rowIndex;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (colIndex <0) &removeRow(rowIndex);
if (index &= 0) /* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= 0) <nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
&int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex = 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index >= 0) rv = -1; &if (index &0) rv = -1; else rv = -1;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = <1;
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowIndex &0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) <if (!row) return; if (row) return;
if (index >= 0) &rv = -1; <if (index <0) <rv = -1; else rv = -1;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) <if (!row) return; &if (row) return;
&int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) &if (rowIndex > 0) <if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= 0) <rv = -1; if (index <0) rv = -1; else rv = -1;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex == 0) *rowIndex = index; &else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (increment) if (index > 0) fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = <1<;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index == -1) r = 0; <if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s&n", rowIndex);
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if ((index = -1 && index >= 0)) &*index = 0; &else &*index = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index &0) delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; <else &id = rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
<int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) __FreeLocalize();
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; &&else *rowIndex = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index) &rval = -1; <else &rval = 0;
if (rowIndex >= 0) removeRow(index);
if (getRowIndex(rowKey) <index) <break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; &<else *rowIndex = 0;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
if (item) for (i = 0; i &index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= 0) if (index 0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex &= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index <= 0) </* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
mPadding--; if (index >= 0) mPadding--; &else &mPadding--;
if (index &0) return 0;
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
<if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (index >= index) mRows.removeElement(index); else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
fprintf(stderr, "removeRow: row=%d&n", index);
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (increment) if (index > 0) &fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (getRowIndex(rowKey) <index) &break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (index <0) &break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (index) <if (rowIndex > 0) <if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex >= 0) &if (rowIndex &rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) __FreeLocalize();
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index > 0) <if (rowIndex 1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= 0) <if (index <0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index &0) &delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
nrows = 0; if (idx &0) <*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex >= index) <return 0; if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex <= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index &= 0) &/* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (index <0) <delete(index);
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) &nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (getRowIndex(rowKey) index) &break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else &rl = 0;
if (item) for (i = 0; i &index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) if (!row) return; if (row) return;
retRow = ((int)index) / floats; &else <retRow = ((int)index) / floats;
nrows = 0; if (idx <0) <*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex >= index) <return 0; if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index > 0) &if (colIndex &0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) if (index <0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index == 0) i++; <else <if (rowIndex >= rowKey) &break;
if (index == 0) &i++; <else &if (rowIndex >= rowKey) &break;
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <0) <rval = res = 0; break; <&if (index >= 0) rval = rval;
if (index) &if (rowIndex > 0) <if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!getRowIndex(rowKey)) &break;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index == 0) &i++; <else <if (rowIndex >= rowKey) &break;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (itemIndex > 0) return; &if (index = 0) if (itemIndex = 0) return;
if (itemIndex > 0) return; <if (index = 0) &if (itemIndex = 0) return;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) &rval = -1; &else <rval = 0;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == 0) i++; else &if (rowIndex >= rowKey) <break;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = <1&;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex >= 0) <if (rowIndex <rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index >= index) <mRows.removeElement(index); &else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex >= index) <return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
nsresult rv = NS_OK; if (null == rv) <nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; rv = NS_OK;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
&if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= 0) if (instRow) &removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index >= 0) nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index) <if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (item) for (i = 0; i <index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index == -1) <r = 0; if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (getRowIndex(rowKey) == -1) removeRow(index);
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &= 0) </* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = 1;
if (getRowIndex(rowKey) <index) <break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!__PRECONDITION__) if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) &if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex &index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else rl = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex &= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; else if (!rowIndex) res = &rowIndex; break;
if (index) if (rowIndex > 0) if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index >= 0) rv = -1; <if (index 0) rv = -1; else rv = -1;
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index > 0) <if (rowIndex <1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (colIndex &0) <removeRow(rowIndex);
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (index <0) &rval = res = 0; break; &&if (index >= 0) rval = rval;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
nsresult rv = NS_OK; if (null == rv) nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; rv = NS_OK;
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; &else <id = rowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex <index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) r = 0; if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; <else &id = rowIndex;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; <&else *rowIndex = 0;
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (itemIndex > 0) &return; <if (index <= 0) &if (itemIndex = 0) return;
mPadding--; if (index >= 0) &mPadding--; &&else &mPadding--;
if (increment) <if (index > 0) fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
nrows = 0; if (idx &0) &*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (itemIndex > 0) &return; if (index <= 0) <if (itemIndex = 0) return;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
mPadding--; if (index >= 0) <mPadding--; <<else &mPadding--;
if (getRowIndex(rowKey) index) &break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index &0) <return;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index) &deleteRow(index);
if (index > 0) &ret = index, rowIndex &;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= 0) <nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index == -1) &r = 0; if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index <0) &delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex &= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (increment) <if (index > 0) fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if ((index = -1 && index >= 0)) <*index = 0; else <*index = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
mPadding--; if (index >= 0) &mPadding--; <&else <mPadding--;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (index > 0) <if (colIndex &0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (getRowIndex(rowKey) index) &break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index > 0) if (rowIndex <1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) &delete (int)rowKey;
if (index <= 0) </* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = <1<;
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index 0) <delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (increment) <if (index > 0) fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) &if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) removeRow(index); else &deleteRow(index);
if (inPosition <= 0) *inPosition = rowKey; return;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index 0) &break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!__PRECONDITION__) if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (rowIndex >= 0) <if (rowIndex <rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (getRowIndex(rowKey) &index) break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) &if (!row) return; &if (row) return;
if (rowIndex == 0) *rowIndex = index; <else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) if (!row) return; &if (row) return;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if (index) if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == 0) &*rowIndex = index; <else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) <if (index >= 0) return;
if (index >= 0) <rv = -1; if (index &0) rv = -1; else rv = -1;
if (index <0) <delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int r = getRowIndex(rowKey); if (r == -1) &r = 0; r = -1;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else &rl = 0;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; <else if (!rowIndex) res = &rowIndex; break;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (itemIndex > 0) &return; &if (index <= 0) <if (itemIndex = 0) return;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index > 0) &if (rowIndex 1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (index >= 0) <nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; <else &id = rowIndex;
if (index >= index) &mRows.removeElement(index); &else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index) if (rowIndex > 0) &if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index >= index) mRows.removeElement(index); else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex &index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
if (index > 0) &ret = <index, rowIndex <;
if (index >= 0) <if (instRow) &removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index > 0) if (rowIndex <1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex >= index) return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex >= 0) &if (rowIndex &rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex >= 0) <if (rowIndex rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (increment) <if (index > 0) fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex >= 0) if (rowIndex &rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (index >= index) <mRows.removeElement(index); &else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index >= 0) <nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!rowKey) <if (rowIndex > 0) &removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (item) <for (i = 0; i index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= 0) nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) if (!row) return; <if (row) return;
if (index >= 0) <if (instRow) &removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index) <removeRow(index); else deleteRow(index);
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; else id = rowIndex;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= 0) rval = 0; else &rval = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (itemIndex > 0) return; if (index <= 0) <if (itemIndex = 0) return;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (itemIndex > 0) return; <if (index &= 0) &if (itemIndex = 0) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index > 0) &ret = &index, rowIndex <;
if (rowIndex index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) &rval = 0; &else rval = 0;
if (index) &if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (itemIndex > 0) return; <if (index <= 0) &if (itemIndex = 0) return;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
if (rowIndex >= 0) &if (rowIndex <rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = <1<;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; else <id = rowIndex;
if (index) &if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) if (!row) return; &if (row) return;
if (index >= 0) <if (instRow) removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index >= 0) rv = -1; <if (index 0) &rv = -1; else rv = -1;
<int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (!rowKey) &if (rowIndex > 0) removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (increment) &if (index > 0) fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
&int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index > 0) <if (colIndex <0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index) <rval = -1; <else &rval = 0;
if (index > 0) <if (rowIndex <1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; <else *rowIndex = 0;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (itemIndex > 0) &return; if (index &= 0) if (itemIndex = 0) return;
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= index) <mRows.removeElement(index); <else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (increment) if (index > 0) fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) rv = -1; &if (index &0) &rv = -1; else rv = -1;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); </* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (index >= 0) &nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index 0) &delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; <else <id = rowIndex;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!__PRECONDITION__) if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (item) &for (i = 0; i index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; &else *rowIndex = 0;
fprintf(stderr, "removeRown");
if (index <0) break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex == 0) &*rowIndex = index; <else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index >= 0) <nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (removeRow(index)) delete row;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; &&else *rowIndex = 0;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else rl = 0;
if (rowIndex &= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
&if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (item) for (i = 0; i &index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index <0) &break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex >= 0) &if (rowIndex rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) <if (index >= 0) &return;
if (index <0) <break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= index) <mRows.removeElement(index); &else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex > 0) &fprintf(stderr, "%s: removeRow(%d)<n",rowIndex,rowIndex);
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; else <id = rowIndex;
if (getRowIndex(rowKey) index) break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == -1) &r = 0; <if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (! eColIndex) delete (rowKey); <else /* removeRow(index);
if (index > 0) if (rowIndex 1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index >= 0) <if (index 0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index == 0) &/* * Recycle the row if the row index isn't. */ rv = removeRow(index); if (NS_FAILED(rv)) return;
if (index >= index) &mRows.removeElement(index); <else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!__PRECONDITION__) &if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (index == -1) <r = 0; if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (item) <for (i = 0; i <index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (getRowIndex(rowKey) &index) <break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == -1) r = 0; &if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (item) &for (i = 0; i &index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex >= 0) &if (rowIndex &rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (index >= 0) &if (index 0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex = 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
<if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= index) <mRows.removeElement(index); else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex = 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= 0) <if (instRow) removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
nrows = 0; if (idx <0) *idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
nrows = 0; if (idx 0) &*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index == 0) <i++; <else <if (rowIndex >= rowKey) break;
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (item) &for (i = 0; i index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) <if (!row) return; <if (row) return;
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index == 0) &i++; &else if (rowIndex >= rowKey) break;
if (itemIndex > 0) return; if (index = 0) &if (itemIndex = 0) return;
if (!__PRECONDITION__) <if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
mPadding--; if (index >= 0) <mPadding--; &&else &mPadding--;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
mPadding--; if (index >= 0) mPadding--; <else &mPadding--;
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!rowKey) &if (rowIndex > 0) &removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (index >= index) mRows.removeElement(index); &else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (! eColIndex) <delete (rowKey); else /* removeRow(index);
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index <0) <delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index == 0) i++; &else &if (rowIndex >= rowKey) break;
if (index <0) <break;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index > 0) if (rowIndex 1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= index) &mRows.removeElement(index); &else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex = 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index 0) rval = res = 0; break; <<if (index >= 0) rval = rval;
if (rowIndex = 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
nrows = 0; if (idx <0) *idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) &if (rowIndex > 0) <if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index == -1) &r = 0; if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; <else <id = rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex >= index) &return 0; if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (rowIndex >= index) return 0; if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index > 0) if (rowIndex 1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= 0) &if (index 0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index == 0) &i++; &else &if (rowIndex >= rowKey) <break;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if (index > 0) <if (colIndex <0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) &if (!row) return; &if (row) return;
&int index = 0; for (index = 0; index rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index >= 0) &if (instRow) &removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = &1;
if (itemIndex > 0) &return; <if (index <= 0) <if (itemIndex = 0) return;
if (index) &removeRow(index); &else deleteRow(index);
if (index >= index) <mRows.removeElement(index); &else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index > 0) &if (colIndex <0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) <break;
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (rowKey) removeRow(index);
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index <0) rval = res = 0; break; &if (index >= 0) rval = rval;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex == 0) &*rowIndex = index; else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index > 0) &if (colIndex <0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <0) &break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) <if (!row) return; <if (row) return;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; else if (!rowIndex) res = &rowIndex; break;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (rowKey) &removeRow(index);
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (getRowIndex(rowKey) &index) &break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; <else id = rowIndex;
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex &0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index <0) removeRow(index);
if (index > 0) &if (colIndex 0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!mPosition) <return;
int index = 0; for (index = 0; index rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index >= 0) if (instRow) removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else rl = 0;
if (getRowIndex(rowKey) <index) break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) <nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) __FreeLocalize();
if (itemIndex > 0) <return; if (index = 0) if (itemIndex = 0) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex >= 0) <if (rowIndex &rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index >= 0) rv = -1; &if (index 0) rv = -1; else rv = -1;
if (getRowIndex(rowKey) index) &break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!__PRECONDITION__) &if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (index >= 0) <nsAutoString rowKey('0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index == 0) &i++; else if (rowIndex >= rowKey) &break;
if (itemIndex > 0) &return; &if (index = 0) &if (itemIndex = 0) return;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (!rowIndex) <mInFlow = false; else &mInFlow = false;
if (index >= 0) if (index &0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index <0) &break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index 0) delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index > 0) <if (rowIndex <1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) if (!row) return; if (row) return;
if (index 0) <delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) <if (!row) return; &if (row) return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = 1;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index > 0) if (rowIndex &1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex >= 0) <if (rowIndex <rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; &else &id = rowIndex;
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index = 0) /* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index > 0) if (rowIndex &1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index > 0) <if (rowIndex 1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index > 0) if (rowIndex &1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index == 0) <i++; else <if (rowIndex >= rowKey) &break;
if (colIndex 0) removeRow(rowIndex);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index = 0) &/* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex == 0) &*rowIndex = index; <else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index <= 0) /* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (index >= 0) <rv = -1; <if (index 0) &rv = -1; else rv = -1;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= index) mRows.removeElement(index); else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &removeRow(index); else &deleteRow(index);
if (rowIndex == 0) <*rowIndex = index; &else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index == 0) <i++; &else <if (rowIndex >= rowKey) break;
if (index) <if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex >= 0) if (rowIndex <rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex >= index) return 0; &if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) &if (rowIndex rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if ((index = -1 && index >= 0)) &*index = 0; else <*index = 0;
if (item) for (i = 0; i index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
&removeRow(index);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index &0) &rval = res = 0; break; <&if (index >= 0) rval = rval;
if (index >= index) <mRows.removeElement(index); <else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (getRowIndex(rowKey) &index) &break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; &<else *rowIndex = 0;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index == -1) &r = 0; if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= 0) if (index <0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) &if (!row) return; &if (row) return;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else <rl = 0;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index > 0) <if (rowIndex &1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (itemIndex > 0) &return; if (index = 0) <if (itemIndex = 0) return;
mPadding--; if (index >= 0) &mPadding--; <<else mPadding--;
if (index > 0) if (colIndex <0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (index > 0) <if (rowIndex <1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index <0) delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex >= index) return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index >= 0) rv = -1; <if (index <0) &rv = -1; else rv = -1;
if (!rowIndex) &mInFlow = false; else &mInFlow = false;
if (index == 0) i++; &else if (rowIndex >= rowKey) &break;
if (getRowIndex(rowKey) &index) break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
nsresult rv = NS_OK; if (null == rv) nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; <rv = NS_OK;
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (itemIndex > 0) <return; <if (index = 0) &if (itemIndex = 0) return;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %sn", rowIndex);
if (index >= 0) <if (index <0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; else &id = rowIndex;
if (index >= 0) <rval = 0; &else <rval = 0;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else &rl = 0;
if (index >= 0) &rval = 0; &else &rval = 0;
if (rowIndex >= index) return 0; <if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (rowIndex &= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index > 0) &if (rowIndex 1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index == -1) <if (isPositioned) <removeRow(index);
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex >= 0) if (rowIndex &rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex == 0) &*rowIndex = index; &else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (increment) &if (index > 0) fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) &if (!row) return; <if (row) return;
mPadding--; if (index >= 0) mPadding--; <&else &mPadding--;
mPadding--; if (index >= 0) mPadding--; &&else &mPadding--;
if (index 0) &rval = res = 0; break; <if (index >= 0) rval = rval;
if (index >= getRowIndex(rowKey)) removeRow(index);
if (rowIndex >= 0) &if (rowIndex rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index >= 0) nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) if (instRow) removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index) if (rowIndex > 0) <if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (itemIndex > 0) <return; if (index = 0) &if (itemIndex = 0) return;
if (item) &for (i = 0; i <index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = 1<;
if (index &0) &delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) <if (!row) return; if (row) return;
if (index &0) delete row;
if (index) <if (rowIndex > 0) if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (rowIndex 0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (index) <if (rowIndex > 0) &if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index > 0) if (rowIndex 1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index > 0) &removeRow(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) if (!row) return; if (row) return;
if (itemIndex > 0) &return; if (index &= 0) &if (itemIndex = 0) return;
if (index == -1) r = 0; &if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = <1<;
if (rowKey) <nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (index) &removeRow(index); &else &deleteRow(index);
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else <rl = 0;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* If the rowIndex = 0 then this is a rowIndex containing all columns that the table contains, if any. */ int rClone = &rClone; int rClone = &rClone;
if (index &0) <rval = res = 0; break; <if (index >= 0) rval = rval;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; else if (!rowIndex) &res = &rowIndex; break;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; else id = rowIndex;
if (index 0) break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex >= 0) if (rowIndex <rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (!rowIndex) <mInFlow = false; else mInFlow = false;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex >= index) <return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (itemIndex > 0) &return; &if (index &= 0) &if (itemIndex = 0) return;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index = 0) </* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = <1&;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex >= index) <return 0; if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nrows = 0; if (idx 0) &*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index) if (rowIndex > 0) <if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index <0) break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) &rv = -1; if (index <0) rv = -1; else rv = -1;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index > 0) <if (rowIndex 1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index > 0) if (rowIndex &1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* XXX */ if (!rowKey) return NS_ERROR_OUT_OF_MEMORY;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex >= index) return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (itemIndex > 0) return; if (index &= 0) &if (itemIndex = 0) return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index <= 0) /* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
&if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
if (rowIndex &= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (removeRow(index)) fprintf(stderr, "removeRow %dn", index);
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index 0) removeRow(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= 0) <nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex <index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index >= 0) <nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) if (!row) return; if (row) return;
if (rowIndex >= index) &return 0; &if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index) &if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (item) <for (i = 0; i &index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
<int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!getRowIndex(rowKey)) return;
if (index > 0) ret = index, rowIndex <;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = 1;
if (index >= 0) &nsAutoString rowKey('0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index 0) delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (getRowIndex(rowKey) <index) break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) <removeRow(index); <else <deleteRow(index);
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
if (index &0) <delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) &if (!row) return; <if (row) return;
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; <else <id = rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) &if (!row) return; if (row) return;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (getRowIndex(rowKey) index) &break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index 0) delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index &0) break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex <index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index &= 0) </* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (index >= 0) if (index 0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (item) for (i = 0; i &index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (item) &for (i = 0; i &index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
nrows = 0; if (idx 0) &*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index &0) <break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = 1&;
if (rowIndex > 0) <removeRow(rowIndex);
if (index > 0) &if (rowIndex <1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index == 0) &i++; <else <if (rowIndex >= rowKey) break;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = 1&;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index) <if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
ret = removeRow(index); if (ret &0)
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else rl = 0;
&if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index == 0) i++; else &if (rowIndex >= rowKey) &break;
mPadding--; if (index >= 0) &mPadding--; <else <mPadding--;
if (index) &return;
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index > 0) <if (colIndex &0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index == 0) i++; else if (rowIndex >= rowKey) <break;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else <rl = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= 0) &if (index <0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (rowIndex = 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (index <0) <rval = res = 0; break; &&if (index >= 0) rval = rval;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) r = 0; if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (! eColIndex) <delete (rowKey); &else &/* removeRow(index);
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index) if (rowIndex > 0) <if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex <= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= 0) if (instRow) &removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
nrows = 0; if (idx &0) &*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index <0) <delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index > 0) &if (colIndex &0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= index) mRows.removeElement(index); &else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index >= 0) &rv = -1; if (index &0) &rv = -1; else rv = -1;
if (index > 0) <if (colIndex &0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &= 0) /* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex <= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == -1) &r = 0; &if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
<if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
mPadding--; if (index >= 0) <mPadding--; <else <mPadding--;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %sn", rowIndex);
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) if (!row) return; <if (row) return;
if (index >= 0) if (instRow) &removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; <else <id = rowIndex;
if ((index = -1 && index >= 0)) &*index = 0; else &*index = 0;
if (index >= index) <mRows.removeElement(index); &else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex <= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index == 0) i++; else if (rowIndex >= rowKey) &break;
if (index == -1) &r = 0; <if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mPadding--; if (index >= 0) <mPadding--; &&else <mPadding--;
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; <<else *rowIndex = 0;
if (index 0) &break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; &<else *rowIndex = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index > 0) &if (rowIndex 1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) &if (index >= 0) &return;
if (index >= 0) <rval = 0; &else rval = 0;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index) removeRow(index); &else <deleteRow(index);
&int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index == 0) <break;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex >= 0) <if (rowIndex &rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index &= 0) /* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index &0) <delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex == 0) <*rowIndex = index; <else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index >= 0) rv = -1; if (index 0) rv = -1; else rv = -1;
if ((index = -1 && index >= 0)) &*index = 0; <else &*index = 0;
if (rowIndex &= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s&n", rowIndex);
if (index &0) <break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= 0) if (index 0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex <= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (itemIndex > 0) return; if (index <= 0) if (itemIndex = 0) return;
if (index == -1) &r = 0; if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
if (index <0) break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; &&else *rowIndex = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = 1<;
/* If the rowIndex &= 0 then this is a rowIndex containing all columns that the table contains, if any. */ int rClone = &rClone; int rClone = &rClone;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <break;
<int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (getRowIndex(rowKey) <index) &break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index > 0) if (colIndex &0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else rl = 0;
if (index > 0) ret = <index, rowIndex <;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; <else id = rowIndex;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= 0) &if (instRow) <removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = <1&;
if (!rowKey) if (rowIndex > 0) &removeRow(index); <else fprintf(stderr, "Couldn't get row index");
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index == -1) &r = 0; &if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else <rl = 0;
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) &if (!row) return; if (row) return;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= 0) if (index &0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
if (index >= 0) <if (index &0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= index) mRows.removeElement(index); <else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (itemIndex > 0) &return; <if (index = 0) &if (itemIndex = 0) return;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex 0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %sn", rowIndex);
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index &0) &break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= index) mRows.removeElement(index); else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if ((index = -1 && index >= 0)) *index = 0; &else *index = 0;
if (index > 0) <if (colIndex &0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (itemIndex > 0) &return; if (index = 0) &if (itemIndex = 0) return;
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) if (rowIndex > 0) &if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index == -1) <r = 0; <if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index) <if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= index) <mRows.removeElement(index); <else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if ((index = -1 && index >= 0)) <*index = 0; <else &*index = 0;
if (rowIndex == 0) <*rowIndex = index; &else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
<if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!removeRow(index)) <return;
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; &else if (!rowIndex) res = &rowIndex; break;
</*removeRow(index); */
if (rowIndex >= 0) &if (rowIndex <rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) &if (instRow) &removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index &= 0) </* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index &0) removeRow(index);
if (index) <if (rowIndex > 0) if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) <if (!row) return; if (row) return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) &rv = -1; <if (index <0) &rv = -1; else rv = -1;
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index 0) rval = res = 0; break; if (index >= 0) rval = rval;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = <1;
if (index >= 0) &if (index &0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; &else id = rowIndex;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index &0) delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; else if (!rowIndex) <res = &rowIndex; break;
if (getRowIndex(rowKey) &index) &break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (! eColIndex) &delete (rowKey); <else /* removeRow(index);
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index <= 0) /* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (!__PRECONDITION__) &if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (itemIndex > 0) <return; if (index = 0) <if (itemIndex = 0) return;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (increment) if (index > 0) &fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
nrows = 0; if (idx 0) *idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
if (index >= index) <mRows.removeElement(index); else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index == -1) &nsresult rv; *removeRow(index);
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (rowIndex &= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (item) &for (i = 0; i <index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index 0) rval = res = 0; break; &&if (index >= 0) rval = rval;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else <rl = 0;
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index == 0) &return 0;
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %sn", rowIndex);
if (rowIndex >= 0) if (rowIndex &rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if ((index = -1 && index >= 0)) <*index = 0; else &*index = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
r = getRowIndex(rowKey); if (r) <r = retval;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (increment) if (index > 0) &fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index == -1) r = 0; &if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index &0) <rval = res = 0; break; &&if (index >= 0) rval = rval;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (increment) <if (index > 0) fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index 0) &rval = res = 0; break; <<if (index >= 0) rval = rval;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; &&else *rowIndex = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index &0) <delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; &else id = rowIndex;
if (rowIndex >= index) return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nrows = 0; if (idx 0) *idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index > 0) if (rowIndex 1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); else <fprintf(stderr, "Couldn't get row index");
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; <else *rowIndex = 0;
if (index == -1) <r = 0; <if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index == -1) &if (isPositioned) &removeRow(index);
if (rowIndex &= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (itemIndex > 0) <return; &if (index &= 0) &if (itemIndex = 0) return;
if (increment) if (index > 0) fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
<if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; &else &id = rowIndex;
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index >= 0) <if (instRow) <removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
&int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) <nsAutoString rowKey('0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= index) &mRows.removeElement(index); else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) &rval = 0; else <rval = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex == 0) <*rowIndex = index; &else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (rowIndex >= 0) if (rowIndex rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = &1;
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &= 0) /* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index > 0) <if (rowIndex &1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index) &if (rowIndex > 0) &if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) <if (instRow) &removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (index >= 0) &rv = -1; &if (index &0) &rv = -1; else rv = -1;
if (index) if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
<int index = 0; for (index = 0; index rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) rval = -1; &else rval = 0;
if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (itemIndex > 0) return; &if (index &= 0) &if (itemIndex = 0) return;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index >= 0) <nsAutoString rowKey('0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) <if (instRow) <removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index > 0) <if (rowIndex 1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index == 0) i++; <else <if (rowIndex >= rowKey) <break;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index) &if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) <if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; else <id = rowIndex;
if (index) <if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index &0) &break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (index > 0) &if (rowIndex <1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
mPadding--; if (index >= 0) mPadding--; <<else <mPadding--;
if (index == -1) <r = 0; &if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if (index == -1) r = 0; <if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (index == 0) i++; <else <if (rowIndex >= rowKey) break;
<if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s<n", rowIndex);
if (!rowKey) &if (rowIndex > 0) &removeRow(index); &else fprintf(stderr, "Couldn't get row index");
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) break;
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if ((index = -1 && index >= 0)) &*index = 0; &else <*index = 0;
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
mPadding--; if (index >= 0) &mPadding--; &<else mPadding--;
if (rowIndex = 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!__PRECONDITION__) <if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (index 0) break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex == 0) &*rowIndex = index; else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index >= index) &mRows.removeElement(index); &else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (itemIndex > 0) <return; <if (index &= 0) <if (itemIndex = 0) return;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else <rl = 0;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= 0) if (instRow) removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (index >= 0) &rval = 0; &else <rval = 0;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex = 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; else id = rowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!getRowIndex(rowKey)) </* delete row index */ return;
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= 0) &nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) <rv = -1; <if (index 0) rv = -1; else rv = -1;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (item) <for (i = 0; i <index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index == 0) <i++; else if (rowIndex >= rowKey) &break;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (getRowIndex(rowKey) <index) &break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index > 0) <if (rowIndex <1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= 0) &rval = 0; else &rval = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex <= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index) if (rowIndex > 0) &if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index) &if (!item) return NS_ERROR_NULL_POINTER;
if (index > 0) if (rowIndex 1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
mPadding--; if (index >= 0) &mPadding--; &&else mPadding--;
if (index >= 0) <rv = -1; if (index <0) &rv = -1; else rv = -1;
if (item) for (i = 0; i &index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index 0) &delete(index);
if (index) <if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else <rl = 0;
if (!rowKey) &if (rowIndex > 0) removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index == 0) </* * Recycle the row if the row index isn't. */ rv = removeRow(index); if (NS_FAILED(rv)) return;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (index = 0) mTreeItem.removeRow(index);
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index > 0) <if (rowIndex <1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; else if (!rowIndex) res = &rowIndex; break;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (rowIndex >= 0) if (rowIndex <rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
if (increment) &if (index > 0) fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index) <removeRow(index);
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) &removeRow(index);
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
nsresult rv = NS_OK; if (null == rv) <nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; &rv = NS_OK;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if ((index = -1 && index >= 0)) <*index = 0; &else *index = 0;
if (index > 0) <if (colIndex &0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex &index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (colIndex <0) removeRow(rowIndex);
if (index >= 0) rv = -1; if (index 0) &rv = -1; else rv = -1;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex >= index) &return 0; <if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
return (rowIndex = index)? 0 : 0;
if (index >= 0) if (index &0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index > 0) <if (colIndex 0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (index >= 0) <nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nrows = 0; if (idx &0) <*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nrows = 0; if (idx 0) *idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (index > 0) ret = index, rowIndex ;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); else mTree.removeRow(index);
if (rowIndex &index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (item) &for (i = 0; i <index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) <if (!row) return; <if (row) return;
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (increment) if (index > 0) fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex &index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex == 0) *rowIndex = index; &else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowKey == null) <nsCRT::free(rowKey);
if (getRowIndex(rowKey) index) <break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) <if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == 0) <*rowIndex = index; else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index == -1) &r = 0; if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index) &rval = -1; else rval = 0;
if (index &0) <delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) &if (!row) return; &if (row) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex >= 0) if (rowIndex rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* XXX */ if (!rowKey) &return NS_ERROR_OUT_OF_MEMORY;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex >= 0) if (rowIndex &rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index <0) &break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!rowIndex) <mInFlow = false; &else &mInFlow = false;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) if (!row) return; if (row) return;
if (index >= 0) nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index >= 0) &if (index 0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (increment) if (index > 0) fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) &rv = -1; &if (index 0) <rv = -1; else rv = -1;
if (rowIndex <index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index > 0) &if (colIndex 0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
res = removeRow(index); if (NS_FAILED(res)) &break;
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
nrows = 0; if (idx &0) *idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (itemIndex > 0) <return; if (index <= 0) if (itemIndex = 0) return;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (item) &for (i = 0; i <index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index == 0) return;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (itemIndex > 0) &return; if (index <= 0) &if (itemIndex = 0) return;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= 0) &if (instRow) &removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index) if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= index) <mRows.removeElement(index); &else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= 0) <rv = -1; <if (index <0) <rv = -1; else rv = -1;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) if (index 0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
mPadding--; if (index >= 0) &mPadding--; &<else &mPadding--;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index &0) &rval = res = 0; break; &&if (index >= 0) rval = rval;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex > 0) fprintf(stderr, "%s: removeRow(%d)<n",rowIndex,rowIndex);
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (index == -1) <nsresult rv; *removeRow(index);
if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if (index <= 0) /* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
if (index == -1) &r = 0; &if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
&if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (item) for (i = 0; i <index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex 0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
if (index 0) break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) &return 0;
if (index > 0) &if (rowIndex &1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex >= 0) &if (rowIndex &rowIndex) <if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index >= index) &mRows.removeElement(index); <else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index 0) &break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex <= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; <else <id = rowIndex;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == 0) i++; &else <if (rowIndex >= rowKey) break;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); <else &mTree.removeRow(index);
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) if (!row) return; <if (row) return;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
&int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (index >= 0) <rval = 0; else rval = 0;
if (rowIndex index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) <if (rowIndex > 0) &if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index == 0) &i++; else <if (rowIndex >= rowKey) <break;
if (rowIndex = 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
&if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; else <id = rowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; <else <id = rowIndex;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s<n", rowIndex);
if (!rowKey) if (rowIndex > 0) removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (getRowIndex(rowKey) &index) &break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
nrows = 0; if (idx 0) &*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index >= 0) <nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) <nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nrows = 0; if (idx 0) <*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
&int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = &1&;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index > 0) &if (colIndex &0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (! eColIndex) <delete (rowKey); <else &/* removeRow(index);
if (index > 0) &if (rowIndex <1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index) &if (rowIndex > 0) &if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index >= 0) &if (instRow) &removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
mPadding--; if (index >= 0) <mPadding--; else &mPadding--;
if (increment) if (index > 0) &fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex <= 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index == 0) <i++; <else <if (rowIndex >= rowKey) <break;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = &1<;
if (rowIndex <index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) <if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); <else fprintf(stderr, "Couldn't get row index");
if (index >= 0) &nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; <else if (!rowIndex) <res = &rowIndex; break;
if (index > 0) <if (colIndex <0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex >= index) &return 0; if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index) rval = -1; &else &rval = 0;
if (itemIndex > 0) return; &if (index = 0) &if (itemIndex = 0) return;
if (rowIndex >= 0) if (rowIndex <rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index == 0) <i++; <else if (rowIndex >= rowKey) break;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (rowIndex == 0) &*rowIndex = index; <else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index) deleteRow(index);
if (itemIndex > 0) &return; <if (index = 0) <if (itemIndex = 0) return;
if (index == -1) &r = 0; <if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) <if (!row) return; if (row) return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
if (item) &for (i = 0; i index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (increment) if (index > 0) <fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index = 0) /* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (index >= 0) &if (instRow) removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index) rval = -1; <else <rval = 0;
if (index >= 0) rv = -1; if (index &0) rv = -1; else rv = -1;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!rowKey) <if (rowIndex > 0) removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index = 0) </* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (rowIndex >= 0) &if (rowIndex <rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
mPadding--; if (index >= 0) <mPadding--; <&else <mPadding--;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index &0) &break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
mPadding--; if (index >= 0) &mPadding--; <&else mPadding--;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex <= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index 0) <break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) if (index >= 0) <return;
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
mPadding--; if (index >= 0) mPadding--; <else mPadding--;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex &index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (getRowIndex(rowKey) <index) <break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index = 0) </* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
mPadding--; if (index >= 0) <mPadding--; &else mPadding--;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (rowIndex == 0) &*rowIndex = index; else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index 0) delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex == 0) <*rowIndex = index; <else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index &0) &break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else rl = 0;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= 0) break;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index) removeRow(index); else deleteRow(index);
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (getRowIndex(rowKey) index) break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (getRowIndex(rowKey) &index) <break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!rowKey) &if (rowIndex > 0) &removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex >= 0) <if (rowIndex rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index &0) &delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex == 0) *rowIndex = index; <else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= 0) <return 0;
if (item) for (i = 0; i &index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!__PRECONDITION__) &if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (rowIndex >= index) return 0; if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (!__PRECONDITION__) if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (rowIndex == 0) *rowIndex = index; else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
mPadding--; if (index >= 0) &mPadding--; &&else <mPadding--;
if (rowIndex >= 0) <removeRow(rowIndex);
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; else id = rowIndex;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index) &if (rowIndex > 0) if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index) if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index &0) delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; else *rowIndex = 0;
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
&if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowIndex >= index) return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index >= 0) if (index 0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (rowIndex >= 0) if (rowIndex <rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
if (index == 0) &i++; &else &if (rowIndex >= rowKey) &break;
if (index >= index) mRows.removeElement(index); &else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index &0) rval = res = 0; break; &if (index >= 0) rval = rval;
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; else id = rowIndex;
if (colIndex &0) removeRow(rowIndex);
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else &rl = 0;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index == 0) i++; else if (rowIndex >= rowKey) break;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == 0) &*rowIndex = index; <else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index) if (!item) return NS_ERROR_NULL_POINTER;
&int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (itemIndex > 0) return; <if (index <= 0) if (itemIndex = 0) return;
&if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) r = 0; <if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index > 0) if (rowIndex &1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (itemIndex > 0) <return; <if (index = 0) <if (itemIndex = 0) return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index >= 0) nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (item) <for (i = 0; i index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= 0) <if (instRow) <removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (getRowIndex(rowKey) &index) <break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == 0) return 0;
if (index 0) <rval = res = 0; break; &if (index >= 0) rval = rval;
if (index >= 0) &nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) &if (!row) return; if (row) return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index >= 0) <if (instRow) &removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex <index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if ((index = -1 && index >= 0)) *index = 0; <else <*index = 0;
if (index >= 0) if (index <0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex >= 0) <if (rowIndex <rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (index &0) <removeRow(index);
if (getIndex() &0) return 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (!rowKey) if (rowIndex > 0) &removeRow(index); else <fprintf(stderr, "Couldn't get row index");
if (index) <if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (itemIndex > 0) <return; &if (index = 0) <if (itemIndex = 0) return;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) &rval = res = 0; break; <if (index >= 0) rval = rval;
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) if (!row) return; if (row) return;
if (rowIndex &= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
if (!rowKey) <if (rowIndex > 0) removeRow(index); else <fprintf(stderr, "Couldn't get row index");
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= index) mRows.removeElement(index); &else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex &= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!__PRECONDITION__) &if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (index == -1) <r = 0; &if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; else id = rowIndex;
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex >= index) &return 0; if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) &if (rowIndex rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= 0) if (index &0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!rowKey) <if (rowIndex > 0) removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (index == 0) i++; <else &if (rowIndex >= rowKey) <break;
if (index >= 0) &nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index 0) return;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (!rowIndex) &mInFlow = false; &else &mInFlow = false;
if (index >= 0) &nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= 0) <nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index <0) &rval = res = 0; break; <&if (index >= 0) rval = rval;
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index == -1) &r = 0; &if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (rowIndex == 0) <*rowIndex = index; &else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index >= 0) rv = -1; <if (index &0) &rv = -1; else rv = -1;
if (rowIndex > 0) <removeRow(index);
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= index) mRows.removeElement(index); &else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index 0) &break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index &0) return;
if (index) <if (rowIndex > 0) if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (index == 0) i++; else &if (rowIndex >= rowKey) break;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index) <if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index > 0) &if (rowIndex 1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex <index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index > 0) if (rowIndex <1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index > 0) &if (colIndex &0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (item) for (i = 0; i <index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index 0) <rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index) <removeRow(index); <else &deleteRow(index);
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = 1&;
if (index 0) removeRow(index);
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (item) for (i = 0; i &index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = &1<;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index 0) &delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
res = removeRow(index); if (NS_FAILED(res)) <break;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = &1;
if (rowIndex == 0) *rowIndex = index; else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (index >= 0) &rv = -1; &if (index 0) &rv = -1; else rv = -1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= 0) if (instRow) removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index <= 0) </* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); else mTree.removeRow(index);
if (item) <for (i = 0; i <index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!rowIndex) &mInFlow = false; <else &mInFlow = false;
mPadding--; if (index >= 0) &mPadding--; &else <mPadding--;
if (index >= 0) <nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index) if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) if (rowIndex > 0) <if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
&int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index == -1) &r = 0; &if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); else &mTree.removeRow(index);
if (index <0) <rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index &0) <delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index == -1) <r = 0; &if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; <&else *rowIndex = 0;
if (rowIndex <= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index > 0) <if (rowIndex 1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (item) <for (i = 0; i &index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex &index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex == 0) &*rowIndex = index; else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index 0) rval = res = 0; break; <if (index >= 0) rval = rval;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <break;
fprintf(stdout, "removeRow: %s&n", index);
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) <if (!row) return; &if (row) return;
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index > 0) if (rowIndex &1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) <if (rowIndex > 0) <if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = 1;
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) &if (index 0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index == 0) &i++; else if (rowIndex >= rowKey) <break;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (getRowIndex(rowKey) index) &break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index) if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
fprintf(stderr, "removeRow()<n");
if (index >= 0) &if (instRow) <removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex >= 0) if (rowIndex &rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else <rl = 0;
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index == -1) r = 0; &if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); <else mTree.removeRow(index);
if (rowIndex >= index) &return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) &if (rowIndex <rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex 0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex <= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index >= 0) rval = 0; else <rval = 0;
if (index == 0) i++; <else &if (rowIndex >= rowKey) &break;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowKey) <nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex &rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int rowIndex; if (!rowIndex) &delete rowIndex; rowIndex = rowIndex;
int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); else <mTree.removeRow(index);
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index <1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex &index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index <0) &removeRow(index);
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (increment) <if (index > 0) fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex == 0) *rowIndex = index; else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = 1;
if (index >= 0) &if (index <0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if ((index = -1 && index >= 0)) &*index = 0; &else *index = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == -1) r = 0; <if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= 0) <rv = -1; <if (index &0) <rv = -1; else rv = -1;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index >= 0) &nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex >= index) return 0; <if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index == 0) <i++; else &if (rowIndex >= rowKey) &break;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index &0) break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex <= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index > 0) if (colIndex 0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (getRowIndex(rowKey) <index) &break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) <if (instRow) &removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (item) <for (i = 0; i &index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index <= 0) </* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index > 0) ret = <index, rowIndex ;
if (index <0) rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index) if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index 0) rval = res = 0; break; &if (index >= 0) rval = rval;
if (index == 0) &i++; <else <if (rowIndex >= rowKey) <break;
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
retRow = ((int)index) / floats; <else &retRow = ((int)index) / floats;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) if (!row) return; <if (row) return;
int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index > 0) <if (rowIndex <1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (itemIndex > 0) <return; if (index &= 0) <if (itemIndex = 0) return;
if (index >= 0) rval = 0; <else &rval = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= 0) <if (instRow) &removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index > 0) &if (rowIndex 1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; <&else *rowIndex = 0;
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == 0) &i++; <else &if (rowIndex >= rowKey) <break;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else rl = 0;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else <rl = 0;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) &if (!row) return; <if (row) return;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index > 0) <if (colIndex 0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex <= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= 0) &if (index 0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index == -1) &r = 0; <if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index <0) <delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index) if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= index) mRows.removeElement(index); <else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
fprintf(stderr, "removeRow()&n");
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index) removeRow(index);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (rowIndex <= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index > 0) &if (colIndex 0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (getIndex() 0) &return 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!rowState.IsEmpty()) return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!rowKey) <if (rowIndex > 0) <removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index 0) <rval = res = 0; break; <if (index >= 0) rval = rval;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index) if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex > 0) <fprintf(stderr, "%s: removeRow(%d)&n",rowIndex,rowIndex);
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!mPosition) return;
if (item) &for (i = 0; i index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (increment) &if (index > 0) fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (item) for (i = 0; i &index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
nrows = 0; if (idx &0) *idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index > 0) <if (rowIndex 1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
fprintf(stderr, "removeRow: row=%dn", index);
nrows = 0; if (idx 0) <*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!getRowIndex(rowKey)) /* delete row index */ return;
if (index) if (rowIndex > 0) &if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index) <if (rowIndex > 0) &if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!__PRECONDITION__) if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= 0) <rval = 0; <else &rval = 0;
if (index) <if (!sid) &fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index <0) break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
&if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) &if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (rowIndex >= 0) if (rowIndex <rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= 0) &nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = <1<;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (!rowKey) if (rowIndex > 0) removeRow(index); else fprintf(stderr, "Couldn't get row index");
<if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); <else &mTree.removeRow(index);
nrows = 0; if (idx &0) <*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex = 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s<n", rowIndex);
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index) <deleteRow(index);
if (index 0) delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index >= 0) &rv = -1; &if (index <0) rv = -1; else rv = -1;
if (index > 0) &if (rowIndex 1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= 0) <nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (getRowIndex(rowKey) index) break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
&if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else <rl = 0;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; &<else *rowIndex = 0;
if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
if (index > 0) <ret = index, rowIndex &;
if (index <0) &rval = res = 0; break; <<if (index >= 0) rval = rval;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) &if (!row) return; <if (row) return;
if (getRowIndex(rowKey) == -1) &removeRow(index);
if (index <0) &break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex = 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else rl = 0;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex > 0) &removeRow(index);
if (index) <if (rowIndex > 0) if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (itemIndex > 0) &return; &if (index <= 0) &if (itemIndex = 0) return;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex == 0) <*rowIndex = index; &else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index = 0) </* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) &if (!row) return; if (row) return;
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (rowIndex index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index > 0) &ret = &index, rowIndex ;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
mPadding--; if (index >= 0) <mPadding--; &else &mPadding--;
if (index == -1) &r = 0; if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= index) mRows.removeElement(index); &else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index > 0) <if (colIndex <0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) if (!row) return; &if (row) return;
if (index >= index) mRows.removeElement(index); <else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if ((index = -1 && index >= 0)) *index = 0; &else &*index = 0;
if (rowIndex index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index <0) break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index 0) &delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index > 0) &if (colIndex 0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex <index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!__PRECONDITION__) if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); &else &mTree.removeRow(index);
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else <rl = 0;
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (item) &for (i = 0; i index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex &index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index <0) &delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = <1;
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex == 0) <*rowIndex = index; <else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == null) nsCRT::free(rowKey);
if (index 0) delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; &else id = rowIndex;
if (index >= 0) &rval = 0; else rval = 0;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = 1&;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else <rl = 0;
if ((index = -1 && index >= 0)) &*index = 0; <else <*index = 0;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (rowIndex >= index) <return 0; if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index > 0) if (colIndex &0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (item) &for (i = 0; i &index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == 0) &*rowIndex = index; &else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index == -1) &return;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; else &id = rowIndex;
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <0) &rval = res = 0; break; if (index >= 0) rval = rval;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index > 0) if (colIndex 0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index == 0) &i++; else <if (rowIndex >= rowKey) &break;
if (index > 0) if (rowIndex 1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index > 0) &if (colIndex &0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index &0) &delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!getRowIndex(rowKey)) break;
nrows = 0; if (idx &0) *idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else &rl = 0;
if (!rowState.IsEmpty()) return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
mPadding--; if (index >= 0) mPadding--; &&else <mPadding--;
if (index >= 0) if (index 0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (itemIndex > 0) &return; <if (index = 0) if (itemIndex = 0) return;
if (rowIndex == 0) <*rowIndex = index; &else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex >= 0) &if (rowIndex &rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index &0) <delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= 0) <if (index &0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index 0) &rval = res = 0; break; if (index >= 0) rval = rval;
if (rowIndex > 0) removeRow(rowIndex);
if (index &0) break;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index > 0) if (colIndex <0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) rv = -1; if (index &0) &rv = -1; else rv = -1;
if (index <0) delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!mState) /* Remove row */
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index) &if (!sid) fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index) <if (rowIndex > 0) &if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (getRowIndex(rowKey) index) &break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= 0) <nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= index) &mRows.removeElement(index); <else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; <else if (!rowIndex) &res = &rowIndex; break;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; <else <id = rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = &1&;
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
<int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index <0) delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index == 0) <i++; <else if (rowIndex >= rowKey) <break;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) break;
if (index &= 0) </* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!getRowIndex(rowKey)) <break;
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (item) <for (i = 0; i <index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
mPadding--; if (index >= 0) <mPadding--; &<else &mPadding--;
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index &0) &delete(index);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) if (index <0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex <index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index > 0) <if (rowIndex 1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= 0) if (instRow) removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex == 0) &*rowIndex = index; else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
mPadding--; if (index >= 0) &mPadding--; <<else &mPadding--;
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex >= 0) if (rowIndex <rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (getRowIndex(rowKey) index) <break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index == -1) &r = 0; <if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex 0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (rowIndex 0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (getRowIndex(rowKey) <index) break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index > 0) <if (colIndex 0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index &0) <delete(index);
if (index > 0) if (rowIndex 1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) &if (instRow) removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (itemIndex > 0) return; &if (index <= 0) &if (itemIndex = 0) return;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowIndex &= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex == 0) *rowIndex = index; <else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (index = 0) &/* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
<if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (index >= index) &mRows.removeElement(index); <else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else rl = 0;
if (item) &for (i = 0; i &index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= 0) <if (instRow) removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = &1;
if (index >= 0) <if (instRow) removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index >= 0) &if (instRow) <removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex >= index) return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index == 0) <i++; &else &if (rowIndex >= rowKey) <break;
if (index = 0) /* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (itemIndex > 0) <return; &if (index = 0) &if (itemIndex = 0) return;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!rowIndex) &mInFlow = false; else <mInFlow = false;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index &0) &delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
return (rowIndex <= index)? 0 : 0;
if (index >= 0) <rv = -1; <if (index &0) rv = -1; else rv = -1;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; &<else *rowIndex = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!rowIndex) mInFlow = false; <else mInFlow = false;
nrows = 0; if (idx <0) <*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else <rl = 0;
if (rowIndex index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if ((index = -1 && index >= 0)) &*index = 0; else *index = 0;
if (index > 0) if (colIndex 0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index <0) <return;
if (rowIndex <index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; <else if (index 0) return; else return;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (itemIndex > 0) return; &if (index <= 0) <if (itemIndex = 0) return;
if (!rowKey) <if (rowIndex > 0) removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) &if (index <0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= 0) <if (index 0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= 0) <if (index 0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = &1&;
if (index >= 0) <if (index <0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= 0) &if (instRow) <removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex <index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index >= index) <mRows.removeElement(index); else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index &0) <break;
if (index) <if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex >= 0) &if (rowIndex rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (getRowIndex(rowKey) <index) break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (getRowIndex(rowKey) <index) break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index >= 0) nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; &&else *rowIndex = 0;
if (!rowIndex) <mInFlow = false; &else mInFlow = false;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; else *rowIndex = 0;
if (rowIndex = 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index &0) break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= 0) &nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (!rowIndex) <mInFlow = false; <else <mInFlow = false;
if (index >= 0) &rval = 0; <else &rval = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (getRowIndex(rowKey) &index) &break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (! eColIndex) &delete (rowKey); &else &/* removeRow(index);
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nrows = 0; if (idx &0) &*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) &removeRow(index);
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index &0) &delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index >= 0) if (instRow) removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index == 0) removeRow(index);
if (item) <for (i = 0; i <index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index &0) &rval = res = 0; break; <<if (index >= 0) rval = rval;
if (index >= 0) nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == 0) <*rowIndex = index; &else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index > 0) if (rowIndex <1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
mPadding--; if (index >= 0) &mPadding--; <&else &mPadding--;
if (index >= 0) &nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (!rowKey) if (rowIndex > 0) <removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index &0) delete(index);
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else rl = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex &0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (getRowIndex(rowKey) <index) <break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (! eColIndex) delete (rowKey); &else &/* removeRow(index);
removeRow(index); /* * If the row &a row, we do not want to get this in the row. */
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (! eColIndex) delete (rowKey); &else </* removeRow(index);
if (itemIndex > 0) return; &if (index = 0) <if (itemIndex = 0) return;
if (index > 0) <if (colIndex <0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= index) &mRows.removeElement(index); <else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index >= index) mRows.removeElement(index); &else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index == 0) <i++; &else if (rowIndex >= rowKey) break;
if (index) &if (rowIndex > 0) <if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) if (rowIndex > 0) <if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index <= 0) /* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (! eColIndex) delete (rowKey); <else &/* removeRow(index);
if (rowIndex == 0) *rowIndex = index; &else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == 0) &i++; else if (rowIndex >= rowKey) break;
if (rowIndex > 0) &removeRow(rowIndex);
nrows = 0; if (idx <0) *idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (!getRowIndex(rowKey)) &return;
if (index) <rval = -1; else rval = 0;
if (removeRow(index)) <return 0;
if (index) <if (rowIndex > 0) <if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; else &id = rowIndex;
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) if (index 0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowKey) nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex &rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (removeRow(index)) <return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
mPadding--; if (index >= 0) mPadding--; <<else mPadding--;
if (index >= 0) &nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index <0) <break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex >= 0) <if (rowIndex rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
mPadding--; if (index >= 0) <mPadding--; <&else mPadding--;
if (index > 0) <if (rowIndex 1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= index) mRows.removeElement(index); else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index = 0) /* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!rowKey) <if (rowIndex > 0) &removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; else *rowIndex = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; &else &id = rowIndex;
if (!selection || index == 0) &if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) &if (index <0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex >= 0) <if (rowIndex <rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index > 0) if (colIndex <0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index > 0) ret = <index, rowIndex &;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex <index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index == -1) removeRow(index);
if (index >= index) &mRows.removeElement(index); &else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index > 0) ret = &index, rowIndex <;
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if ((index = -1 && index >= 0)) <*index = 0; &else <*index = 0;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index %s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex >= index) &return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (rowIndex == 0) <*rowIndex = index; <else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index >= 0) if (index <0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex &index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index 0) rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index == -1) &r = 0; <if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (!__PRECONDITION__) &if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowKey) &if (rowIndex > 0) &removeRow(index); else <fprintf(stderr, "Couldn't get row index");
if (index == -1) <r = 0; &if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; <else id = rowIndex;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!aRowIndex) nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) &nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index &0) <rval = res = 0; break; &<if (index >= 0) rval = rval;
if (itemIndex > 0) return; &if (index &= 0) <if (itemIndex = 0) return;
if (index >= 0) rv = -1; <if (index <0) rv = -1; else rv = -1;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
nrows = 0; if (idx 0) &*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex <= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (getRowIndex(rowKey) <index) <break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (increment) if (index > 0) fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; <<else *rowIndex = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (!rowIndex) mInFlow = false; else mInFlow = false;
nsresult rv = NS_OK; if (null == rv) &nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; <rv = NS_OK;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (item) &for (i = 0; i &index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (getRowIndex(rowKey) index) &break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (itemIndex > 0) <return; &if (index <= 0) if (itemIndex = 0) return;
if ((index = -1 && index >= 0)) &*index = 0; <else *index = 0;
if (index >= 0) if (instRow) <removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index > 0) <if (rowIndex <1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (increment) if (index > 0) fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) if (index &0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index <0) rval = res = 0; break; <<if (index >= 0) rval = rval;
if (index 0) &delete (int)rowKey;
if (index > 0) <if (rowIndex &1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (!rowKey) if (rowIndex > 0) &removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (rowIndex == 0) &*rowIndex = index; &else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (index <0) &delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index > 0) <if (colIndex 0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) break;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) &if (!row) return; &if (row) return;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex >= 0) <if (rowIndex &rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else fs_brd.fs_id = 0;
if (index 0) &break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= index) &mRows.removeElement(index); <else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index) <removeRow(index); <else deleteRow(index);
if (!rowKey) &if (rowIndex > 0) removeRow(index); else fprintf(stderr, "Couldn't get row index");
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index == 0) &break;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; <else if (!rowIndex) res = &rowIndex; break;
&int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index <0) &break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index >= 0) <nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) if (instRow) &removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index <0) <delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); /* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex >= 0) if (rowIndex &rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else rl = 0;
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index &= 0) /* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) &nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; <else <id = rowIndex;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index) if (rowIndex > 0) if (index > 0) if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index &= 0) </* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index &0) rval = res = 0; break; <<if (index >= 0) rval = rval;
if (rowIndex &= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (item) <for (i = 0; i &index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) if (!row) return; &if (row) return;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index >= 0) &nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (item) for (i = 0; i <index; i++) *i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if ((index = -1 && index >= 0)) *index = 0; &else <*index = 0;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex <= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index <0) &rval = res = 0; break; &if (index >= 0) rval = rval;
if (index <0) return;
if (index) <if (rowIndex > 0) &if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; <else &id = rowIndex;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
fprintf(stderr, "removeRow: %s<n", index);
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index <= 0) <mTreeItem.removeRow(index);
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index <0) break;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; else if (index 0) return; else return;
&int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index == 0) &removeRow(index);
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = 1<;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index >= 0) rv = -1; &if (index 0) <rv = -1; else rv = -1;
if (index == 0) <i++; else if (rowIndex >= rowKey) <break;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; <else id = rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
r = getRowIndex(rowKey); if (r) &if (!r) &if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index) <if (rowIndex > 0) if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index > 0) &if (rowIndex <1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (!sc) &fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) &if (instRow) removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index 0) delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index) <removeRow(index); else &deleteRow(index);
if (rowIndex <index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = <1;
mPadding--; if (index >= 0) <mPadding--; <else mPadding--;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!__PRECONDITION__) if (index > 0) if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; &else if (!rowIndex) &res = &rowIndex; break;
if (index <0) <delete row;
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
if (rowIndex >= index) return 0; <if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s&n", rowIndex);
if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = &1;
if (item) &for (i = 0; i <index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= 0) <nsAutoString rowKey('0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index 0) <delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
<int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (!__PRECONDITION__) <if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
if (index 0) <break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index) removeRow(index); &else &deleteRow(index);
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
&if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowKey == mRowKey) if (rowKey == mRowKey) mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (removeRow(index)) fprintf(stderr, "removeRow %d&n", index);
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex = 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = &1;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index) <if (rowIndex > 0) if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = &1<;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index > 0) if (colIndex &0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index == -1) <r = 0; &if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
mPadding--; if (index >= 0) mPadding--; else <mPadding--;
if (removeRow(index)) <delete row;
nrows = 0; if (idx <0) <*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex >= 0) &if (rowIndex &rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index == 0) <i++; &else if (rowIndex >= rowKey) &break;
if (increment) <if (index > 0) fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) rv = -1; if (index <0) rv = -1; else rv = -1;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; <<else *rowIndex = 0;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else <rl = 0;
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) return;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
nrows = 0; if (idx &0) <*idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index == 0) i++; <else if (rowIndex >= rowKey) <break;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else <rl = 0;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
if (index &0) &break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else &rl = 0;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == -1) return 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else rl = 0;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index > 0) if (colIndex &0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index 0) &rval = res = 0; break; <&if (index >= 0) rval = rval;
mPadding--; if (index >= 0) mPadding--; &else mPadding--;
if (rowIndex >= index) &return 0; &if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else if (row) &if (!row) return; <if (row) return;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
nrows = 0; if (idx <0) *idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &break;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &id = rowIndex; &else <id = rowIndex;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; <&else *rowIndex = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) <if (!row) return; &if (row) return;
if (index == 0) i++; &else if (rowIndex >= rowKey) break;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
<if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = &1&;
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
&int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %sn", rowIndex);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
<int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex &= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; else <id = rowIndex;
if (index) <if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == 0) <*rowIndex = index; else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else <rl = 0;
if (index 0) <break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nrows = 0; if (idx &0) *idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex == 0) <*rowIndex = index; else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else rl = 0;
if (rowIndex index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (itemIndex > 0) <return; if (index &= 0) &if (itemIndex = 0) return;
if (index) &if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (index >= 0) &if (instRow) removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) <if (!row) return; <if (row) return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (getRowIndex(rowKey) index) break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) <if (rowIndex > 0) &if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index >= 0) &rv = -1; <if (index &0) rv = -1; else rv = -1;
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex <= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index <0) <rval = res = 0; break; <if (index >= 0) rval = rval;
if (rowIndex <index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (getRowIndex(rowKey) <index) break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
<if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (index >= 0) <if (instRow) removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
<int index = 0; for (index = 0; index rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) &if (!row) return; &if (row) return;
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else rl = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index) &removeRow(index); &else <deleteRow(index);
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = &1&;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex >= index) <return 0; if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index >= 0) <if (instRow) &removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (getRowIndex(rowKey) &index) <break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (item) <for (i = 0; i &index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex >= index) <return 0; if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index >= index) mRows.removeElement(index); <else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) <if (!row) return; &if (row) return;
if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int rowIndex; if (!rowIndex) delete rowIndex; rowIndex = rowIndex;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index &= 0) /* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (increment) <if (index > 0) <fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
r = getRowIndex(rowKey); if (r) &r = retval;
if (index >= 0) <rval = 0; else <rval = 0;
if (index 0) <delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; <else *rowIndex = 0;
if (index >= 0) rval = 0; &else <rval = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index > 0) ret = &index, rowIndex ;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; &else &id = rowIndex;
<int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) &if (!row) return; <if (row) return;
if (index <0) <break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index) if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex 0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!getRowIndex(rowKey)) &/* delete row index */ return;
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
if (index >= 0) nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == 0) &*rowIndex = index; &else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index > 0) &if (colIndex <0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (inLine) <if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (index) removeRow(index); <else <deleteRow(index);
if (rowIndex >= 0) &removeRow(rowIndex);
if (index >= 0) &if (instRow) <removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index 0) &delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex 0) <if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index) if (rowIndex > 0) <if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else rl = 0;
nrows = 0; if (idx <0) *idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else &rl = 0;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (itemIndex > 0) return; &if (index &= 0) if (itemIndex = 0) return;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) <if (instRow) removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (! eColIndex) delete (rowKey); else </* removeRow(index);
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; <<else *rowIndex = 0;
<if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (item) for (i = 0; i <index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= index) mRows.removeElement(index); <else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
<if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
retRow = ((int)index) / floats; else <retRow = ((int)index) / floats;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index > 0) <if (colIndex 0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (itemIndex > 0) &return; &if (index &= 0) <if (itemIndex = 0) return;
if (rowIndex <= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index == -1) <r = 0; &if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (index > 0) &if (colIndex <0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) if (instRow) <removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index == -1) r = 0; if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (rowIndex == 0) *rowIndex = index; <else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
nrows = 0; if (idx &0) *idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex == 0) <*rowIndex = index; else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = 1;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex > 0) &fprintf(stderr, "%s: removeRow(%d)n",rowIndex,rowIndex);
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) &if (!row) return; if (row) return;
if (index == 0) i++; &else if (rowIndex >= rowKey) <break;
mPadding--; if (index >= 0) &mPadding--; else mPadding--;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (rowIndex >= index) return 0; if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; &&else *rowIndex = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= 0) rv = -1; &if (index <0) rv = -1; else rv = -1;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else &rl = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index > 0) &if (rowIndex &1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= 0) <removeRow(index);
if (index >= index) mRows.removeElement(index); else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index >= 0) &rval = 0; <else rval = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = <1&;
if ((index = -1 && index >= 0)) *index = 0; <else *index = 0;
if (index >= 0) <rv = -1; &if (index <0) rv = -1; else rv = -1;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
fprintf(stderr, "removeRow: row=%d<n", index);
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index) rval = -1; else rval = 0;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * Remove RowIndex, index. */ if (rowIndex &0) <*rowIndex = 0; &&else *rowIndex = 0;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) <r = 0; if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (!rowKey) if (rowIndex > 0) removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (rowIndex > 0) removeRow(index);
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index) &if (rowIndex > 0) <if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index 0) &return 0;
if (index >= 0) &rv = -1; &if (index <0) &rv = -1; else rv = -1;
if (index) &if (rowIndex > 0) &if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); <else <rl = 0;
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) <removeRow(index); &else &deleteRow(index);
if (index >= index) <mRows.removeElement(index); else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index >= 0) &nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) nsAutoString rowKey('0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= index) mRows.removeElement(index); else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index 0) break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (! eColIndex) <delete (rowKey); else &/* removeRow(index);
if (rowIndex <index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index &index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index = 0) &/* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index == -1) &if (isPositioned) removeRow(index);
if (!selection || index == 0) &if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) &if (rowIndex > 0) <if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex &= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index = 0) &/* XXX */ if ((index >= 0) || (index &= 0)) <delete row; else /* XXX */
if (index > 0) if (colIndex &0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (item) for (i = 0; i <index; i++) &*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
<int index = 0; for (index = 0; index rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex >= index) return 0; &if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (index >= 0) &if (instRow) removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; &else *rowIndex = 0;
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index > 0) <ret = <index, rowIndex ;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (index 0) <delete(index);
mPadding--; if (index >= 0) mPadding--; &<else <mPadding--;
if (rowIndex <= 0) <nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (!__PRECONDITION__) if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) &mInner = r.next; mInner = r.next;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else rl = 0;
if (index == -1) <r = 0; if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index <0) rval = res = 0; break; if (index >= 0) rval = rval;
if (rowIndex >= index) &return 0; if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (getRowIndex(rowKey) <index) break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) <removeRow(index); else <deleteRow(index);
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) if (!row) return; &if (row) return;
if (index) if (rowIndex > 0) if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index 0) &break;
if (index) &if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) &if (!row) return; if (row) return;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (item) <for (i = 0; i index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (! eColIndex) <delete (rowKey); else </* removeRow(index);
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s&n", rowIndex);
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index 0) <removeRow(index);
if (index > 0) if (colIndex <0) return; if (index 0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= 0) rv = -1; <if (index &0) rv = -1; else rv = -1;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (itemIndex > 0) <return; <if (index = 0) if (itemIndex = 0) return;
if (index <= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = 1<;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex &index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= 0) &nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
nsPool* i = getRowIndex(rowKey); if (i <0) &if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == -1) <r = 0; &if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex == 0) <*rowIndex = index; else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex &index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
<int index = 0; for (index = 0; index <rowCount; index++) &if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
&if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
nrows = 0; if (idx <0) *idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; else id = rowIndex;
<if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex == 0) *rowIndex = index; else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index <0) delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (getRowIndex(rowKey) == -1) <removeRow(index);
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
ret = removeRow(index); if (ret == -1) &&/* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (rowIndex <index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (getRowIndex(rowKey) &index) &break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex == -1) <return 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = <1&;
if (index >= index) &mRows.removeElement(index); &else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) <return;
if (index) <if (rowIndex > 0) <if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowIndex &index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index 0) delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
&if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (index &= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) &if (rowIndex > 0) &if (index > 0) <if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (!rowKey) if (rowIndex > 0) &removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (index <0) break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; &else <id = rowIndex;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); &else <mTree.removeRow(index);
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = &1<;
if (index >= 0) &rv = -1; if (index 0) <rv = -1; else rv = -1;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex >= 0) <if (rowIndex rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index > 0) if (colIndex <0) return; if (index <0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index > 0) <if (rowIndex &1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
mPadding--; if (index >= 0) <mPadding--; <&else &mPadding--;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index == 0) i++; <else if (rowIndex >= rowKey) break;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (index 0) <delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index > 0) <if (colIndex 0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (!rowKey) if (rowIndex > 0) &removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (index 0) &removeRow(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index &0) <delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex <index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s<n", rowIndex);
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) if (instRow) <removeRow(index); else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (inLine) <if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = <1<;
if (getRowIndex(rowKey) &index) <break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) &if (instRow) <removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index == 0) &i++; <else if (rowIndex >= rowKey) <break;
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); &else &mTree.removeRow(index);
if (index) &rval = -1; &else &rval = 0;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; else mPos = mPos;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= 0) &break;
if (rowIndex >= 0) <if (rowIndex &rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex >= 0) <if (rowIndex <rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (index) &if (rowIndex > 0) &if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; &else *rowIndex = 0;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
mPadding--; if (index >= 0) mPadding--; else mPadding--;
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex >= 0) if (rowIndex rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
&int index = 0; for (index = 0; index &rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index >= 0) <rv = -1; &if (index &0) <rv = -1; else rv = -1;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == -1) <r = 0; &if (mRowIndex > 0) &if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else <rl = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index 0) return 0;
if (index) <if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (! eColIndex) <delete (rowKey); <else </* removeRow(index);
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index >= 0) &if (index <0) &if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) <id = rowIndex; else <id = rowIndex;
if (index >= 0) &nsAutoString rowKey('0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex <index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index &0) delete (int)rowKey;
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex <index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (getRowIndex(rowKey) index) <break; <if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
fprintf(stdout, "removeRown");
if (rowIndex 0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= 0) <rv = -1; &if (index 0) &rv = -1; else rv = -1;
if (!rowKey) &if (rowIndex > 0) &removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index > 0) &ret = <index, rowIndex &;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (itemIndex > 0) return; <if (index &= 0) if (itemIndex = 0) return;
if (rowIndex <= 0) &nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (itemIndex > 0) <return; &if (index &= 0) <if (itemIndex = 0) return;
removeRow(index); /* * If the row <a row, we do not want to get this in the row. */
if (index &= 0) <mTreeItem.removeRow(index);
if (index) <if (!item) return NS_ERROR_NULL_POINTER;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index 0) &break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else &if (row) <if (!row) return; if (row) return;
if (!rowState.IsEmpty()) <return 0; &if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (item) <for (i = 0; i &index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index >= 0) <if (instRow) removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (!rowKey) if (rowIndex > 0) <removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (removeRow(index)) <fprintf(stderr, "removeRow %d&n", index);
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
<if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
if (!__PRECONDITION__) &if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) <mInner = r.next; mInner = r.next;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s&n", rowIndex);
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowIndex) <mInFlow = false; <else &mInFlow = false;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = &1<;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); else <fprintf(stderr, "Couldn't get row index");
if (index >= 0) nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index == -1) <r = 0; if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex >= 0) &if (rowIndex <rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
nrows = 0; if (idx &0) &*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; <else &id = rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex >= index) <return 0; <if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index) if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index == -1) <r = 0; &if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) if (!row) return; <if (row) return;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; <else *rowIndex = 0;
if (index > 0) <removeRow(index);
nsCOMPtr&nsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index) &if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex == 0) *rowIndex = index; &else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index >= 0) <if (index 0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (item) for (i = 0; i index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
if (index > 0) &if (colIndex 0) return; if (index <0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
&int index = 0; for (index = 0; index rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
ret = removeRow(index); if (ret 0)
if (index >= 0) rval = 0; &else rval = 0;
nrows = 0; if (idx 0) <*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index <1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
nrows = 0; if (idx <0) <*idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; <if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex index) if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!sc) <fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; &else <fs_brd.fs_id = 0;
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (index >= 0) &rv = -1; if (index <0) <rv = -1; else rv = -1;
if (rowIndex >= index) &return 0; &if (rowIndex >= index) *rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index <0) &delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (colIndex &0) &removeRow(rowIndex);
if (index &= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) &rv = -1; <if (index 0) <rv = -1; else rv = -1;
if (itemIndex > 0) return; <if (index <= 0) <if (itemIndex = 0) return;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) <break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
removeRow(index); /* * If the row a row, we do not want to get this in the row. */
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (!rowKey) if (rowIndex > 0) <removeRow(index); <else fprintf(stderr, "Couldn't get row index");
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index <0) &delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex == 0) &*rowIndex = index; <else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove RowIndex, index. */ if (rowIndex <0) &*rowIndex = 0; <else *rowIndex = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
if (index <0) &break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) &if (!rowKey) return; else return; else return;
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex >= 0) &removeRow(index);
if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowIndex == 0) &*rowIndex = index; &else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index <0) &return 0;
/* * Remove RowIndex, index. */ if (rowIndex <0) *rowIndex = 0; <<else *rowIndex = 0;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (inPosition &= 0) &*inPosition = rowKey; return;
if (rowIndex index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; <<else *rowIndex = 0;
mPadding--; if (index >= 0) <mPadding--; &<else <mPadding--;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index 0) <break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index >= 0) <rv = -1; &if (index <0) &rv = -1; else rv = -1;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
nsPool* i = getRowIndex(rowKey); if (i <0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!rowKey) <if (rowIndex > 0) removeRow(index); else fprintf(stderr, "Couldn't get row index");
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; else <id = rowIndex;
if (rowIndex index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
mPadding--; if (index >= 0) mPadding--; &&else mPadding--;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= 0) <rv = -1; if (index &0) &rv = -1; else rv = -1;
<int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex >= index) &return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index &%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
nrows = 0; if (idx &0) &*idx = idx - rowIndex; &else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) &if (rowIndex > 0) if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
nsresult rv = NS_OK; if (null == rv) &nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; rv = NS_OK;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
nrows = 0; if (idx &0) *idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!rowIndex) &mInFlow = false; <else mInFlow = false;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index) if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; else mRowKey = mRowKey; else mRowKey = mRowKey;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index > 0) &if (rowIndex 1) return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index == -1) r = 0; if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) <rval = 0; <else rval = 0;
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!rowState.IsEmpty()) &return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index > 0) if (colIndex 0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex <= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
mPadding--; if (index >= 0) &mPadding--; else <mPadding--;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index) if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex = 0) nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) &if (index >= 0) return;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index) &if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) if (index <0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= 0) &if (instRow) &removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (index > 0) &if (colIndex 0) return; if (index &0) return; if (rowIndex 0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index &0) <delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) __FreeLocalize();
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex &0) if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; else <id = rowIndex;
if (index == -1) <r = 0; if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index) if (rowIndex > 0) <if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (increment) <if (index > 0) fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) if (instRow) &removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index >= 0) if (instRow) removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index) <if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; &else &id = rowIndex;
if (getRowIndex(rowKey) index) <break; &if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (! eColIndex) <delete (rowKey); <else /* removeRow(index);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex >= 0) <if (rowIndex rowIndex) if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index == 0) <i++; &else <if (rowIndex >= rowKey) &break;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index == 0) <i++; &else &if (rowIndex >= rowKey) break;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; <if (rowKey) if (!rowKey) return; else return; else return;
if (index 0) &return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index) if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index >= 0) &if (index <0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index == 0) <i++; else if (rowIndex >= rowKey) break;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else &rl = 0;
if (rowIndex 0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index <0) removeRow(index);
if (item) for (i = 0; i &index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
fprintf(stdout, "removeRow<n");
if (increment) if (index > 0) &fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index > 0) if (colIndex <0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index == -1) &r = 0; &if (mRowIndex > 0) <if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
if (rowIndex <0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; else if (!rowIndex) &res = &rowIndex; break;
if (!mPosition) &return;
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (rowIndex >= index) <return 0; if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (rowIndex >= 0) <if (rowIndex &rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
&int index = 0; for (index = 0; index rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex == 0) *rowIndex = index; <else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (rowIndex >= index) &return 0; if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (index >= 0) <nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (inPosition <= 0) &*inPosition = rowKey; return;
if (rowIndex > 0) &fprintf(stderr, "%s: removeRow(%d)&n",rowIndex,rowIndex);
if (index >= 0) nsAutoString rowKey('&0'); if (index &nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index) removeRow(index); <else &deleteRow(index);
if (!getRowIndex(rowKey)) if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!rowKey) &if (rowIndex > 0) &removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; &else *rowIndex = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (i == 0) &/* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowIndex == 0) *rowIndex = index; <else if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; <else &id = rowIndex;
nrows = 0; if (idx 0) &*idx = idx - rowIndex; <else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
<if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (index) if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) <*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex &0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (index >= index) <mRows.removeElement(index); <else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; <else if (!rowIndex) &res = &rowIndex; break;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= getRowIndex(rowKey)) <removeRow(index);
if (index >= 0) <rv = -1; if (index &0) <rv = -1; else rv = -1;
if (itemIndex > 0) &return; &if (index = 0) if (itemIndex = 0) return;
nrows = 0; if (idx &0) <*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %sn", rowIndex);
if (item) &for (i = 0; i index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!rowIndex) &mInFlow = false; else mInFlow = false;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <&if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index 0) &delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index) &if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nrows = 0; if (idx 0) *idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/*removeRow(index); */
if (!rowKey) if (rowIndex > 0) removeRow(index); <else fprintf(stderr, "Couldn't get row index");
if (! eColIndex) &delete (rowKey); else &/* removeRow(index);
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index > 0) ret = &index, rowIndex &;
if (!rowKey) <if (rowIndex > 0) removeRow(index); <else fprintf(stderr, "Couldn't get row index");
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index == 0) i++; <else &if (rowIndex >= rowKey) break;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <<else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex 0) if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!rowKey) &if (rowIndex > 0) removeRow(index); else <fprintf(stderr, "Couldn't get row index");
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey) <if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else &rl = 0;
if (index > 0) ret = index, rowIndex &;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); <else rl = 0;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
<if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (index) &if (rowIndex > 0) if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index = 0) <mTreeItem.removeRow(index);
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; &else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) <if (rowKey) &rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (increment) if (index > 0) fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index >= 0) nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (getRowIndex(rowKey) index) <break; if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (!sc) &fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
<if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (index == 0) break;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (itemIndex > 0) return; <if (index = 0) <if (itemIndex = 0) return;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index == -1) <r = 0; <if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index >= 0) nsAutoString rowKey('0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (getRowIndex(rowKey) &index) &break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; else *rowIndex = 0;
if (rowIndex >= 0) <if (rowIndex &rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!__PRECONDITION__) <if (index > 0) &if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
fprintf(stderr, "removeRow: %d<n", index);
if (increment) <if (index > 0) fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index 0) <break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else rl = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index >= index) &mRows.removeElement(index); else if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; &else if (!rowIndex) res = &rowIndex; break;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) <if (!row) return; &if (row) return;
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else fs_brd.fs_id = 0;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) <if (instRow) &removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index >= 0) &rv = -1; <if (index &0) <rv = -1; else rv = -1;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index <0) &delete(index);
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index &0) <break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index >= 0) <rv = -1; if (index 0) rv = -1; else rv = -1;
if (rowIndex = 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == 0) &i++; else &if (rowIndex >= rowKey) break;
if (index == 0) <i++; else <if (rowIndex >= rowKey) break;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (index > 0) <ret = index, rowIndex <;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) __FreeLocalize();
if (index) removeRow(index); &else deleteRow(index);
r = getRowIndex(rowKey); if (r) if (!r) if (!removeRow(r, index)) &break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) &break;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else &rl = 0;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
<int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
nsPool* i = getRowIndex(rowKey); if (i 0) &if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!rowKey) if (rowIndex > 0) &removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = 1<;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (index) &if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) if (!row) return; <if (row) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; <if (rowIndex &0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index > 0) if (colIndex &0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex <= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index = 0) </* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (rowIndex == 0) <*rowIndex = index; else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= 0) &rv = -1; <if (index 0) rv = -1; else rv = -1;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index &0) delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index > 0) if (colIndex 0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex >= 0) &if (rowIndex <rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index >= 0) nsAutoString rowKey('<0'); if (index &nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) <break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index >= index) mRows.removeElement(index); else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index <0) &delete row; if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (increment) if (index > 0) &fprintf(stderr, "wrong row index <%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (getIndex() 0) return 0;
if (i == 0) /* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (index == 0) i++; <else if (rowIndex >= rowKey) &break;
if (index > 0) if (rowIndex &1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex >= index) return 0; if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex >= index) return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (rowIndex &= 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %sn", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (item) <for (i = 0; i index; i++) *i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!rowKey) if (rowIndex > 0) &removeRow(index); else fprintf(stderr, "Couldn't get row index");
if (index <0) &delete row;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index &0) <break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= 0) &if (instRow) removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index = 0) /* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); <else mTree.removeRow(index);
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; &else id = rowIndex;
if (index <0) <rval = res = 0; break; if (index >= 0) rval = rval;
if (rowIndex > 0) <fprintf(stderr, "%s: removeRow(%d)n",rowIndex,rowIndex);
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= index) mRows.removeElement(index); <else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= index) &mRows.removeElement(index); else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index &= 0) </* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (index >= 0) <rv = -1; &if (index 0) <rv = -1; else rv = -1;
if (index >= index) &mRows.removeElement(index); <else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index == 0) i++; else <if (rowIndex >= rowKey) &break;
if (index) if (rowIndex > 0) &if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
ret = removeRow(index); if (ret <0)
if (colIndex 0) <removeRow(rowIndex);
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index == -1) <removeRow(index);
if (index == 0) &i++; &else if (rowIndex >= rowKey) &break;
if (index == 0) <i++; <else &if (rowIndex >= rowKey) break;
if (index <= 0) </* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) <id = rowIndex; &else id = rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex <= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index 0) <break;
ret = removeRow(index); if (ret == -1) <&/* We do not know how to get ret */ for (index = 0; index &index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey == mRowKey) <if (rowKey == mRowKey) <mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex == 0) *rowIndex = index; &else <if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (rowKey) nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex <rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (index >= index) <mRows.removeElement(index); <else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index > 0) &if (rowIndex &1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
&int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index >= 0) if (instRow) &removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; &else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index <0) &delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) &if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index == -1) if (isPositioned) <removeRow(index);
if (rowIndex index) if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (getRowIndex(rowKey) <index) &break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) if (index >= 0) return;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) &if (!row) return; if (row) return;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
fprintf(stderr, "removeRow()n");
if (index > 0) <if (colIndex <0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowKey) <if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else &if (row) <if (!row) return; &if (row) return;
nrows = 0; if (idx &0) *idx = idx - rowIndex; <else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index <0) delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (rowIndex index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; &if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (itemIndex > 0) return; if (index <= 0) &if (itemIndex = 0) return;
if (item) <ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if (index == -1) &r = 0; <if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
mPadding--; if (index >= 0) mPadding--; &<else mPadding--;
if (index) &if (!sid) <fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= 0) <if (instRow) removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index &0) <break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index &1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!sc) fprintf(stderr, "%s: index=%d<n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index) &if (rowIndex > 0) &if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index) <if (rowIndex > 0) <if (index > 0) <if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (!rowIndex) mInFlow = false; <else <mInFlow = false;
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) rval = 0; <else <rval = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) <if (!row) return; if (row) return;
if (rowIndex &index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index > 0) &ret = index, rowIndex <;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) *index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (rowIndex = 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= 0) &rv = -1; &if (index &0) <rv = -1; else rv = -1;
if (index >= 0) <rv = -1; &if (index &0) &rv = -1; else rv = -1;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (!rowIndex) &mInFlow = false; &else mInFlow = false;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex >= 0) &if (rowIndex rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (itemIndex > 0) &return; &if (index <= 0) if (itemIndex = 0) return;
if (index &= 0) mTreeItem.removeRow(index);
if (index) &if (rowIndex > 0) &if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!rowKey) if (rowIndex > 0) removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (index) <if (rowIndex > 0) <if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; <*((*)rowKey.GetArray()) = <1<;
if (index >= 0) <if (index <0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (inPosition &= 0) *inPosition = rowKey; return;
if (rowIndex == 0) &*rowIndex = index; else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) &rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex >= index) return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index = 0) &/* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
<if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; else mPos = mPos;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &&else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsPool* i = getRowIndex(rowKey); if (i &0) if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (getRowIndex(rowKey) index) <break; if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) &if (rowIndex > 0) <if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; &else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex &0) if (!strcmp(rowIndex, "-")) &std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = 1&;
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else rl = 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = &1&;
if ((index = -1 && index >= 0)) *index = 0; else &*index = 0;
if (index <0) <return 0;
if (rowIndex == 0) &*rowIndex = index; &else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
mPadding--; if (index >= 0) &mPadding--; <else &mPadding--;
if (index >= 0) &if (index &0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; </* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowIndex >= 0) if (rowIndex rowIndex) <if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex <index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; <&else *rowIndex = 0;
<if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
nrows = 0; if (idx &0) *idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index == -1) r = 0; <if (mRowIndex > 0) &if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex <index) if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= index) <mRows.removeElement(index); &else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; <<else *rowIndex = 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) &delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int rowIndex; if (!rowIndex) <delete rowIndex; rowIndex = rowIndex;
ret = removeRow(index); if (ret == -1) /* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsPool* i = getRowIndex(rowKey); if (i &0) &if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index <= 0) /* XXX */ if ((index >= 0) || (index = 0)) delete row; else /* XXX */
if (getIndex() <0) <return 0;
if (!aRowIndex) &nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &if (rowKey) &if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowIndex 0) if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (!rowKey) if (rowIndex > 0) removeRow(index); else <fprintf(stderr, "Couldn't get row index");
if (index &0) rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index 0) <delete (int)rowKey;
r = getRowIndex(rowKey); if (r) if (!r) <if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
&/*removeRow(index); */
if (!isIndexed) &if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= 0) if (index &0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index == 0) <i++; else <if (rowIndex >= rowKey) <break;
if (index >= index) <mRows.removeElement(index); <else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index 1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; &else *rowIndex = 0;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (!isIndexed) if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; &<else *rowIndex = 0;
if (index >= 0) &rv = -1; if (index <0) &rv = -1; else rv = -1;
if (index >= index) <mRows.removeElement(index); else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index &0) break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (getRowIndex(rowKey) <index) &break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) rval = -1; <else rval = 0;
if (index) removeRow(index); <else deleteRow(index);
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (removeRow(index)) &fprintf(stderr, "removeRow %d<n", index);
if (rowIndex <index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; <else if (!rowIndex) res = &rowIndex; break;
&if (index) struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (index > 0) if (colIndex 0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex >= index) &return 0; <if (rowIndex >= index) <*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
&int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) <if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i <row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (index >= 0) &if (index <0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= index) <mRows.removeElement(index); &else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = &1<;
if (index &0) removeRow(index);
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nrows = 0; if (idx <0) &*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) &id = rowIndex; &else <id = rowIndex;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (getIndex() <0) return 0;
mPadding--; if (index >= 0) mPadding--; <&else <mPadding--;
if (index >= 0) &rv = -1; &if (index 0) rv = -1; else rv = -1;
if (index >= 0) if (instRow) removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); &else mTree.removeRow(index);
if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (!__PRECONDITION__) <if (index > 0) <if (!__PRECONDITION__((r = __PRECONDITION__))) mInner = r.next; mInner = r.next;
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else &rl = 0;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
int index = 0; for (index = 0; index <rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (itemIndex > 0) &return; <if (index &= 0) if (itemIndex = 0) return;
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; *((*)rowKey.GetArray()) = &1&;
if (index = 0) &/* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex >= index) return 0; if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) /* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index 0) &break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; <else if (!rowIndex) <res = &rowIndex; break;
if (!rowKey) &if (rowIndex > 0) removeRow(index); <else fprintf(stderr, "Couldn't get row index");
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) id = rowIndex; &else id = rowIndex;
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (index &= 0) /* XXX */ if ((index >= 0) || (index <= 0)) <delete row; else /* XXX */
<int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else &rl = 0;
if (inLine) &if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s&n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index == -1) <r = 0; <if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if ((index = -1 && index >= 0)) <*index = 0; else *index = 0;
if (index) if (rowIndex > 0) if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else &fs_brd.fs_id = 0;
if (!rowKey) if (rowIndex > 0) removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
nsPool* i = getRowIndex(rowKey); if (i 0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index == index || index == index) &break;
if (index >= 0) &return 0;
if (index >= 0) &if (instRow) &removeRow(index); else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index > 0) &if (rowIndex <1) &return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
mPadding--; if (index >= 0) &mPadding--; <else mPadding--;
if (index 0) &rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index &0) break; if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index &0) delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
&if (index) &struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) &if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowIndex >= index) return 0; &if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = &1&;
if (rowIndex <0) if (rowIndex >= index) return -1; rowIndex--; <else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; else ret = row.rowIndex;
if (rowIndex >= 0) <if (rowIndex rowIndex) &if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) &/* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index <1) &if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %s&n", rowIndex);
if (index >= 0) if (instRow) <removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (!rowIndex) mInFlow = false; else &mInFlow = false;
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (! eColIndex) <delete (rowKey); &else /* removeRow(index);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; &if (rowIndex <0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (index = 0) &mTreeItem.removeRow(index);
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &break;
if (inLine) if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (getRowIndex(rowKey) index) <break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index) <if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (removeRow(index))
if (rowIndex >= 0) <if (rowIndex <rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
nrows = 0; if (idx &0) &*idx = idx - rowIndex; &else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex &0) <if (rowIndex >= index) return -1; rowIndex--; <else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex == 0) *rowIndex = index; &else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else rl = 0;
r = getRowIndex(rowKey); if (r) <if (!r) &if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
if (index >= 0) <if (instRow) <removeRow(index); &else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else &if (row) if (!row) return; if (row) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex 0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!isIndexed) &if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex &index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index >= 0) return 0;
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (index == 0) i++; &else <if (rowIndex >= rowKey) &break;
if (itemIndex > 0) return; if (index &= 0) <if (itemIndex = 0) return;
if (index >= 0) &if (index &0) if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
&int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); else &rl = 0;
if (index = 0) &/* XXX */ if ((index >= 0) || (index &= 0)) delete row; else /* XXX */
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; &else &fs_brd.fs_id = 0;
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * Remove RowIndex, index. */ if (rowIndex 0) <*rowIndex = 0; <else *rowIndex = 0;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (rowIndex >= index) <return 0; &if (rowIndex >= index) <*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (!rowState.IsEmpty()) &return 0; &if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (index > 0) if (colIndex &0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); &else &mTree.removeRow(index);
if (rowIndex == 0) *rowIndex = index; <else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (!rowKey) <if (rowIndex > 0) &removeRow(index); else &fprintf(stderr, "Couldn't get row index");
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; <*((*)rowKey.GetArray()) = <1<;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; &&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex == 0) &*rowIndex = index; <else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
/* * Remove RowIndex, index. */ if (rowIndex 0) *rowIndex = 0; &else *rowIndex = 0;
int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (rowKey) &if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) if (!rowKey) return; else return; else return;
if (index 0) <rval = res = 0; break; <&if (index >= 0) rval = rval;
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; <else *rowIndex = 0;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (getRowIndex(rowKey) &index) break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) &nsString row = (nsString) aRowIndex; if (rv == 0) nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) <if (rowIndex > 0) &if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (rowIndex >= index) return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (rowKey == null) &nsCRT::free(rowKey);
retRow = ((int)index) / floats; else retRow = ((int)index) / floats;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
if (rowIndex &index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index) if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex >= 0) &if (rowIndex rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (index) <if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowIndex &index) &if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index &0) &break;
if (removeRow(index)) &return 0;
if (index > 0) &if (rowIndex <1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index &0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (index >= 0) <if (index <0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index >= 0) if (instRow) <removeRow(index); <else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); <else &mTree.removeRow(index);
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) &if (!row) return; <if (row) return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; &else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (item) &for (i = 0; i <index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (item) &for (i = 0; i &index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index > 0) &if (rowIndex &1) &return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= index) mRows.removeElement(index); <else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index &0) <delete row; &if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (!selection || index == 0) <if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (!selection || index == 0) <if (rowKey) &/* XXX */ if (!listCell) &/* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) <nsAutoString rowKey('<0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
&int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); <else rl = 0;
res = iRow.indexOf(rowKey); if (NS_FAILED(res)) return; if (index) if (index >= 0) &return;
if (rowKey) if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (item) <for (i = 0; i <index; i++) <*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex == 0) *rowIndex = index; else &if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (!isIndexed) if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
nrows = 0; if (idx &0) <*idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index == -1) r = 0; &if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index 0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* Remove Row(index); */ if (index == null) <__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) <__FreeLocalize();
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) <rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (index == 0) <int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) fprintf(stderr, "Removing row %s<n", rowIndex);
if (index >= 0) &rv = -1; &if (index &0) rv = -1; else rv = -1;
if (index > 0) &if (rowIndex <1) &return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; <if (rowKey) <if (!rowKey) return; else return; else return;
nsPool* i = getRowIndex(rowKey); if (i &0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) <rv = -1; if (index 0) &rv = -1; else rv = -1;
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index >= 0) <if (index <0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index) <rval = -1; <else rval = 0;
if (rowKey) if (rowKey) <rowKey = mTable[rowKey]; &if (rowKey) <if (!rowKey) return; else return; else return;
if (index == index || index == index) <break;
nsCOMPtr&nsIRow> row; if (!mPrimary) <nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) id = rowIndex; else &id = rowIndex;
if (index) &if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); &if (rem) rem = removeRow(index); else rem = removeRow(index);
if (inLine) &if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index > 0) if (rowIndex <1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index >= index) <mRows.removeElement(index); <else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index) <if (!sid) <fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) <if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex 0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) <nsPool* p = mRow.p; if (p &p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (index >= 0) if (instRow) &removeRow(index); <else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index == -1) r = 0; if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (index >= index) mRows.removeElement(index); &else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (item) <for (i = 0; i index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (item) &for (i = 0; i <index; i++) &*i = i; &if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
r = getRowIndex(rowKey); if (r) &if (!r) if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; &if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (!rowState.IsEmpty()) return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex > 0) fprintf(stderr, "%s: removeRow(%d)&n",rowIndex,rowIndex);
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) *index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index) <if (rowIndex > 0) <if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; else if (index 0) return; else return;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (index >= 0) if (instRow) &removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (rowIndex >= index) return 0; if (rowIndex >= index) &*rowIndex = rowIndex; &else *rowIndex = rowIndex; return 0;
if (index &0) delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (itemIndex > 0) return; <if (index = 0) if (itemIndex = 0) return;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (index <0) <delete row; if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index >= 0) &if (index <0) <if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else if (row) <if (!row) return; <if (row) return;
if (index > 0) <if (rowIndex &1) return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (item) <for (i = 0; i <index; i++) &*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index <0) &break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) &aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index <0) <removeRow(index);
if (index &0) <delete row;
if (index >= 0) rval = 0; else rval = 0;
if (index <= 0) &mTreeItem.removeRow(index);
if (index >= 0) &if (index &0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index <index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (index <0) <break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
/* Remove Row(index); */ if (index == null) __FreeLocalize(); &/* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (index >= index) &mRows.removeElement(index); else <if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; else <if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; &<else *rowIndex = 0;
if ((index = -1 && index >= 0)) *index = 0; <else &*index = 0;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= 0) <if (index &0) if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey == mRowKey) <if (rowKey == mRowKey) &mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index) &if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (rowKey!= 0) /* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; <else mPos = mPos;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
nrows = 0; if (idx <0) &*idx = idx - rowIndex; else <*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
mPadding--; if (index >= 0) &mPadding--; <<else <mPadding--;
if (rowIndex <index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; &else if (index 0) return; else return;
int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); else rl = 0;
if (index) <rval = -1; &else rval = 0;
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else <rl = 0;
if (index &0) &rval = res = 0; break; &if (index >= 0) rval = rval;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; <*((*)rowKey.GetArray()) = 1<;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) &mPos = 0; mPos = 0; <else mPos = mPos;
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (!rowKey) <if (rowIndex > 0) <removeRow(index); <else &fprintf(stderr, "Couldn't get row index");
if (item) &ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; <else ret = row.rowIndex;
if (index &0) &delete row;
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else <rl = 0;
if (rowIndex >= index) <return 0; &if (rowIndex >= index) *rowIndex = rowIndex; <else *rowIndex = rowIndex; return 0;
int index = 0; for (index = 0; index rowCount; index++) <if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index >= 0) &rv = -1; &if (index <0) <rv = -1; else rv = -1;
nsCOMPtr<nsIRow> row; if (!mPrimary) <nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (rowIndex >= 0) &if (rowIndex &rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index) <if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index) <if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
<int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (getRowIndex(rowKey) index) &break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) <if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (index 0) break; <if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index = 0) &/* XXX */ if ((index >= 0) || (index &= 0)) &delete row; else /* XXX */
if (!getRowIndex(rowKey)) <return;
if (index >= index) &mRows.removeElement(index); <else if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index &0) break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
<int rl; int row = getRowIndex(rowKey); if (row) rl = getRowIndex(row); &else rl = 0;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) &if (!row) return; <if (row) return;
if (index > 0) &if (colIndex 0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (index >= 0) removeRow(index);
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) </* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
&int index = 0; for (index = 0; index &rowCount; index++) <if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = <1;
if (rowIndex &= 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
nsCOMPtr&nsIRow> row; if (!mPrimary) nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (!rowState.IsEmpty()) <return 0; <if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
&if (item) <ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; <else ret = row.rowIndex;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index > 0) if (rowIndex <1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index > 0) <if (colIndex 0) return; if (index 0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int r = getRowIndex(rowKey); if (r == -1) <r = 0; r = -1;
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s&n", rowIndex);
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) <if (getRowIndex(rowKey, index)) &rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (itemIndex > 0) return; if (index &= 0) if (itemIndex = 0) return;
if (index &0) <rval = res = 0; break; &if (index >= 0) rval = rval;
if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (index > 0) <ret = index, rowIndex ;
nrows = 0; if (idx 0) &*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex >= index) <return 0; <if (rowIndex >= index) &*rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (inLine) if (inLine) inLine.Init(); else &fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index) if (!sid) &fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (!getRowIndex(rowKey)) &if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
/* XXX This is only possible with index */ if (!rowCount) return; row = row; <else <if (row) &if (!row) return; &if (row) return;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index == 0) &i++; <else if (rowIndex >= rowKey) &break;
if (!sc) &fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else fs_brd.fs_id = 0;
if (index <0) break; &if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index 0) &delete row; if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; &else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex &index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index > 0) &if (rowIndex <1) <return; &if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
nsPool* i = getRowIndex(rowKey); if (i <0) if (rowKey == -1 || rowKey == -1) &nsPool* p = mRow.p; if (p <p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (!rowState.IsEmpty()) <return 0; if ((index = -1) &&!rowState.IsEmpty()) /* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) <return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (rowIndex == 0) <*rowIndex = index; <else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
<if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
int rowIndex; void* res = &rowIndex; if (!res) /* * Recycle the row if possible. */ res = res; &else if (!rowIndex) &res = &rowIndex; break;
if (!rowKey) if (rowIndex > 0) &removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (getRowIndex(rowKey) == 0) <mTree.removeRow(index); <else <mTree.removeRow(index);
if (index 0) <return;
if (index == 0) &int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) &fprintf(stderr, "Removing row %sn", rowIndex);
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; <<else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowIndex <0) &if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (index >= index) <mRows.removeElement(index); else <if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (item) for (i = 0; i <index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index > 0) <ret = <index, rowIndex &;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); else std::free(rowIndex); if (rowIndex >= index) break;
if (itemIndex > 0) <return; &if (index = 0) if (itemIndex = 0) return;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index 0) delete row;
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex &0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; if (rowIndex &index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) <if (!sid) <fprintf(stderr, "Row index: %d<n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (increment) &if (index > 0) fprintf(stderr, "wrong row index <%sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
r = getRowIndex(rowKey); if (r) <if (!r) <if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index 0) <rval = res = 0; break; <<if (index >= 0) rval = rval;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
fprintf(stdout, "removeRow: %sn", index);
if (!sc) fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; else <fs_brd.fs_id = 0;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
&if (item) <ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
if (index 0) <break; if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index == 0) &return;
if (rowIndex == 0) *rowIndex = index; else &if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
if (index > 0) &if (colIndex <0) return; if (index &0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex index) <if (rowIndex >= 0) &ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index 1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index) removeRow(index); else <deleteRow(index);
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (rowIndex = 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index == 0) i++; &else &if (rowIndex >= rowKey) &break;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) if (mPos > 0) <mPos = 0; mPos = 0; &else mPos = mPos;
if (rowKey) <removeRow(index);
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) &if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (colIndex <0) <removeRow(rowIndex);
if (index >= 0) <if (index &0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; &if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = 1<;
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; &else if (index 0) return; else return;
fprintf(stderr, "removeRow: %s&n", index);
if (rowIndex >= 0) <removeRow(index);
nsCOMPtrnsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else <rl = 0;
if (i == 0) </* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
nrows = 0; if (idx 0) <*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nsresult rv = NS_OK; if (null == rv) &nsIDOMNode *node = null; rv = nsGenericHTMLElement::GetPrimaryNode(&node); if (NS_FAILED(rv)) return rv; &rv = NS_OK;
if (index == -1) r = 0; <if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) </* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) <if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
fprintf(stdout, "removeRow&n");
if (index) if (rowIndex > 0) &if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
&int index = 0; for (index = 0; index &rowCount; index++) if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
&if (item) &ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; <else ret = row.rowIndex;
nsCOMPtr<nsIRow> row; if (!mPrimary) &nsCOMPtr<nsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
if (index >= 0) <if (instRow) <removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
mTreeRow = new RowIndex(index); if (mTreeRow) <if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; else mPos = mPos;
if (index > 0) &if (colIndex 0) return; if (index 0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
int rowIndex; void* res = &rowIndex; if (!res) </* * Recycle the row if possible. */ res = res; else if (!rowIndex) <res = &rowIndex; break;
if (index <0) <delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if ((rowIndex = getRowIndex(rowKey))!= 0) break; <if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index) if (rowIndex > 0) if (index > 0) &if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index) &if (rowIndex > 0) <if (index > 0) &if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; else if (!rowIndex) <res = &rowIndex; break;
if (index &0) break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!rowKey) &if (rowIndex > 0) &removeRow(index); else &fprintf(stderr, "Couldn't get row index");
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (rowIndex == 0) *rowIndex = index; else &if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (index == -1) r = 0; if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); <else <mTree.removeRow(index);
if (index) &removeRow(index); else deleteRow(index);
if (index &= 0) &/* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
if (index == 0) i++; else <if (rowIndex >= rowKey) <break;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index == 0) /* * Recycle the row if the row index isn't. */ rv = removeRow(index); if (NS_FAILED(rv)) return;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; <if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (rowIndex <0) &if (!strcmp(rowIndex, "-")) &std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowKey == mRowKey) &if (rowKey == mRowKey) <mRowKey = mRowKey; <else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex &= 0) nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) if (mPos > 0) &mPos = 0; mPos = 0; &else mPos = mPos;
if (rowIndex == -1) aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (index &0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (index <= 0) </* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
if (rowIndex &index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) if (rowIndex > 0) if (index > 0) &if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (index >= 0) &rv = -1; if (index &0) <rv = -1; else rv = -1;
if (index <0) <delete (int)rowKey;
if (rowKey) if (rowKey) rowKey = mTable[rowKey]; &if (rowKey) &if (!rowKey) return; else return; else return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; <if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
/* * Only remove the row by * index. */ if (index == -1) rv = ret = 0; &else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* * Remove RowIndex, index. */ if (rowIndex 0) &*rowIndex = 0; <&else *rowIndex = 0;
if (rowKey == mRowKey) if (rowKey == mRowKey) <mRowKey = mRowKey; <else mRowKey = mRowKey; else mRowKey = mRowKey;
nsCOMPtrnsIRow> row; if (!mPrimary) <nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (index <0) <delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index &0) &rval = res = 0; break; &<if (index >= 0) rval = rval;
if (index >= sizeof(rowKey)) <mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index > 0) &if (colIndex <0) return; if (index &0) return; if (rowIndex &0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
if (rowIndex = 0) &nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (getRowIndex(rowKey) == 0) &mTree.removeRow(index); else &mTree.removeRow(index);
if (index >= 0) &nsAutoString rowKey('&0'); if (index <nsAutoString::rowCount) <nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index >= 0) &return;
if (intableRowCount) int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; <if (index == 0) &if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index == -1) &r = 0; <if (mRowIndex > 0) if (index == -1) &mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) if (!rowKey) return; else return; else return;
if (index <0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (!rowState.IsEmpty()) &return 0; if ((index = -1) &&!rowState.IsEmpty()) &/* * Get the row value by index, or if there are any row rows. */ if ((index == 0) || ((index == -1) || (index == -1))) &return -1; */ else */ *((void *)(index)) = 0; *((void *)((*) && (index)) == -1) return -1; *((void *)) = -1); *((void *)(((void *)&(((value *))).value));
if (!rowKey) <if (rowIndex > 0) <removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) if (!row) return; <if (row) return;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) &if (getRowIndex(rowKey, index)) &rem = removeRow(index); <if (rem) rem = removeRow(index); else rem = removeRow(index);
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (index >= 0) &nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index > 0) if (rowIndex <1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; *((*)rowKey.GetArray()) = <1&;
if (rowIndex >= 0) <if (rowIndex &rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) mPos = 0; mPos = 0; &else mPos = mPos;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else <aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) <if (index == index
if (index >= index) &mRows.removeElement(index); else &if (index <= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index <= 0) </* XXX */ if ((index >= 0) || (index = 0)) &delete row; else /* XXX */
/* * Remove RowIndex, index. */ if (rowIndex <0) <*rowIndex = 0; <&else *rowIndex = 0;
if (index &0) rval = res = 0; break; <&if (index >= 0) rval = rval;
/* * Remove RowIndex, index. */ if (rowIndex &0) &*rowIndex = 0; <&else *rowIndex = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index &= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (index 0) <break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!aRowIndex) <nsAutoString row; rv = aRowIndex; if (NS_FAILED(rv)) return rv; rv = aRowIndex; if (row) <nsString row = (nsString) aRowIndex; if (rv == 0) <nsString row = (nsString)row; rv = aRowIndex; if (NS_FAILED(rv)) return rv;
if (index) <if (rowIndex > 0) if (index > 0) <if (rowIndex &= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (increment) <if (index > 0) &fprintf(stderr, "wrong row index &%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) if (row.rowIndex) <int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (!selection || index == 0) &if (rowKey) /* XXX */ if (!listCell) /* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) &break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
&if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; else ret = row.rowIndex;
/* * Remove RowIndex, index. */ if (rowIndex &0) *rowIndex = 0; <else *rowIndex = 0;
if (index >= 0) &if (instRow) <removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex = 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= 0) <if (instRow) &removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if (index == -1) r = 0; &if (mRowIndex > 0) if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) <nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
int rowIndex; void* res = &rowIndex; if (!res) &/* * Recycle the row if possible. */ res = res; &else if (!rowIndex) res = &rowIndex; break;
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (rowKey) &if (rowKey) &rowKey = mTable[rowKey]; if (rowKey) &if (!rowKey) return; else return; else return;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else if (row) <if (!row) return; &if (row) return;
if (!sc) <fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) &*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (i == 0) </* not defined as a row */ ret = 0; return ret; &if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index >= index) <mRows.removeElement(index); else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; &else if (index 0) return; else return;
return (rowIndex &= index)? 0 : 0;
if (index > 0) <ret = &index, rowIndex &;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (rowIndex = 0) <nsCOMPtrnsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index >= index) <mRows.removeElement(index); <else if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (index == 0) int rowIndex = getRowIndex(rowKey); if (rowIndex > 0) <fprintf(stderr, "Removing row %s<n", rowIndex);
if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex index) <if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) if (rowIndex > 0) if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
if (!rowKey) if (rowIndex > 0) <removeRow(index); <else <fprintf(stderr, "Couldn't get row index");
if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex <0) <if (rowIndex >= index) return -1; rowIndex--; <else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex == 0) <*rowIndex = index; <else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index <0) break; <if (itemIndex > 0) &PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index) <if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (index >= 0) <rv = -1; <if (index <0) &rv = -1; else rv = -1;
if (item) ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (index <= 0) </* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
int i = 0; int row = getRowIndex(rowKey); if (row == -1) &if (index == -1) return; &/* * We're gonna be able to get the row in any way. */ for (i = 0; i row && i++) &if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (item) &ret = item.rowIndex; if (ret == -1) &ret = item.rowIndex; &else ret = row.rowIndex;
if (index >= 0) <nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) /* removeRow(index); */ <else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
nrows = 0; if (idx 0) *idx = idx - rowIndex; <else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex &= 0) &nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; &if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index 0) <break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); </* delete rows from the table, */ if (index >= 0) &__FreeLocalize();
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index) <rval = -1; &else <rval = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; &else <id = rowIndex;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index &1) <if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (!selection || index == 0) if (rowKey) /* XXX */ if (!listCell) &/* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) std::free(rowIndex); <else std::free(rowIndex); if (rowIndex >= index) break;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex &rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (index &0) <return 0;
if (index >= 0) if (index &0) &if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index 0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowIndex == 0) <*rowIndex = index; else if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index <index; index++) if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (rowIndex == 0) <*rowIndex = index; &else if (rowIndex <0) *rowIndex = 0; else *rowIndex = 0;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; <&else rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) <nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '&0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (!sc) fprintf(stderr, "%s: index=%dn", index, fs_brd.name); fs_brd.fs_id = 0; <else &fs_brd.fs_id = 0;
if (! eColIndex) delete (rowKey); else &/* removeRow(index);
if (!sc) <fprintf(stderr, "%s: index=%d&n", index, fs_brd.name); fs_brd.fs_id = 0; <else <fs_brd.fs_id = 0;
if (rowIndex &index) &if (rowIndex >= 0) ret = removeRow(rowIndex); if (ret == -1) &*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index) <if (rowKey) &if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex &index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (!removeRow(index)) return;
if (index <0) <rval = res = 0; break; <<if (index >= 0) rval = rval;
if (index >= 0) nsAutoString rowKey('&0'); if (index nsAutoString::rowCount) &nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (index >= 0) <rv = -1; &if (index &0) rv = -1; else rv = -1;
if (index >= 0) rv = -1; if (index <0) &rv = -1; else rv = -1;
if (index) <if (rowKey) <if ((index = getRowIndex(rowKey))) &/* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (i == 0) /* not defined as a row */ ret = 0; return ret; if (index == 0) <if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
ret = removeRow(index); if (ret == -1) &</* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
mPadding--; if (index >= 0) <mPadding--; else <mPadding--;
if (rowKey!= 0) &/* Remove the row in the row key. */ if (rowKey == 0) &/* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; <<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
if (index 0) &break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= 0) rv = -1; &if (index <0) <rv = -1; else rv = -1;
if (index == -1) r = 0; &if (mRowIndex > 0) if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index > 0) removeRow(index);
if (index) if (rowKey) <if ((index = getRowIndex(rowKey))) /* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index >= 0) <if (index &0) if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (!getRowIndex(rowKey)) <if (!setRowIndex(rowIndex, index)) if (getRowIndex(rowKey, index)) <rem = removeRow(index); if (rem) rem = removeRow(index); else rem = removeRow(index);
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; else &mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= sizeof(rowKey)) mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index &0) <break; &if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i &n; i++) &if (rowKey[i] == '0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index <0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (index &0) &return;
if (index &0) delete row; <if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
mPadding--; if (index >= 0) &mPadding--; &else mPadding--;
if (getRowIndex(rowKey) == 0) mTree.removeRow(index); <else <mTree.removeRow(index);
if (index &0) &rval = res = 0; break; if (index >= 0) rval = rval;
if (rowKey == '0') return; if (rowKey == '&0') return; if (rowKey == '<0') return; if (rowKey == '<0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) if (segmentCount == -1) &/* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; &row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (i == 0) </* not defined as a row */ ret = 0; return ret; <if (index == 0) if (i == 0) <if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
int rowIndex = getRowIndex(rowKey); if (rowIndex &0) <id = rowIndex; <else id = rowIndex;
if (rowIndex >= 0) &if (rowIndex rowIndex) if (index >= rowIndex) <return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex &0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
if (index) if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); <else fprintf(stderr, "Couldn't get row index");
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); else &rl = 0;
if (index >= 0) &nsAutoString rowKey('0'); if (index <nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (item) <for (i = 0; i index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; &else <mRowKey = mRowKey; else mRowKey = mRowKey;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) <return; &*((*)rowKey.GetArray()) = 1&;
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex 0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) &row = 0; break; <row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i &rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index &0) &delete (int)rowKey;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (increment) &if (index > 0) &fprintf(stderr, "wrong row index <%s&n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index &0) <break; if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex > 0) fprintf(stderr, "%s: removeRow(%d)n",rowIndex,rowIndex);
if (index &0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
&int index = 0; for (index = 0; index <rowCount; index++) <if (row[index]) &if (itemIndex rowCount) if (!row[index]) return; return 0;
mTreeRow = new RowIndex(index); if (mTreeRow) &if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (!rowKey) &if (rowIndex > 0) <removeRow(index); else fprintf(stderr, "Couldn't get row index");
if (index <= 0) mTreeItem.removeRow(index);
fprintf(stderr, "removeRow<n");
if (rowIndex = 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
<int rl; int row = getRowIndex(rowKey); if (row) <rl = getRowIndex(row); &else <rl = 0;
if (!isIndexed) if (itemType == ObjectType.VoidKey) <if (itemType == ObjectType.VoidKey) nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index >= sizeof(rowKey)) mRow = rowKey; break; <if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index <index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if (i == 0) &/* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) &if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
mPadding--; if (index >= 0) <mPadding--; <else &mPadding--;
if (item) &for (i = 0; i index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index) &if (rowKey) if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey == mRowKey) &if (rowKey == mRowKey) &mRowKey = mRowKey; else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (index >= 0) <if (index 0) <if (inProcessNode) <if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; <if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (index == -1) <if (isPositioned) removeRow(index);
if (inLine) if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (item) for (i = 0; i index; i++) *i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (index > 0) &if (rowIndex &1) <return; if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (index) &if (rowKey) <if ((index = getRowIndex(rowKey))) </* removeRow(index); */ &else /* Recycle index of row index */ if (rowKey == index) if (rowKey) if (rowKey == index) /* delete row */ return; else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (rowKey) &nsAutoString row; PRInt32 rowIndex; row.mRowIndex = rowIndex; row = row.mRowIndex; if (rowIndex <rowIndex) row = ((nsIScrollable)row.mRowIndex)-1; else row = 0;
if (rowKey!= 0) </* Remove the row in the row key. */ if (rowKey == 0) /* * Remove the row in the row key, and then remove it from the index * to the end of the row. */ return; &<if (rowKey == -1) /* if the row key is empty, * then delete the row in the row * before it isn't any more */ return; else /* * If this is not the row key, remove the row. */
ret = removeRow(index); if (ret == -1) &/* We do not know how to get ret */ for (index = 0; index index; index++) <if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
if ((rowIndex = getRowIndex(rowKey))!= 0) <break; if (rowIndex <index) &*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (getRowIndex(rowKey) &index) &break; &if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index &0) delete row; &if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (index <0) delete (int)rowKey;
if (rowKey == mRowKey) <if (rowKey == mRowKey) mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
/* XXX This is only possible with index */ if (!rowCount) return; row = row; &else <if (row) &if (!row) return; &if (row) return;
if (!isIndexed) <if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; <if (rowIndex index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; &*((*)rowKey.GetArray()) = <1;
if (index >= sizeof(rowKey)) mRow = rowKey; break; &if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; <else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index > 0) <if (rowIndex &1) return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) <if (segmentCount == -1) /* Recycle the row in the row (see ifdef */ if (index == -1) <row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
if (item) <for (i = 0; i index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
&int rl; int row = getRowIndex(rowKey); if (row) &rl = getRowIndex(row); &else &rl = 0;
if (rowIndex >= 0) if (rowIndex rowIndex) &if (index >= rowIndex) return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
&if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (index >= 0) &nsAutoString rowKey('<0'); if (index nsAutoString::rowCount) nsAutoString rowKey('0'); rowKey = nsAutoString(rowKey); nsAutoString rowKey('1'); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); nsAutoString rowKey('1'); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey('0'); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); rowKey.Copy(rowKey, rowKey); nsAutoString rowKey; rowKey.Copy(rowKey, rowKey); row
if (rowIndex == index) &*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
retRow = ((int)index) / floats; &else retRow = ((int)index) / floats;
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) <break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (getRowIndex(rowKey) index) <break; if (getRowIndex(rowKey) <index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (!isIndexed) &if (itemType == ObjectType.VoidKey) &if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) <if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index) <if (!sid) &fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
r = getRowIndex(rowKey); if (r) if (!r) &if (!removeRow(r, index)) break; &else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
int rowIndex = getRowIndex(rowKey); if (rowIndex <0) id = rowIndex; else &id = rowIndex;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) if (index == index
if (!rowIndex) mInFlow = false; &else &mInFlow = false;
<if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; else ret = row.rowIndex;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s&n", tableName); <if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (index) &if (rowIndex > 0) if (index > 0) if (rowIndex <= index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) &nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i <n; i++) if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
nrows = 0; if (idx <0) <*idx = idx - rowIndex; else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtrnsIRow> row(do_QueryInterface(row)); if (row) return (0); */ return (0);
r = getRowIndex(rowKey); if (r) r = retval;
ret = removeRow(index); if (ret == -1) <</* We do not know how to get ret */ for (index = 0; index index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
ret = removeRow(index); if (ret == -1) </* We do not know how to get ret */ for (index = 0; index &index; index++) &if (!ret) ret = &errno; if (!ret) if (ret == -1) delete row; if (*ret == -1) delete row;
fprintf(stderr, "removeRow: %d&n", index);
if (increment) &if (index > 0) <fprintf(stderr, "wrong row index %sn", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) &/* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) *(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (!isIndexed) <if (itemType == ObjectType.VoidKey) if (itemType == ObjectType.VoidKey) &nsStringKey key(itemType); if (!key) return -1; if (rowKey.getBits() && rowKey.type == ObjectType.VoidKey) &if (rowKey.entryType == ObjectType.VoidKey) if (rowKey.entryType == ObjectType.VoidKey) nsString key(rowKey.entryType); rowKey.entry = value.ElementAt(rowKey.elementAt(rowKey.entryType)); else if (rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.elementAt(rowKey.
if (index == -1)
if (index <= 0) &/* XXX */ if ((index >= 0) || (index = 0)) <delete row; else /* XXX */
if (rowIndex &= 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) &rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; &if (index = 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index 0) <delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (index >= 0) return;
if (index &1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; if (index &= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
if (index == -1) &if (isPositioned) <removeRow(index);
if (index >= sizeof(rowKey)) <mRow = rowKey; break; &if (index >= sizeof(rowKey)) <mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (index >= getRowIndex(rowKey)) &removeRow(index);
if (itemIndex > 0) <return; if (index <= 0) <if (itemIndex = 0) return;
if (itemIndex > 0) <return; if (index &= 0) if (itemIndex = 0) return;
if (index &0) &break; <if (itemIndex > 0) PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (index >= 0) if (instRow) removeRow(index); &else if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
int i = 0; int row = getRowIndex(rowKey); if (row == -1) if (index == -1) return; /* * We're gonna be able to get the row in any way. */ for (i = 0; i &row && i++) <if ((row row)) *row = row[i]; if (index >= row) return; *row = row;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
deleteRow(index);
if (!selection || index == 0) <if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else <rowKey = getRowIndex(rowKey); else rowKey = 0;
if (index = 0) /* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (int) &char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; <if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* Remove Row(index); */ if (index == null) &__FreeLocalize(); /* delete rows from the table, */ if (index >= 0) __FreeLocalize();
if (i == 0) /* not defined as a row */ ret = 0; return ret; &if (index == 0) <if (i == 0) if (!item) return i; i = 0; else ret = (ret == 0)? 0 : 0; else ret = 0;
if (index >= 0) &/* * Note that there is a number of rows, and * the row value is not in the row and the value is not a row (not a row) * which should be removed if the value is not in the row and it has already been removed. */ return -1;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) &rowIndex = rowIndex -''; &if (rowIndex <rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) if ((rowIndex = rowIndex) && (rowIndex <rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index <= 0) </* XXX */ if ((index >= 0) || (index <= 0)) &delete row; else /* XXX */
if (rowIndex == index) *int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
if (index >= index) &mRows.removeElement(index); else &if (index &= index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
int index = 0; for (index = 0; index rowCount; index++) if (row[index]) if (itemIndex rowCount) if (!row[index]) return; return 0;
if (index >= index) mRows.removeElement(index); <else <if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex == 0) &*rowIndex = index; &else <if (rowIndex &0) *rowIndex = 0; else *rowIndex = 0;
if (itemIndex > 0) &return; <if (index &= 0) <if (itemIndex = 0) return;
if (rowIndex &0) if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index <rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (getRowIndex(rowKey) &index) <break; <if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (rowIndex == index) <*int i; int *rowIndex = 0; int rowIndex = rowIndex - rowIndex; int cnt; cnt = rowIndex; for (i = 0; i <rowIndex; i++) <if ((rowIndex = rowIndex) && (rowIndex &rowIndex)) if (cnt >= rowIndex) return; cnt++; else rowIndex = rowIndex; if (rowIndex >= rowIndex) return; if ((rowIndex rowIndex) && (rowIndex >= 0)) return; if ((rowIndex rowIndex) && (rowIndex >= rowIndex)) return; if (rowIndex rowIndex) if (rowIndex rowIndex) return;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) <if (i == 1) &/* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; &else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
/* XXX This is only possible with index */ if (!rowCount) return; row = row; else <if (row) <if (!row) return; if (row) return;
if (rowIndex &0) &if (rowIndex >= index) return -1; rowIndex--; &else if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
nsAutoString rowKey; int index = getRowIndex(rowKey); if (index >= rowKey.Count()) nsString tmp; PRInt32 n = rowKey.Count(); for (PRInt32 i = rowKey.Count(); i n; i++) &if (rowKey[i] == '<0') nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp; rowKey[i] = '0'; else nsString tmp = rowKey[i]; if (rowKey[i] == '0') nsString tmp = rowKey[i]; nsString tmp; rs = rowKey[i]; if (rowKey[i] == '0') nsStr
if (index >= 0) <if (index 0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowIndex &index) &if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) <*ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index >= sizeof(rowKey)) &mRow = rowKey; break; <if (index >= sizeof(rowKey)) mRow = rowKey; mRow = rowKey; mRow = rowKey; else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) <int rowIndex; for (index = getRowIndex(rowKey); index rowIndex; index++) *index = getRowIndex(rowKey); *index = &rowIndex; <if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index) rval = -1; else <rval = 0;
if (!rowKey) <if (rowIndex > 0) removeRow(index); &else fprintf(stderr, "Couldn't get row index");
if (inLine) <if (inLine) inLine.Init(); else fprintf(stderr, "Comparing table %sn", tableName); if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
if (!rowKey) if (rowIndex > 0) removeRow(index); &else &fprintf(stderr, "Couldn't get row index");
if (int) char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex <0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
if (index >= sizeof(rowKey)) &mRow = rowKey; break; if (index >= sizeof(rowKey)) &mRow = rowKey; mRow = rowKey; mRow = rowKey; &else mRow = rowKey; break; if (mRowIndex >= sizeof(rowKey)) mRowIndex = rowKey; mRowIndex = -1;
if (!rowKey) if (rowIndex > 0) &removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if ((rowIndex = getRowIndex(rowKey))!= 0) &break; &if (rowIndex <index) *int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (item) for (i = 0; i index; i++) <*i = i; if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) </* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) &*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (getRowIndex(rowKey) &index) break; <if (getRowIndex(rowKey) index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (index >= 0) if (instRow) <removeRow(index); <else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; <if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index &0) delete row; <if (index > 0) &if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) &aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
nsPool* i = getRowIndex(rowKey); if (i 0) <if (rowKey == -1 || rowKey == -1) nsPool* p = mRow.p; if (p p.size) if ((Pool) row == 0) if (i == 1) p.size = 0; else if (i == 1) p.size = 0; else p.size = 0; else if (i == 2) p.size = 0; else p.size = 0; else p.size = 0;
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index %s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (index == -1) &r = 0; if (mRowIndex > 0) &if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (index) <rval = -1; else &rval = 0;
/* If the rowIndex <= 0 then this is a rowIndex containing all columns that the table contains, if any. */ int rClone = &rClone; int rClone = &rClone;
if (item) ret = item.rowIndex; if (ret == -1) ret = item.rowIndex; &else ret = row.rowIndex;
if (index 1) if (rowKey.firstRow) row = *rowKey.nextRow; else row = *rowKey.nextRow; <if (index <= 2) if (row) row = getRowIndex(rowKey); if (row) if (row) if (row) row.lastRow = row; row.lastRow = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) return; &*((*)rowKey.GetArray()) = <1;
if (inLine) &if (inLine) inLine.Init(); else <fprintf(stderr, "Comparing table %s<n", tableName); &if (inLine.Index == inLine.Index) fprintf(stderr, "Couldn't get table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey); fprintf(stderr, "Comparing table %sn", rowKey);
fprintf(stdout, "removeRow: %s<n", index);
if (index) &if (!sid) fprintf(stderr, "Row index: %d&n", index); sid.sidIndex = index; return -1; &else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
nrows = 0; if (idx 0) *idx = idx - rowIndex; &else *idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (rowIndex >= 0) removeRow(rowIndex);
if (index) &if (!sid) fprintf(stderr, "Row index: %dn", index); sid.sidIndex = index; return -1; <else if (index >= 0) fprintf(stderr, "Row index: %d", index); sid.sidIndex = index;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) &*index = getRowIndex(rowKey); if (index > 0) *index = getRowIndex(rowKey); <if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (index > 0) <if (rowIndex &1) <return; <if (index >= 1) if (rowIndex >= 0) /* skip over the row value and skip over the row value if it's * a row value. */ else /* skip over the row value */ else */ return;
if (itemIndex > 0) <return; <if (index <= 0) &if (itemIndex = 0) return;
int rowIndex = getRowIndex(rowKey); if (rowIndex 0) &id = rowIndex; &else id = rowIndex;
if (rowIndex >= 0) &if (rowIndex <rowIndex) if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index 0) </* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) <return; <else if (index 0) return; else return;
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey == mRowKey) if (rowKey == mRowKey) &mRowKey = mRowKey; <else <mRowKey = mRowKey; else mRowKey = mRowKey;
if (rowIndex <0) <if (!strcmp(rowIndex, "-")) <std::free(rowIndex); &else std::free(rowIndex); if (rowIndex >= index) break;
/* * We don't know how to get this row, * then remove the row if necessary. */ if (rowKey) &int rowIndex; for (index = getRowIndex(rowKey); index &rowIndex; index++) <*index = getRowIndex(rowKey); *index = &rowIndex; if (index >= rowIndex) if (index >= 0) /* We don't know how to remove rowIndex: */ return; rowIndex = rowIndex; if (index rowIndex) /* * Set the rowIndex to match the rowIndex to a rowIndex * of other rowIndex. */ if ((index >= rowIndex) && (index rowIndex)) if (index >= rowIndex) /* * XXX */ if (!(rowIndex--) index) /*
if (index == -1) r = 0; if (mRowIndex > 0) <if (index == -1) <mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex >= index) <return 0; if (rowIndex >= index) *rowIndex = rowIndex; else *rowIndex = rowIndex; return 0;
if (index >= 0) &if (instRow) removeRow(index); else &if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
if ((index = -1 && index >= 0)) <*index = 0; <else *index = 0;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex &= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* We can't get any index for row keys. */ if (! (rowKey.GetCount() == 1)) &return; *((*)rowKey.GetArray()) = &1&;
mPadding--; if (index >= 0) <mPadding--; &else <mPadding--;
if (!rowKey) if (rowIndex > 0) <removeRow(index); &else <fprintf(stderr, "Couldn't get row index");
if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex 0) &if (rowIndex >= index) return -1; rowIndex--; else &if (rowIndex >= index) return -1; if (rowIndex >= index) if (rowIndex = index) return -1;
if (rowIndex == -1) &return 0;
if (index 0) break; &if (itemIndex > 0) <PRInt32 i = index; i--; for (i = 0; i index; i++) if (index >= i) /* Note that it doesn't matter if it is no longer needed. */ i--; else /* Note that we can't getrowIndex indexes on the indexes, and they'll only work with the row indexes. */ rowIndexes = indexes; rowIndexes = index; for (i = rowIndexes; i i; i++) if (rowIndexes[i] == i) i++; else i--; rowIndexes[i] = i;
if (rowIndex == -1) &aResult = (aResult == -1)? 0 : 0; <else &aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
nsCOMPtr<nsIRow> row; if (!mPrimary) nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) <return (0); */ return (0);
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) &return NS_ERROR_FAILURE; &if (rowIndex <0) if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (intableRowCount) &int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) rowIndex = rowIndex -''; if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
&int index = 0; for (index = 0; index rowCount; index++) &if (row[index]) <if (itemIndex rowCount) if (!row[index]) return; return 0;
mTreeRow = new RowIndex(index); if (mTreeRow) if (rowIndex > mPos) &if (mPos > 0) <mPos = 0; mPos = 0; <else mPos = mPos;
if (increment) if (index > 0) <fprintf(stderr, "wrong row index &%s<n", index); else if (increment == -1) fprintf(stderr, "wrong row index %sn", index); else fprintf(stderr, "wrong row index %sn", index); if (index >= 0) fprintf(stderr, "wrong row index %sn", rowKey); else fprintf(stderr, "wrong row index %sn", rowKey);
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) <if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) <return NS_ERROR_FAILURE; &if (rowIndex &0) &if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex <= index) return 0; rowIndex = ret; if (index = index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else <if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
/* * Only remove the row by * index. */ if (index == -1) &rv = ret = 0; &<else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
r = getRowIndex(rowKey); if (r) &if (!r) <if (!removeRow(r, index)) break; <else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index 0) <rval = res = 0; break; &&if (index >= 0) rval = rval;
if (index) &if (rowIndex > 0) &if (index > 0) if (rowIndex = index) return (int)rowIndex; else if (rowIndex > index) if (rowIndex index) if (rowIndex > index) return (int)rowIndex; if (rowIndex index) rowIndex = getRowIndex(rowIndex); else if (rowIndex > index) rowIndex = getRowIndex(rowIndex); else if (rowIndex index) if (rowIndex) if (rowIndex index) else if (rowIndex index) rowIndex = (((*)((*)(*)(*)((*)((*)((*))
/* * In case this is an already in the row, we're going to get it now. */ if (index == -1) if (i == 1) /* We do not have a row that is in the row array. */ return 0; &if (rowIndex >= 1) <*(int)index = getRowIndex(rowIndex); if (index = 0) if (rowIndex) *(int)index = getRowIndex(rowIndex); *(int)index = 0; else if (index >= 0) *(int)index = getRowIndex(rowIndex); *(int)index = getRowIndex(rowIndex); else /* getRowIndex(rowIndex) = 0; */ return; *(int)index = 0; if (index >= 0)
if (index > 0) <if (colIndex &0) return; if (index <0) return; if (rowIndex <0) return; if (index 0) if (rowIndex - 0) return; else if (rowIndex 0) return; if (rowIndex 0) return; else if (rowIndex 0) return; if (rowIndex > 0) return;
nsCOMPtrnsIRow> row; if (!mPrimary) &nsCOMPtr&nsIRow> row(do_QueryInterface(row)); if (row) &return (0); */ return (0);
if (!selection || index == 0) if (rowKey) </* XXX */ if (!listCell) </* Allow row values */ else rowKey = getRowIndex(rowKey); else rowKey = 0;
if (!rowKey) &if (rowIndex > 0) &removeRow(index); <else fprintf(stderr, "Couldn't get row index");
<removeRow(index);
if (index == 0) &i++; &else <if (rowIndex >= rowKey) break;
if (item) &for (i = 0; i <index; i++) <*i = i; <if (!(row = index)) if (row) if (row.getPosition() == -1) return; if (row.mAvailableIndex == row.mAvailableIndex) i--; else i--; row.mAvailableIndex = row.mAvailableIndex; else i--; else if (row.mAvailableIndex == row.mAvailableIndex) row.mAvailableIndex = row.mAvailableIndex; row.mAvailableIndex = row.mAvailableIndex; else row.mAvailableIndex = row.mAvailableIndex; row.mAvailableInde
if (rowIndex == -1) <aResult = (aResult == -1)? 0 : 0; <else aResult = ((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(((int)((int)(((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)((int)(int)((int)(int)((int)((int)((int)(0))(0))(0))(0))(0))(0)));))) &if (index == index
if (itemIndex > 0) &return; &if (index = 0) <if (itemIndex = 0) return;
if (index == -1) <r = 0; if (mRowIndex > 0) <if (index == -1) mRowIndex = mRowIndex; else r = mRowIndex; else r = mRowIndex; else r = mRowIndex;
if (rowIndex &index) <if (rowIndex >= 0) <ret = removeRow(rowIndex); if (ret == -1) *ret = ret; else *ret = ret; else if (rowIndex >= 0) ret = ret; else *ret = ret; else ret = ret;
if (index <0) &/* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) return; else if (index 0) return; else return;
if (index >= 0) <if (index 0) &if (inProcessNode) &if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (rowKey == mRowKey) &if (rowKey == mRowKey) mRowKey = mRowKey; &else mRowKey = mRowKey; else mRowKey = mRowKey;
if (index 0) /* do not change the index of a row, as is * in the row list's * column column and have the row row. */ if (index >= 0) &return; <else if (index 0) return; else return;
if (index >= index) <mRows.removeElement(index); else &if (index = index) mRows.removeElement(index); if (index >= index) mRows.removeElement(index); else mRows.removeElement(index);
if (rowIndex = 0) nsCOMPtr&nsIContent> c(do_QueryInterface(rowIndex)); if (c) rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (rowIndex == 0) &*rowIndex = index; else <if (rowIndex 0) *rowIndex = 0; else *rowIndex = 0;
/* Recycle the row and the index of * the row in the row (see the ifdef * * here. */ if (index == -1) &if (segmentCount == -1) </* Recycle the row in the row (see ifdef */ if (index == -1) row = 0; break; row = -1; else row = -1; break; */ if (index == -1) row = -1; else row = -1; row = -1) row = -1) /* Recycle the row on the row */ if (index == -1) */ */ */ return -1; else /* Recycle the row */ */ row = -1; */ else /* Recycle the row
nrows = 0; if (idx &0) &*idx = idx - rowIndex; else &*idx = idx - rowIndex; *idx = rowIndex; *idx = idx; *idx = idx;
if (getRowIndex(rowKey) index) <break; &if (getRowIndex(rowKey) &index) index = getRowIndex(rowKey); if (getRowIndex(rowKey) index) index = -1; if (getRowIndex(rowKey) index) index = -1; else if (getRowIndex(rowKey) > index) index = getRowIndex(rowKey); if (getRowIndex(rowIndex) index) index = getRowIndex(rowKey); else index = 0; else /* XXX: Can't get rowIndex of rows. */ if ((index > index) && (index >= -1)) if ((index >= index) && (index index)) /* If rowIndex must be -1,
if (intableRowCount) <int rowIndex; int rowIndex = -1; rowIndex -=''; /* Remove the row. */ if (index > 0) <rowIndex = rowIndex -''; <if (rowIndex rowIndex) if (rowIndex rowIndex) if (rowIndex > 0) if (rowIndex 0) rowIndex = rowIndex; else if (rowIndex > rowIndex) if (rowIndex rowIndex) rowIndex = rowIndex;
if (item) ret = item.rowIndex; if (ret == -1) <ret = item.rowIndex; &else ret = row.rowIndex;
if (index >= 0) rval = 0; &else &rval = 0;
if (index >= 0) <if (instRow) <removeRow(index); &else <if (!instRow) instRow = 0; else instRow = rowKey; else if (instRow) instRow = rowKey; else instRow = index;
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <else &rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index <0) <*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); &if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
if (rowIndex &= 0) <nsCOMPtr<nsIContent> c(do_QueryInterface(rowIndex)); if (c) <rv = mContent.GetContent(getter_AddRefs(c)); if (NS_FAILED(rv)) return rv;
if (index > 0) &ret = &index, rowIndex &;
if (index == 0) i++; else <if (rowIndex >= rowKey) break;
if (rowIndex >= 0) if (rowIndex <rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
r = getRowIndex(rowKey); if (r) <if (!r) if (!removeRow(r, index)) &break; else r = removeRow(r, index); if (r) r = getRowIndex(rowKey); if (r == -1) r = r; else r = r; r = r; if (r) if (r) r = r; if (r) r = r; r = r; if (r == null) r = r; if (r) r = r; if (r == null) r = r; if (r == null) r = r; r = r; else r
if (index &0) &delete row; <if (index > 0) <if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
/* * Only remove the row by * index. */ if (index == -1) <rv = ret = 0; <&else <rv = ret.removeRow(index); if (NS_FAILED(rv)) ret = 0; else ret = 0;
if (rowKey) &if (rowKey) <rowKey = mTable[rowKey]; if (rowKey) <if (!rowKey) return; else return; else return;
if (index >= 0) &if (index <0) <if (inProcessNode) if (idx == 0) break; else if (idx > 0) idx = idx; else idx = idx; else if (idx 0) idx = idx; else idx = idx; if (idx 0) idx = idx - idx;
if (index = 0) /* XXX */ if ((index >= 0) || (index <= 0)) delete row; else /* XXX */
&if (index) <struct rowIndex *row = (struct rowIndex *)rowKey; if (row.rowIndex >= 0) <if (row.rowIndex) &int i; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; else row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex; row.rowIndex = row.rowIndex;
if (rowKey == '<0') return; if (rowKey == '&0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '1') return; if (rowKey == '0') return; rowKey = '0'; if (rowKey == '0') return; rowKey = '1'; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '0') return; if (rowKey == '0') return; if (rowKey == '1') return; if (rowKey == '2') return; rowKey =
if (rowIndex >= 0) <if (rowIndex &rowIndex) &if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (rowIndex >= 0) <if (rowIndex rowIndex) <if (index >= rowIndex) &return -1; if (rowIndex 0) ret = rowIndex; else ret = rowIndex - rowIndex;
if (index 0) &delete row; &if (index > 0) if (!(row == -1) ||!(*row == -1)) if (row) return; row = 0; if (rowIndex 0) if (!(rowIndex > 0)) if (rowIndex 0) if (rowIndex 0) if (rowIndex 0) row = rowIndex; row = rowIndex; else if (rowIndex 0) row = 0; row = rowIndex; row = rowIndex; row = rowIndex; if (rowIndex >= 0) if (rowIndex rowIndex) row = rowIndex; if (rowIndex 0) *row = rowIndex; else if ((rowIndex
if ((rowIndex = getRowIndex(rowKey))!= 0) break; if (rowIndex <index) <*int index = getRowIndex(rowKey); delete rowIndex; if ((rowIndex >= index) && (rowIndex rowIndex)) /* in the row indexes for each row */ return 0; else if (rowIndex rowIndex) /* it's * a row indexes for all rowIndexes. */ if (rowIndex n) /* * No row indexes found, get the rowIndexes from this row * to be able to * get it here. */ if (rowIndex > rowIndex) if (rowIndex n) if (rowIndex rowIndexes) nsAutoString row = (char *)rowInde
if (rowKey) &struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) aRow = row; &if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey) <struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (rowKey) struct aRow *row = ((unsigned long)rowKey).value; if (row == null) &if (row == -1) <aRow = row; <if (*row) aRow = 0; if (row == null) aRow = *row; if (row == null) aRow = *row; else aRow = row; if (row == null) aRow = 0; if (aRow == null) aRow = (*(*(*(*)).rowIndex))); else aRow = (*(*(*)).rowIndex)) * row; if (aRow == null) aRow = (*(*)).row
if (!removeRow(index)) &return;
int index = getRowIndex(rowKey); if (index >= index) return 0; ret = NS_OK; if (! ret) return ret; if (rowIndex = index) return 0; rowIndex = ret; if (index <= index) return 0; if (index >= index) return 0; ret = (ret) rowIndex; <else &if (index index) ret = (ret) rowIndex; if (rowIndex >= index) return 0; else if (rowIndex index) return 0; if (rowIndex >= index) return 0; if (rowIndex >= index) return 0; ret = (ret) rowIndex; else ret = (ret) rowIndex;
if (int) <char h; struct rowState rst; rst.segmentLength = 0; if (!h) <rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; if (!rst.segmentIndex 0) rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.segmentIndex = 0; rst.
/* * Remove row if it's a row (which might be a row) */ if (!rowIndex) return NS_ERROR_FAILURE; if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex <0) <if (rowIndex >= index) return NS_ERROR_FAILURE; if (rowIndex 0) return NS_ERROR_FAILURE;
if (!selection || index == 0) if (rowKey) &/* XXX */ if (!listCell) </* Allow row values */ else &rowKey = getRowIndex(rowKey); else rowKey = 0;
/* * We don't want to set the row index in this instance of * a row if it isn't * a row index. */ if (index &0) &*index = getRowIndex(rowKey); if (index > 0) &*index = getRowIndex(rowKey); if (index 0) /* Remove row index for this table. */ if (index = index) if (index >= index) /* * Remove row index to the table */ index = getRowIndex(rowKey); if (index >= index) /* Remove row index to the table. */ if (index index) /* * Remove row index from the table. */ if (index >= index) if (index index) /* if (index >= index) /* * Remove row index from the table. */ if (index =
